"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WordScanner = void 0;
const documentParser_1 = require("../../parser/documentParser");
const stringUtilities_1 = require("../../utilities/stringUtilities");
class WordScanner {
    static findRightBeighboringNextPunctuation(index, text, tabSize = 4) {
        text = text.replace("\t", ' '.repeat(tabSize));
        let okayToBreak = false;
        for (let i = index + 1; i < text.length; i++) {
            const cur = text[i];
            if (stringUtilities_1.StringUtilities.ctypeSpace(cur)) {
                okayToBreak = true;
            }
            if (okayToBreak && (stringUtilities_1.StringUtilities.ctypeAlpha(cur) || stringUtilities_1.StringUtilities.ctypeDigit(cur))) {
                return null;
            }
            if (stringUtilities_1.StringUtilities.ctypePunct(cur) || cur == documentParser_1.DocumentParser.String_Terminator_SingleQuote || cur == documentParser_1.DocumentParser.String_Terminator_DoubleQuote) {
                return cur;
            }
        }
        return null;
    }
    static findRightNeighboringNextAlphaNumeric(index, text, tabSize = 4) {
        text = text.replace("\t", ' '.repeat(tabSize));
        let okayToBreak = false;
        for (let i = index + 1; i < text.length; i++) {
            const cur = text[i];
            if (stringUtilities_1.StringUtilities.ctypeSpace(cur) || (stringUtilities_1.StringUtilities.ctypePunct(cur) && cur != documentParser_1.DocumentParser.Punctuation_Underscore)) {
                okayToBreak = true;
            }
            if (okayToBreak && (stringUtilities_1.StringUtilities.ctypeAlpha(cur) || stringUtilities_1.StringUtilities.ctypeDigit(cur))) {
                return i + 1;
            }
        }
        return null;
    }
    static findLeftNeighboringNextPunctuation(index, text, tabSize = 4) {
        text = text.replace("\t", ' '.repeat(tabSize));
        let okayToBreak = false;
        for (let i = index - 2; i >= 0; i--) {
            const cur = text[i];
            if (stringUtilities_1.StringUtilities.ctypeSpace(cur)) {
                okayToBreak = true;
            }
            if (okayToBreak && (stringUtilities_1.StringUtilities.ctypeAlpha(cur) || stringUtilities_1.StringUtilities.ctypeDigit(cur))) {
                return null;
            }
            if (stringUtilities_1.StringUtilities.ctypePunct(cur)) {
                return cur;
            }
        }
        return null;
    }
    static findLeftNeighboringNextAlphaNumeric(index, text, tabSize = 4) {
        text = text.replace("\t", ' '.repeat(tabSize));
        let okayToBreak = false;
        for (let i = index - 1; i >= 0; i--) {
            const cur = text[i];
            if (stringUtilities_1.StringUtilities.ctypeSpace(cur) || (stringUtilities_1.StringUtilities.ctypePunct(cur) && cur != documentParser_1.DocumentParser.Punctuation_Underscore)) {
                okayToBreak = true;
            }
            if (okayToBreak && (stringUtilities_1.StringUtilities.ctypeAlpha(cur) || stringUtilities_1.StringUtilities.ctypeDigit(cur))) {
                return i + 1;
            }
        }
        return null;
    }
    static scanWordAt(index, text, tabSize = 4) {
        text = text.replace("\t", ' '.repeat(tabSize));
        if (index < 0 || index > text.length) {
            return null;
        }
        const leftChars = [], rightChars = [];
        for (let i = index - 1; i >= 0; i--) {
            const cur = text[i];
            if ((stringUtilities_1.StringUtilities.ctypePunct(cur) && cur != documentParser_1.DocumentParser.Punctuation_Underscore) || stringUtilities_1.StringUtilities.ctypeSpace(cur)) {
                break;
            }
            leftChars.push(cur);
        }
        for (let i = index; i < text.length; i++) {
            const cur = text[i];
            if ((stringUtilities_1.StringUtilities.ctypePunct(cur) && cur != documentParser_1.DocumentParser.Punctuation_Underscore) || stringUtilities_1.StringUtilities.ctypeSpace(cur)) {
                break;
            }
            rightChars.push(cur);
        }
        return leftChars.reverse().join('') + rightChars.join('');
    }
}
exports.WordScanner = WordScanner;
//# sourceMappingURL=wordScanner.js.map