"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("../formatting/prettier/utils");
suite('Directives Formatting', () => {
    test('it can format PHP in directives', () => {
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(`@directive   ($test  + $that-$another   + $thing)`).trim(), `@directive($test + $that - $another + $thing)`);
    });
    test('it preserves content if PHP is invalid', () => {
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(`@directive   ($test  ++++ $that-$another   + $thing)`).trim(), `@directive($test  ++++ $that-$another   + $thing)`);
    });
    test('it indents nicely', () => {
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(`@section("messages")
    <div class="alert success">
        <p><strong>Success!</strong></p>
        @foreach ($success->all('<p>:message</p>') as $msg)
            {{ $msg }}
        @endforeach
    </div>
@show`).trim(), `@section("messages")
<div class="alert success">
    <p><strong>Success!</strong></p>
    @foreach ($success->all('<p>:message</p>') as $msg)
        {{ $msg }}
    @endforeach
</div>
@show`);
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(`
@section("messages")
<div class="alert success">
<p><strong>Success!</strong></p>
@foreach ($success->all('<p>:message</p>') as $msg)
{{ $msg }}
@endforeach
</div>
@show
`).trim(), `@section("messages")
<div class="alert success">
    <p><strong>Success!</strong></p>
    @foreach ($success->all('<p>:message</p>') as $msg)
        {{ $msg }}
    @endforeach
</div>
@show`);
    });
    test('it indents if HTML is on separate lines', () => {
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(`<div>
            @directive   ($test  + $that-$another   + $thing)
                </div>`).trim(), `<div>
    @directive($test + $that - $another + $thing)
</div>`);
    });
    test('it preserves same line if HTML is on same line', () => {
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(`<div>@directive   ($test  + $that-$another   + $thing)</div>`).trim(), `<div>@directive($test + $that - $another + $thing)</div>`);
    });
    test('it can indent paired directives without any HTML hints', () => {
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(`
<div>
    @pair
dasdfsdf
asdf
@endpair
            </div>`).trim(), `<div>
    @pair
        dasdfsdf asdf
    @endpair
</div>`);
    });
    test('it can indent paired directives with HTML', () => {
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(`
<div>
    @pair

<div>
    @pair
    <p>Test one.</p>
    
    
<div>
    @pair

<div>
    @pair
    <p>Test two.</p>


<div>
    @pair

<div>
    @pair
    <p>Test three.</p>
    @endpair
</div>

@endpair
            </div>

    @endpair
</div>

@endpair
            </div>

    @endpair
</div>

@endpair
            </div>`).trim(), `<div>
    @pair
        <div>
            @pair
                <p>Test one.</p>

                <div>
                    @pair
                        <div>
                            @pair
                                <p>Test two.</p>

                                <div>
                                    @pair
                                        <div>
                                            @pair
                                                <p>Test three.</p>
                                            @endpair
                                        </div>
                                    @endpair
                                </div>
                            @endpair
                        </div>
                    @endpair
                </div>
            @endpair
        </div>
    @endpair
</div>`);
    });
    test('virtual wrappers are not created for paired directives containing only inlined content', () => {
        const input = `
                @can('create', App\\Models\\User::class)
                {!! $something_here !!}
                @endcan
`;
        const out = `@can('create', App\\Models\\User::class)
    {!! $something_here !!}
@endcan
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it does not blindly remove newlines when formatting directive params', () => {
        const input = `@class([
            'foo' => true,
                    'bar'       => false,
                                 'bar2'                   => false,
        ])`;
        const out = `@class([
    "foo" => true,
    "bar" => false,
    "bar2" => false,
])
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it respects newline placement', () => {
        const input = `@class([
            'filament antialiased min-h-screen js-focus-visible',
            'dark' => filament()->hasDarkModeForced(),
        ])`;
        const out = `@class([
    "filament js-focus-visible min-h-screen antialiased",
    "dark" => filament()->hasDarkModeForced(),
])
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(out), out);
    });
    test('it indents class directives nicely', () => {
        const input = `<div>
    <span @class([
        'some classes',
    ])>
        {{ $foo }}
    </span>
</div>`;
        const out = `<div>
    <span @class([
        "some classes",
    ])>
        {{ $foo }}
    </span>
</div>
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(out), out);
        const input2 = `<div>
    <span @class([
        'some classes',
    ])>
        {{ $foo }}
        
        </span> </div>`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input2), out);
    });
    test('it indents class directives nicely2', () => {
        const input = `<x-foo
@class([
    'foo',
    'foo bar baz something long very very long',
])
/>`;
        const output = `<x-foo
    @class([
        "foo",
        "foo bar baz something long very very long",
    ])
/>
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), output);
    });
    test('it pairs guest', () => {
        const input = `@guest
<div></div>
@endguest`;
        const out = `@guest
    <div></div>
@endguest
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it pairs unless', () => {
        const input = `@unless
<div></div>
@endunless`;
        const out = `@unless
    <div></div>
@endunless
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it pairs sectionMissing', () => {
        const input = `@sectionMissing
<div></div>
@endsectionMissing`;
        const out = `@sectionMissing
    <div></div>
@endsectionMissing
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it pairs hasSection', () => {
        const input = `@hasSection
<div></div>
@endhasSection`;
        const out = `@hasSection
    <div></div>
@endhasSection
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it pairs auth', () => {
        const input = `@auth
<div></div>
@endauth`;
        const out = `@auth
    <div></div>
@endauth
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it pairs env', () => {
        const input = `@env
<div></div>
@endenv`;
        const out = `@env
    <div></div>
@endenv
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it pairs isset', () => {
        const input = `@isset
<div></div>
@endisset`;
        const out = `@isset
    <div></div>
@endisset
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it pairs cannot', () => {
        const input = `@cannot
<div></div>
@endcannot`;
        const out = `@cannot
    <div></div>
@endcannot
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it pairs canany', () => {
        const input = `@canany
<div></div>
@endcanany`;
        const out = `@canany
    <div></div>
@endcanany
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it pairs hasSection', () => {
        const input = `@hasSection
<div></div>
@endhasSection`;
        const out = `@hasSection
    <div></div>
@endhasSection
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it pairs production', () => {
        const input = `@production
<div></div>
@endproduction`;
        const out = `@production
    <div></div>
@endproduction
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it formats class with match nicely', () => {
        const input = `
@class([
    'foo',
    match ($color) {
        'blue' => 'text-blue-500',
        'green' => 'text-green-500',
    },
])`;
        const output = `@class([
    "foo",
    match ($color) {
        "blue" => "text-blue-500",
        "green" => "text-green-500",
    },
])
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), output);
    });
    test('it formats subdocuments correctly', () => {
        const input = `

               @once
               <li>
               <button
                   type="button"
                   wire:loading.attr="disabled"
               >
                   <x-component::name
                       class="w-4 h-4 text-primary-500"
                       wire:loading.delay
                       wire:target="{{ one }} {{ two }}"
                   />
               </button>
           </li>
               @endonce
`;
        const output = `@once
    <li>
        <button type="button" wire:loading.attr="disabled">
            <x-component::name
                class="text-primary-500 h-4 w-4"
                wire:loading.delay
                wire:target="{{ one }} {{ two }}"
            />
        </button>
    </li>
@endonce
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), output);
    });
    test('it does not trash ifs inside elements', () => {
        const input = `

@if ($that)
    <div @if ($somethingElse) this! @endif>Hello, world.</div>
@endif
`;
        const out = `@if ($that)
    <div @if ($somethingElse) this! @endif>Hello, world.</div>
@endif
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('it reflows operators inside directive simple arrays', () => {
        const input = `
@class([
    'foo' => ! true,
])
`;
        const output = `@class([
    "foo" => ! true,
])
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), output);
    });
    test('it does not trash complex arrays', () => {
        const input = `@class([
            'text-sm font-medium leading-4',
            'text-gray-700' => !$error,
            'dark:text-gray-300' => !$error && config('forms.dark_mode'),
            'text-danger-700' => $error,
            'dark:text-danger-400' => $error && config('forms.dark_mode'),
        ])`;
        const output = `@class([
    "text-sm font-medium leading-4",
    "text-gray-700" => ! $error,
    "dark:text-gray-300" => ! $error && config("forms.dark_mode"),
    "text-danger-700" => $error,
    "dark:text-danger-400" => $error && config("forms.dark_mode"),
])
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), output);
    });
    test('it can format mixed directive arg arrays', () => {
        const input = `@class([
    'grid auto-cols-fr grid-flow-col gap-2 text-sm',
    'ms-8' => $active,
])
`;
        const out = `@class([
    "grid auto-cols-fr grid-flow-col gap-2 text-sm",
    "ms-8" => $active,
])
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
    });
    test('really long directive array args without keys can be placed on separate lines', () => {
        const input = `
<div>
<div class="relative group max-w-md">
        <span
            @class([
                'absolute inset-y-0 left-0 flex items-center justify-center w-10 h-10 text-gray-500 pointer-events-none group-focus-within:text-primary-500',
                'dark:text-gray-400' => config('filament.dark_mode'),
            ])
        >
        </span>
        </div>
        </div>
`;
        const out = `<div>
    <div class="group relative max-w-md">
        <span
            @class([
                "group-focus-within:text-primary-500 pointer-events-none absolute inset-y-0 left-0 flex h-10 w-10 items-center justify-center text-gray-500",
                "dark:text-gray-400" => config("filament.dark_mode"),
            ])
        ></span>
    </div>
</div>
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(input), out);
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(out), out);
    });
    test('directives inside html classes do not wreck output', () => {
        const template = `<div class="@something here @endSomething h-3 rounded-full border border-white"></div>`;
        const out = `<div
    class="@something here @endSomething h-3 rounded-full border border-white"
></div>
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeStringWithPint)(template), out);
    });
});
//# sourceMappingURL=formatter_directives.test.js.map