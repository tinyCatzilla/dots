"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const bladeDocument_1 = require("../document/bladeDocument");
const nodes_1 = require("../nodes/nodes");
const assertions_1 = require("./testUtils/assertions");
suite('Inline PHP Parsing', () => {
    test('it parses inline PHP regions', () => {
        const nodes = bladeDocument_1.BladeDocument.fromText(`


<html>
        <?php

$test = 'this';

?>
        hello <?php echo 'world<?php ?>'; ?>
</html>`).getAllNodes();
        (0, assertions_1.assertCount)(5, nodes);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[0]);
        (0, assertions_1.assertLiteralContent)("\n\n\n<html>\n        ", nodes[0]);
        (0, assertions_1.assertInstanceOf)(nodes_1.InlinePhpNode, nodes[1]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[2]);
        (0, assertions_1.assertLiteralContent)("\n        hello ", nodes[2]);
        (0, assertions_1.assertInstanceOf)(nodes_1.InlinePhpNode, nodes[3]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[4]);
        (0, assertions_1.assertLiteralContent)("\n</html>", nodes[4]);
        const php1 = nodes[1], php2 = nodes[3];
        assert_1.default.strictEqual(php1.sourceContent, "<?php\n\n$test = 'this';\n\n?>");
        assert_1.default.strictEqual(php2.sourceContent, "<?php echo 'world<?php ?>'; ?>");
    });
    test('it resolves offsets correctly', () => {
        const nodes = bladeDocument_1.BladeDocument.fromText(`a<?php ?>b<?php ?>c<?php ?>d`).getAllNodes();
        (0, assertions_1.assertCount)(7, nodes);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[0]);
        (0, assertions_1.assertLiteralContent)("a", nodes[0]);
        (0, assertions_1.assertInstanceOf)(nodes_1.InlinePhpNode, nodes[1]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[2]);
        (0, assertions_1.assertLiteralContent)("b", nodes[2]);
        (0, assertions_1.assertInstanceOf)(nodes_1.InlinePhpNode, nodes[3]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[4]);
        (0, assertions_1.assertLiteralContent)("c", nodes[4]);
        (0, assertions_1.assertInstanceOf)(nodes_1.InlinePhpNode, nodes[5]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[6]);
        (0, assertions_1.assertLiteralContent)("d", nodes[6]);
    });
    test('it resolves shorthand PHP offsets correctly', () => {
        const nodes = bladeDocument_1.BladeDocument.fromText(`a<?= ?>b<?= ?>c<?= ?>d`).getAllNodes();
        (0, assertions_1.assertCount)(7, nodes);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[0]);
        (0, assertions_1.assertLiteralContent)("a", nodes[0]);
        (0, assertions_1.assertInstanceOf)(nodes_1.ShorthandInlinePhpNode, nodes[1]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[2]);
        (0, assertions_1.assertLiteralContent)("b", nodes[2]);
        (0, assertions_1.assertInstanceOf)(nodes_1.ShorthandInlinePhpNode, nodes[3]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[4]);
        (0, assertions_1.assertLiteralContent)("c", nodes[4]);
        (0, assertions_1.assertInstanceOf)(nodes_1.ShorthandInlinePhpNode, nodes[5]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[6]);
        (0, assertions_1.assertLiteralContent)("d", nodes[6]);
    });
    test('it resolves fragment positions', () => {
        const nodes = bladeDocument_1.BladeDocument.fromText(`<<?php echo $element; ?>>
    <?php echo $inline; ?>
    <p>Text <?php echo $inline; ?> here.</p>
</<?php echo $element; ?>>`).getAllNodes();
        (0, assertions_1.assertCount)(9, nodes);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[0]);
        (0, assertions_1.assertLiteralContent)("<", nodes[0]);
        (0, assertions_1.assertInstanceOf)(nodes_1.InlinePhpNode, nodes[1]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[2]);
        (0, assertions_1.assertLiteralContent)(">\n    ", nodes[2]);
        (0, assertions_1.assertInstanceOf)(nodes_1.InlinePhpNode, nodes[3]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[4]);
        (0, assertions_1.assertLiteralContent)("\n    <p>Text ", nodes[4]);
        (0, assertions_1.assertInstanceOf)(nodes_1.InlinePhpNode, nodes[5]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[6]);
        (0, assertions_1.assertLiteralContent)(" here.</p>\n</", nodes[6]);
        (0, assertions_1.assertInstanceOf)(nodes_1.InlinePhpNode, nodes[7]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[8]);
        (0, assertions_1.assertLiteralContent)(">", nodes[8]);
        const php1 = nodes[1], php2 = nodes[3], php3 = nodes[5], php4 = nodes[7];
        assert_1.default.strictEqual(php1.fragmentPosition, nodes_1.FragmentPosition.IsDynamicFragmentName, 'php1');
        assert_1.default.strictEqual(php2.fragmentPosition, nodes_1.FragmentPosition.Unresolved, 'php2');
        assert_1.default.strictEqual(php3.fragmentPosition, nodes_1.FragmentPosition.Unresolved, 'php3');
        assert_1.default.strictEqual(php4.fragmentPosition, nodes_1.FragmentPosition.IsDynamicFragmentName, 'php4');
    });
    test('it resolves shorthand PHP fragment positions', () => {
        const nodes = bladeDocument_1.BladeDocument.fromText(`<<?= $element; ?>>
    <?= $inline; ?>
    <p>Text <?= $inline; ?> here.</p>
</<?= $element; ?>>`).getAllNodes();
        (0, assertions_1.assertCount)(9, nodes);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[0]);
        (0, assertions_1.assertLiteralContent)("<", nodes[0]);
        (0, assertions_1.assertInstanceOf)(nodes_1.ShorthandInlinePhpNode, nodes[1]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[2]);
        (0, assertions_1.assertLiteralContent)(">\n    ", nodes[2]);
        (0, assertions_1.assertInstanceOf)(nodes_1.ShorthandInlinePhpNode, nodes[3]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[4]);
        (0, assertions_1.assertLiteralContent)("\n    <p>Text ", nodes[4]);
        (0, assertions_1.assertInstanceOf)(nodes_1.ShorthandInlinePhpNode, nodes[5]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[6]);
        (0, assertions_1.assertLiteralContent)(" here.</p>\n</", nodes[6]);
        (0, assertions_1.assertInstanceOf)(nodes_1.ShorthandInlinePhpNode, nodes[7]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[8]);
        (0, assertions_1.assertLiteralContent)(">", nodes[8]);
        const php1 = nodes[1], php2 = nodes[3], php3 = nodes[5], php4 = nodes[7];
        assert_1.default.strictEqual(php1.fragmentPosition, nodes_1.FragmentPosition.IsDynamicFragmentName, 'php1');
        assert_1.default.strictEqual(php2.fragmentPosition, nodes_1.FragmentPosition.Unresolved, 'php2');
        assert_1.default.strictEqual(php3.fragmentPosition, nodes_1.FragmentPosition.Unresolved, 'php3');
        assert_1.default.strictEqual(php4.fragmentPosition, nodes_1.FragmentPosition.IsDynamicFragmentName, 'php4');
    });
});
//# sourceMappingURL=inline_php.test.js.map