"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpeculativeConditionAnalyzer = void 0;
const bladeDocument_1 = require("../document/bladeDocument");
const helpers_1 = require("../nodes/helpers");
const nodes_1 = require("../nodes/nodes");
const pairManager_1 = require("./pairManager");
class SpeculativeConditionAnalyzer {
    static analyze(nodes, document) {
        const reduced = [];
        nodes.forEach((node) => {
            if (node instanceof nodes_1.DirectiveNode && node.isClosedBy != null) {
                const elseNode = node.findFirstChildDirectiveOfType('else');
                if (elseNode != null && elseNode.isClosedBy == null) {
                    reduced.push(this.convertToConditionalNode(node, elseNode, document));
                }
                else {
                    reduced.push(node);
                }
            }
            else {
                reduced.push(node);
            }
        });
        return reduced;
    }
    static convertToConditionalNode(node, elseNode, document) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
        const condition = new nodes_1.ConditionNode(), finalClosing = node.getFinalClosingDirective(), children = node.children, branchOneNodes = [];
        let branchTwoNodes = [];
        const tail = children.pop();
        condition.withParser(document);
        condition.parent = node.parent;
        condition.startPosition = node.startPosition;
        condition.endPosition = finalClosing.endPosition;
        condition.constructedFrom = node;
        const startOffset = ((_b = (_a = node.startPosition) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : 0) - 1, length = (_d = (_c = finalClosing === null || finalClosing === void 0 ? void 0 : finalClosing.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0 - ((_f = (_e = node.startPosition) === null || _e === void 0 ? void 0 : _e.index) !== null && _f !== void 0 ? _f : 0), endOffset = startOffset + length;
        condition.nodeContent = document.getText(startOffset, length);
        condition.offset = {
            start: startOffset,
            end: endOffset,
            length: length
        };
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child instanceof nodes_1.DirectiveNode && child.refId == elseNode.refId) {
                branchTwoNodes = children.slice(i + 1);
                break;
            }
            else {
                branchOneNodes.push(child);
            }
        }
        const branchOne = new nodes_1.ExecutionBranchNode(), branchTwo = new nodes_1.ExecutionBranchNode();
        branchOne.withParser(document);
        branchTwo.withParser(document);
        node.isClosedBy = elseNode;
        elseNode.isOpenedBy = node;
        tail.isOpenedBy = elseNode;
        elseNode.isClosedBy = tail;
        const branchOneChildDocNodes = [...branchOneNodes], branchTwoChildDocNodes = [...branchTwoNodes];
        branchOneNodes.push(elseNode);
        branchOne.head = node;
        branchOne.nodes = branchOneNodes;
        branchOne.index = node.index;
        const branchOneStart = ((_h = (_g = node.endPosition) === null || _g === void 0 ? void 0 : _g.index) !== null && _h !== void 0 ? _h : 0), branchOneEnd = ((_l = (_k = (_j = node.isClosedBy) === null || _j === void 0 ? void 0 : _j.startPosition) === null || _k === void 0 ? void 0 : _k.index) !== null && _l !== void 0 ? _l : 0) - 1, branchOneLength = branchOneEnd - branchOneStart, branchOneDocStart = ((_o = (_m = node.startPosition) === null || _m === void 0 ? void 0 : _m.index) !== null && _o !== void 0 ? _o : 0) - 1, branchOneDocEnd = ((_r = (_q = (_p = node.isClosedBy) === null || _p === void 0 ? void 0 : _p.startPosition) === null || _q === void 0 ? void 0 : _q.index) !== null && _r !== void 0 ? _r : 0) - 1, branchOneDocLength = branchOneDocEnd - branchOneDocStart;
        branchOne.innerContent = document.getText(branchOneStart, branchOneEnd);
        branchOne.documentContent = document.getText(branchOneDocStart, branchOneDocEnd);
        branchOne.innerOffset = {
            start: branchOneStart,
            end: branchOneEnd,
            length: branchOneLength
        };
        branchOne.offset = {
            start: branchOneDocStart,
            end: branchOneDocEnd,
            length: branchOneDocLength
        };
        branchTwoNodes.push(tail);
        branchTwo.head = elseNode;
        branchTwo.nodes = branchTwoNodes;
        branchTwo.index = elseNode.index;
        const branchTwoStart = ((_t = (_s = elseNode.endPosition) === null || _s === void 0 ? void 0 : _s.index) !== null && _t !== void 0 ? _t : 0), branchTwoEnd = ((_w = (_v = (_u = elseNode.isClosedBy) === null || _u === void 0 ? void 0 : _u.startPosition) === null || _v === void 0 ? void 0 : _v.index) !== null && _w !== void 0 ? _w : 0) - 1, branchTwoLength = branchTwoEnd - branchTwoStart, branchTwoDocStart = ((_y = (_x = elseNode.startPosition) === null || _x === void 0 ? void 0 : _x.index) !== null && _y !== void 0 ? _y : 0) - 1, branchTwoDocEnd = ((_1 = (_0 = (_z = elseNode.isClosedBy) === null || _z === void 0 ? void 0 : _z.startPosition) === null || _0 === void 0 ? void 0 : _0.index) !== null && _1 !== void 0 ? _1 : 0) - 1, branchTwoDocLength = branchTwoDocEnd - branchTwoDocStart;
        branchTwo.innerContent = document.getText(branchTwoStart, branchTwoEnd);
        branchTwo.documentContent = document.getText(branchTwoDocStart, branchTwoDocEnd);
        branchTwo.innerOffset = {
            start: branchTwoStart,
            end: branchTwoEnd,
            length: branchTwoLength
        };
        branchTwo.offset = {
            start: branchTwoDocStart,
            end: branchTwoDocEnd,
            length: branchTwoDocLength
        };
        condition.chain = [node.index, elseNode.index];
        condition.logicBranches.push(branchOne);
        condition.logicBranches.push(branchTwo);
        branchOne.startPosition = branchOne.nodes[0].startPosition;
        branchOne.endPosition = branchOne.nodes[branchOne.nodes.length - 1].startPosition;
        branchOne.childDocument = bladeDocument_1.BladeDocument.childFromText(document.getNodeText(branchOneChildDocNodes), document, (0, helpers_1.getStartPosition)(branchOneChildDocNodes));
        branchTwo.childDocument = bladeDocument_1.BladeDocument.childFromText(document.getNodeText(branchTwoChildDocNodes), document, (0, helpers_1.getStartPosition)(branchTwoChildDocNodes));
        branchTwo.startPosition = branchTwo.nodes[0].startPosition;
        branchTwo.endPosition = branchTwo.nodes[branchTwo.nodes.length - 1].startPosition;
        pairManager_1.PairManager.registerSpeculativeCondition(node.directiveName);
        return condition;
    }
}
exports.SpeculativeConditionAnalyzer = SpeculativeConditionAnalyzer;
//# sourceMappingURL=speculativeConditionAnalyzer.js.map