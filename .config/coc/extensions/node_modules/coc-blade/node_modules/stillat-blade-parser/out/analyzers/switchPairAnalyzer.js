"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwitchPairAnalyzer = void 0;
const bladeDocument_1 = require("../document/bladeDocument");
const helpers_1 = require("../nodes/helpers");
const nodes_1 = require("../nodes/nodes");
const bladeKeywords_1 = require("../parser/bladeKeywords");
class SwitchPairAnalyzer {
    static associate(nodes, document) {
        const reduced = [];
        nodes.forEach((node) => {
            if (node instanceof nodes_1.DirectiveNode && node.directiveName.toLowerCase() == bladeKeywords_1.BladeKeywords.Switch) {
                reduced.push(this.createSwitchNode(node, document));
            }
            else {
                reduced.push(node);
            }
        });
        return reduced;
    }
    static createSwitchNode(node, parser) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7;
        const switchNode = new nodes_1.SwitchStatementNode(), children = node.children;
        switchNode.originalNode = node;
        switchNode.startPosition = node.startPosition;
        switchNode.endPosition = node.getFinalClosingDirective().endPosition;
        switchNode.parent = node.parent;
        switchNode.withParser(parser);
        switchNode.constructedFrom = node;
        let currentNodes = [];
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child instanceof nodes_1.DirectiveNode && child.name == bladeKeywords_1.BladeKeywords.Switch) {
                // Skip this for now. We will handle this with the child document.
                i += child.children.length;
            }
            if (child instanceof nodes_1.DirectiveNode && child.name == bladeKeywords_1.BladeKeywords.Case) {
                const caseChildren = this.collectUntil(node, children.slice(i + 1), [bladeKeywords_1.BladeKeywords.Case, bladeKeywords_1.BladeKeywords.Default, bladeKeywords_1.BladeKeywords.EndSwitch]), switchCase = new nodes_1.SwitchCaseNode();
                switchCase.parent = child.parent;
                if (switchNode.cases.length == 0 && currentNodes.length > 0) {
                    switchCase.leadingNodes = currentNodes;
                    if (currentNodes.length > 0) {
                        const firstNode = currentNodes[0], lastNode = currentNodes[currentNodes.length - 1], start = (_b = (_a = firstNode.startPosition) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : 0, end = ((_d = (_c = lastNode.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0) + 1, childText = parser.getText(start, end);
                        switchCase.leadingDocument = bladeDocument_1.BladeDocument.childFromText(childText, parser, firstNode.startPosition);
                    }
                    currentNodes = [];
                }
                switchCase.refId = child.refId;
                switchCase.index = child.index;
                switchCase.startPosition = child.startPosition;
                switchCase.endPosition = child.endPosition;
                switchCase.order = switchNode.cases.length;
                switchCase.head = child;
                switchCase.isDefault = false;
                switchCase.children = caseChildren.children;
                switchCase.withParser(parser);
                switchCase.isClosedBy = caseChildren.brokeOn;
                child.isClosedBy = caseChildren.brokeOn;
                if (switchCase.children.length > 0) {
                    const lastChild = switchCase.children[switchCase.children.length - 1];
                    if (lastChild instanceof nodes_1.DirectiveNode && lastChild == node.isClosedBy) {
                        switchCase.children.pop();
                    }
                }
                switchCase.childDocument = bladeDocument_1.BladeDocument.childFromText(parser.getNodeText(switchCase.children), parser, (0, helpers_1.getStartPosition)(switchCase.children));
                if (caseChildren.brokeOn != null) {
                    switchCase.endPosition = caseChildren.brokeOn.startPosition;
                }
                const caseStart = ((_f = (_e = switchCase.startPosition) === null || _e === void 0 ? void 0 : _e.index) !== null && _f !== void 0 ? _f : 0) - 1, caseEnd = ((_j = (_h = (_g = switchCase.isClosedBy) === null || _g === void 0 ? void 0 : _g.startPosition) === null || _h === void 0 ? void 0 : _h.index) !== null && _j !== void 0 ? _j : 0) - 1, length = caseEnd - caseStart, caseInnerStart = ((_l = (_k = child.endPosition) === null || _k === void 0 ? void 0 : _k.index) !== null && _l !== void 0 ? _l : 0) + 1, caseInnerEnd = ((_p = (_o = (_m = switchCase.isClosedBy) === null || _m === void 0 ? void 0 : _m.startPosition) === null || _o === void 0 ? void 0 : _o.index) !== null && _p !== void 0 ? _p : 0) - 1, innerLength = caseInnerEnd - caseInnerStart;
                switchCase.documentContent = parser.getText(caseStart, caseEnd);
                switchCase.innerContent = parser.getText(caseInnerStart, caseInnerEnd);
                switchCase.offset = {
                    start: caseStart,
                    end: caseEnd,
                    length: length
                };
                switchCase.innerOffset = {
                    start: caseInnerStart,
                    end: caseInnerEnd,
                    length: innerLength
                };
                switchNode.cases.push(switchCase);
            }
            else if (child instanceof nodes_1.DirectiveNode && child.name == bladeKeywords_1.BladeKeywords.Default) {
                const caseChildren = children.slice(i + 1), defaultCase = new nodes_1.SwitchCaseNode();
                defaultCase.parent = child.parent;
                defaultCase.refId = child.refId;
                defaultCase.index = child.index;
                defaultCase.startPosition = child.startPosition;
                defaultCase.endPosition = node.startPosition;
                defaultCase.order = switchNode.cases.length;
                defaultCase.head = child;
                defaultCase.isDefault = true;
                defaultCase.children = caseChildren;
                defaultCase.withParser(parser);
                defaultCase.isClosedBy = node.isClosedBy;
                child.isClosedBy = node.isClosedBy;
                const childDocNodes = [...defaultCase.children], lastChild = childDocNodes[childDocNodes.length - 1];
                if (lastChild instanceof nodes_1.DirectiveNode && lastChild.refId == ((_q = node.isClosedBy) === null || _q === void 0 ? void 0 : _q.refId)) {
                    childDocNodes.pop();
                }
                const caseStart = ((_s = (_r = defaultCase.startPosition) === null || _r === void 0 ? void 0 : _r.index) !== null && _s !== void 0 ? _s : 0) - 1, caseEnd = ((_v = (_u = (_t = defaultCase.isClosedBy) === null || _t === void 0 ? void 0 : _t.startPosition) === null || _u === void 0 ? void 0 : _u.index) !== null && _v !== void 0 ? _v : 0) - 1, length = caseEnd - caseStart, caseInnerStart = ((_x = (_w = child.endPosition) === null || _w === void 0 ? void 0 : _w.index) !== null && _x !== void 0 ? _x : 0) + 1, caseInnerEnd = ((_0 = (_z = (_y = defaultCase.isClosedBy) === null || _y === void 0 ? void 0 : _y.startPosition) === null || _z === void 0 ? void 0 : _z.index) !== null && _0 !== void 0 ? _0 : 0) - 1, innerLength = caseInnerEnd - caseInnerStart;
                defaultCase.documentContent = parser.getText(caseStart, caseEnd);
                defaultCase.innerContent = parser.getText(caseInnerStart, caseInnerEnd);
                defaultCase.offset = {
                    start: caseStart,
                    end: caseEnd,
                    length: length
                };
                defaultCase.innerOffset = {
                    start: caseInnerStart,
                    end: caseInnerEnd,
                    length: innerLength
                };
                defaultCase.childDocument = bladeDocument_1.BladeDocument.childFromText(parser.getNodeText(childDocNodes), parser, (0, helpers_1.getStartPosition)(childDocNodes));
                switchNode.cases.push(defaultCase);
                break;
            }
            else {
                currentNodes.push(child);
            }
        }
        if (switchNode.cases.length > 0) {
            const lastChild = switchNode.cases[switchNode.cases.length - 1];
            if (lastChild.children.length > 0) {
                switchNode.tail = lastChild.children.pop();
            }
        }
        if (switchNode.cases.length == 0) {
            // Set child doc on the construction.
            const childDocNodes = [...node.children];
            if (childDocNodes.length > 0) {
                if (childDocNodes[childDocNodes.length - 1] == node.isClosedBy) {
                    childDocNodes.pop();
                }
            }
            node.childrenDocument = bladeDocument_1.BladeDocument.childFromText(parser.getNodeText(childDocNodes), parser, (0, helpers_1.getStartPosition)(childDocNodes));
        }
        const switchStartOffset = ((_2 = (_1 = node.startPosition) === null || _1 === void 0 ? void 0 : _1.index) !== null && _2 !== void 0 ? _2 : 0) - 1, switchLength = (_5 = (_4 = (_3 = node.isClosedBy) === null || _3 === void 0 ? void 0 : _3.endPosition) === null || _4 === void 0 ? void 0 : _4.index) !== null && _5 !== void 0 ? _5 : 0 - ((_7 = (_6 = node.startPosition) === null || _6 === void 0 ? void 0 : _6.index) !== null && _7 !== void 0 ? _7 : 0), switchEndOffset = switchStartOffset + switchLength;
        switchNode.nodeContent = parser.getText(switchStartOffset, switchLength);
        switchNode.offset = {
            start: switchStartOffset,
            end: switchEndOffset,
            length: switchLength
        };
        if (switchNode.cases.length > 0) {
            const lastCase = switchNode.cases[switchNode.cases.length - 1];
            if (lastCase.isClosedBy == null) {
                lastCase.isClosedBy = node.isClosedBy;
            }
        }
        return switchNode;
    }
    static collectUntil(reference, children, breakFor) {
        var _a;
        const childrenToReturn = [];
        let brokeOn = null;
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child instanceof nodes_1.DirectiveNode && breakFor.includes(child.name) && ((_a = child.parent) === null || _a === void 0 ? void 0 : _a.refId) == reference.refId) {
                brokeOn = child;
                break;
            }
            childrenToReturn.push(child);
        }
        return {
            children: childrenToReturn,
            brokeOn: brokeOn
        };
    }
}
exports.SwitchPairAnalyzer = SwitchPairAnalyzer;
//# sourceMappingURL=switchPairAnalyzer.js.map