"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneralSyntaxReflow = void 0;
const nodes_1 = require("../nodes/nodes");
const documentParser_1 = require("../parser/documentParser");
const isStartOfString_1 = require("../parser/scanners/isStartOfString");
const skipToEndOfLine_1 = require("../parser/scanners/skipToEndOfLine");
const skipToEndOfMultilineComment_1 = require("../parser/scanners/skipToEndOfMultilineComment");
const skipToEndOfString_1 = require("../parser/scanners/skipToEndOfString");
const stringUtilities_1 = require("../utilities/stringUtilities");
class GeneralSyntaxReflow {
    constructor() {
        this.content = '';
        this.chars = [];
        this.inputLen = 0;
        this.prev = null;
        this.cur = null;
        this.next = null;
        this.currentIndex = 0;
        this.currentContent = [];
        this.tokens = [];
    }
    advance(count) {
        for (let i = 0; i < count; i++) {
            this.currentIndex++;
            this.checkCurrentOffsets();
        }
    }
    encounteredFailure() {
        return;
    }
    updateIndex(index) {
        this.currentIndex = index;
    }
    inputLength() {
        return this.inputLen;
    }
    getCurrentIndex() {
        return this.currentIndex;
    }
    incrementIndex() {
        this.currentIndex += 1;
    }
    getCurrent() {
        return this.cur;
    }
    getNext() {
        return this.next;
    }
    getPrev() {
        return this.prev;
    }
    checkCurrentOffsets() {
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (this.currentIndex > 0) {
            this.prev = this.chars[this.currentIndex - 1];
        }
        if ((this.currentIndex + 1) < this.inputLen) {
            this.next = this.chars[this.currentIndex + 1];
        }
    }
    pushChar(value) {
        this.currentContent.push(value);
    }
    getChar(index) {
        return this.chars[index];
    }
    getSeedOffset() {
        return 0;
    }
    getContentSubstring(from, length) {
        return this.content.substr(from, length);
    }
    getTokens() {
        return this.tokens;
    }
    static couldReflow(input) {
        return GeneralSyntaxReflow.breakOperators.some(sb => input.includes(sb));
    }
    safeReflow(input) {
        if (!GeneralSyntaxReflow.couldReflow(input)) {
            return input;
        }
        return this.reflow(input);
    }
    parse(text) {
        this.tokens = [];
        this.content = stringUtilities_1.StringUtilities.normalizeLineEndings(text);
        this.chars = this.content.split('');
        this.inputLen = this.chars.length;
        // Break the input string into tokens to help build on the final array nodes.
        for (this.currentIndex = 0; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
                this.currentContent.push(this.cur);
                continue;
            }
            if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
                const terminator = this.cur, results = (0, skipToEndOfString_1.skipToEndOfStringTraced)(this);
                this.pushChar(terminator);
                this.currentContent = this.currentContent.concat(results.value.split(''));
                this.pushChar(terminator);
                this.currentIndex = results.endedOn;
                continue;
            }
            if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.next == documentParser_1.DocumentParser.Punctuation_ForwardSlash) {
                (0, skipToEndOfLine_1.skipToEndOfLine)(this, true);
                continue;
            }
            if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.next == documentParser_1.DocumentParser.Punctuation_Asterisk) {
                (0, skipToEndOfMultilineComment_1.skipToEndOfMultilineComment)(this, true);
                continue;
            }
            if (this.cur != null) {
                if (this.cur === '!' && this.next !== '=') {
                    if (this.currentContent.length > 0) {
                        const literal = new nodes_1.LiteralNode();
                        literal.content = this.currentContent.join('');
                        this.currentContent = [];
                        this.tokens.push(literal);
                    }
                    const operator = new nodes_1.OperatorNode();
                    operator.sourceContent = this.cur;
                    this.tokens.push(operator);
                    this.currentContent = [];
                    continue;
                }
                else {
                    this.currentContent.push(this.cur);
                }
            }
        }
        if (this.currentContent.length > 0) {
            const literal = new nodes_1.LiteralNode();
            literal.content = this.currentContent.join('');
            this.currentContent = [];
            this.tokens.push(literal);
        }
    }
    reflow(input) {
        try {
            this.parse(input);
        }
        catch (err) {
            // Prevent errors from crashing formatting.
            return input;
        }
        let output = '', lastWasOperator = false;
        this.tokens.forEach((token) => {
            if (token instanceof nodes_1.OperatorNode) {
                lastWasOperator = true;
                output += token.sourceContent + ' ';
                return;
            }
            if (token instanceof nodes_1.LiteralNode) {
                if (lastWasOperator) {
                    output += token.content.trimLeft();
                }
                else {
                    output += token.content;
                }
            }
            lastWasOperator = false;
        });
        return output;
    }
}
exports.GeneralSyntaxReflow = GeneralSyntaxReflow;
GeneralSyntaxReflow.breakOperators = ['!'];
GeneralSyntaxReflow.instance = new GeneralSyntaxReflow();
//# sourceMappingURL=generalSyntaxReflow.js.map