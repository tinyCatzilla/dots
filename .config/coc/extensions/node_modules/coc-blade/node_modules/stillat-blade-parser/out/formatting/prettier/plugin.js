"use strict";
const bladeDocument_1 = require("../../document/bladeDocument");
const phpParserPhpValidator_1 = require("../../parser/php/phpParserPhpValidator");
const optionDiscovery_1 = require("../optionDiscovery");
const prettierDocumentFormatter_1 = require("./prettierDocumentFormatter");
const utils_1 = require("./utils");
const classStringEmulation_1 = require("../classStringEmulation");
const attributeRangeRemover_1 = require("../../document/attributeRangeRemover");
const fragmentsParser_1 = require("../../parser/fragmentsParser");
const classStringsConfig_1 = require("../classStringsConfig");
const classEmulator_1 = require("../../parser/classEmulator");
const nodes_1 = require("../../nodes/nodes");
const voidHtmlTagsManager_1 = require("./voidHtmlTagsManager");
let prettierOptions, transformOptions, parserOptions;
let bladeOptions = null;
const plugin = {
    languages: [
        {
            name: "Blade",
            parsers: ["blade"],
            extensions: [".blade.php"],
            vscodeLanguageIds: ["blade"],
        }
    ],
    parsers: {
        blade: {
            parse: function (text, _, options) {
                const overridePath = (0, optionDiscovery_1.getPrettierFilePath)(), adjuster = (0, utils_1.getOptionsAdjuster)();
                if (adjuster != null) {
                    options = adjuster(options);
                }
                // Provides a way to override this setting.
                if (overridePath != null) {
                    options.filepath = overridePath;
                }
                (0, utils_1.setOptions)(options);
                prettierOptions = options;
                bladeOptions = (0, optionDiscovery_1.getEnvSettings)(__dirname);
                transformOptions = bladeOptions;
                parserOptions = bladeOptions;
                transformOptions.tabSize = (0, utils_1.getHtmlOptions)().tabWidth;
                let parseText = text;
                if (attributeRangeRemover_1.canProcessAttributes) {
                    parseText = voidHtmlTagsManager_1.VoidHtmlTagsManager.adjustInput(parseText);
                }
                let prettierText = parseText, shadowText = parseText;
                const classConfig = transformOptions.classStrings, phpValidator = new phpParserPhpValidator_1.PhpParserPhpValidator();
                let attributeMap = new Map(), canSafelyContinue = true;
                if (transformOptions.formatJsAttributes && attributeRangeRemover_1.canProcessAttributes) {
                    const fragments = new fragmentsParser_1.FragmentsParser(), tmpDoc = bladeDocument_1.BladeDocument.fromText(prettierText);
                    fragments.setIndexRanges(tmpDoc.getParser().getNodeIndexRanges());
                    fragments.setExtractAttributeNames(transformOptions.includeJsAttributes);
                    fragments.setExcludeAttributes(transformOptions.excludeJsAttributes);
                    fragments.setExtractAttributes(true);
                    fragments.parse(prettierText);
                    if (fragments.getParsingTracedStringHitEof()) {
                        canSafelyContinue = false;
                    }
                    if (canSafelyContinue) {
                        const extractedAttributes = fragments.getExtractedAttributes();
                        tmpDoc.getAllNodes().forEach((node) => {
                            if (node instanceof nodes_1.BladeComponentNode && node.hasParameters) {
                                node.parameters.forEach((param) => {
                                    if (param.isEscapedExpression && param.valuePosition != null &&
                                        param.valuePosition.start != null && param.valuePosition.end != null) {
                                        extractedAttributes.push({
                                            content: param.wrappedValue,
                                            name: param.name,
                                            startedOn: param.valuePosition.start.offset,
                                            endedOn: param.valuePosition.end.offset
                                        });
                                    }
                                });
                            }
                        });
                        if (extractedAttributes.length > 0) {
                            const attributeRemover = new attributeRangeRemover_1.AttributeRangeRemover(), remResult = attributeRemover.remove(prettierText, extractedAttributes);
                            attributeMap = attributeRemover.getRemovedAttributes();
                            prettierText = remResult;
                        }
                    }
                }
                if (classConfig.enabled) {
                    const classStringEmulation = new classStringEmulation_1.ClassStringEmulation(classConfig);
                    prettierText = classStringEmulation
                        .withParserOptions(parserOptions)
                        .withPhpValidator(phpValidator)
                        .transform(prettierText);
                    shadowText = classStringEmulation
                        .withParserOptions(parserOptions)
                        .withPhpValidator(phpValidator)
                        .transform(shadowText);
                    if (attributeMap.size > 0) {
                        attributeMap.forEach((attribute) => {
                            try {
                                const classStringRuleEngine = new classStringsConfig_1.ClassStringRuleEngine(classConfig), jsEmulator = new classEmulator_1.ClassEmulator(classStringRuleEngine);
                                jsEmulator.setAllowedMethodNames(classConfig.allowedMethodNames);
                                jsEmulator.setExcludedLanguageStructures(classConfig.ignoredLanguageStructures);
                                let transformContent = attribute.content.substring(1, attribute.content.length - 1), newTransformContent = jsEmulator.emulateJavaScriptString(transformContent);
                                if (transformContent == newTransformContent && !jsEmulator.getFoundAnyStrings()) {
                                    attribute.content = jsEmulator.emulateJavaScriptString(attribute.content);
                                }
                                else {
                                    attribute.content = '"' + transformContent + '"';
                                }
                            }
                            catch (err) {
                                return;
                            }
                        });
                    }
                }
                const document = new bladeDocument_1.BladeDocument(), shadow = new bladeDocument_1.BladeDocument();
                document.getParser()
                    .withParserOptions(parserOptions)
                    .withPhpValidator(phpValidator);
                // The document "shadow" will contain the
                // structures of the original document,
                // without any modificationns. We will
                // use this later when formatting.
                shadow.getParser()
                    .withParserOptions(parserOptions)
                    .withPhpValidator(phpValidator);
                document.loadString(prettierText);
                shadow.loadString(shadowText);
                const result = {
                    doc: document,
                    attributeMap: attributeMap,
                    shadowDocument: shadow,
                    canSafelyContinue: canSafelyContinue,
                    originalText: text
                };
                return result;
            },
            locStart: () => 0,
            locEnd: () => 0,
            astFormat: "blade",
        },
    },
    printers: {
        blade: {
            print(path) {
                const doc = path.stack[0], formatter = new prettierDocumentFormatter_1.PrettierDocumentFormatter(prettierOptions, transformOptions);
                if (!doc.canSafelyContinue) {
                    return doc.originalText;
                }
                return formatter
                    .withRemovedAttributes(doc.attributeMap)
                    .formatDocument(doc.doc, doc.shadowDocument);
            }
        }
    },
    defaultOptions: {
        tabWidth: 4,
    },
};
module.exports = plugin;
//# sourceMappingURL=plugin.js.map