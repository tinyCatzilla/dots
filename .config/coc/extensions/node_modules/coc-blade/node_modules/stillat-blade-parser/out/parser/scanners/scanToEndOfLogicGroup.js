"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scanToEndOfLogicGroup = void 0;
const documentParser_1 = require("../documentParser");
const isStartOfString_1 = require("./isStartOfString");
const skipToEndOfLine_1 = require("./skipToEndOfLine");
const skipToEndOfMultilineComment_1 = require("./skipToEndOfMultilineComment");
const skipToEndOfString_1 = require("./skipToEndOfString");
function scanToEndOfLogicGroup(iterator) {
    const groupStartedOn = iterator.getCurrentIndex() + iterator.getSeedOffset(), recoveryIndex = iterator.getCurrentIndex();
    let groupEndsOn = 0, groupOpenCount = 0, foundEnd = false;
    // Advance over the initial "(".
    iterator.incrementIndex();
    for (iterator.getCurrentIndex(); iterator.getCurrentIndex() < iterator.inputLength(); iterator.incrementIndex()) {
        iterator.checkCurrentOffsets();
        if ((0, isStartOfString_1.isStartOfString)(iterator.getCurrent())) {
            const stringStart = iterator.getCurrent(), recoveryIndex = iterator.getCurrentIndex();
            (0, skipToEndOfString_1.skipToEndOfString)(iterator);
            if (iterator.getNext() === null && iterator.getCurrent() !== stringStart) {
                iterator.updateIndex(recoveryIndex + 1);
                iterator.encounteredFailure();
            }
            continue;
        }
        if (iterator.getCurrent() == documentParser_1.DocumentParser.Punctuation_ForwardSlash && iterator.getNext() == documentParser_1.DocumentParser.Punctuation_Asterisk) {
            (0, skipToEndOfMultilineComment_1.skipToEndOfMultilineComment)(iterator, false);
            continue;
        }
        if (iterator.getCurrent() == documentParser_1.DocumentParser.Punctuation_ForwardSlash && iterator.getNext() == documentParser_1.DocumentParser.Punctuation_ForwardSlash) {
            (0, skipToEndOfLine_1.skipToEndOfLine)(iterator, false);
            continue;
        }
        if (iterator.getCurrent() == documentParser_1.DocumentParser.LeftParen) {
            groupOpenCount += 1;
            continue;
        }
        if (iterator.getCurrent() == documentParser_1.DocumentParser.RightParen) {
            if (groupOpenCount > 0) {
                groupOpenCount -= 1;
                continue;
            }
            groupEndsOn = iterator.getCurrentIndex() + iterator.getSeedOffset() + 1;
            foundEnd = true;
            break;
        }
        if (iterator.getCurrent() == null) {
            break;
        }
    }
    const groupContent = iterator.getContentSubstring(groupStartedOn, groupEndsOn - groupStartedOn);
    if (!foundEnd) {
        iterator.updateIndex(recoveryIndex - 1);
    }
    return {
        start: groupStartedOn,
        end: groupEndsOn,
        content: groupContent,
        foundEnd: foundEnd
    };
}
exports.scanToEndOfLogicGroup = scanToEndOfLogicGroup;
//# sourceMappingURL=scanToEndOfLogicGroup.js.map