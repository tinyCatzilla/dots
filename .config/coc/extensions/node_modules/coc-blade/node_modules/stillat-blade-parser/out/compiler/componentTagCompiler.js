"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentTagCompiler = void 0;
const bladeDocument_1 = require("../document/bladeDocument");
const nodes_1 = require("../nodes/nodes");
const componentClassNameResolver_1 = require("./componentClassNameResolver");
const camelize = require('camelize');
class ComponentTagCompiler {
    constructor() {
        this.aliases = new Map();
        this.compileBlade = false;
        this.detailsResolver = null;
        this.componentNameResolver = new componentClassNameResolver_1.AppClassNameResolver();
    }
    setComponentNameResolver(resolver) {
        this.componentNameResolver = resolver;
        return this;
    }
    setComponentDetailsResolver(resolver) {
        this.detailsResolver = resolver;
        return this;
    }
    registerAlias(componentName, className) {
        this.aliases.set(componentName, className);
        return this;
    }
    registerAliases(aliases) {
        this.aliases = aliases;
        return this;
    }
    compileAttributes(parameters) {
        if (parameters.length == 0) {
            return '[]';
        }
        const attributeParts = [];
        let attributes = '[';
        parameters.forEach((param) => {
            if (param.isExpression) {
                attributeParts.push(`'${param.realName}' => \\Illuminate\\View\\Compilers\\BladeCompiler::sanitizeComponentAttribute(${param.value})`);
                return;
            }
            attributeParts.push(`'${param.realName}' => '${param.value}'`);
        });
        attributes += attributeParts.join(', ');
        attributes += ']';
        return attributes;
    }
    compileSlot(component) {
        var _a;
        const nameParameter = component.getParameter('name');
        let slotName = (_a = component.name) === null || _a === void 0 ? void 0 : _a.inlineName, attributes = this.compileAttributes(component.getParametersExcept(['name']));
        if (nameParameter != null) {
            slotName = nameParameter.value;
            if (nameParameter.isExpression) {
                return `@slot(${slotName}, null, ${attributes})`;
            }
        }
        return `@slot('${slotName}', null, ${attributes})`;
    }
    componentDataAttributes(parameters, componentAttributes) {
        if (parameters.length == 0) {
            return '[]';
        }
        const attributeParts = [];
        let attributes = '[';
        parameters.forEach((param) => {
            let paramName = param.realName;
            if (param.type == nodes_1.ParameterType.Attribute) {
                paramName = param.name;
            }
            if (!componentAttributes.includes(paramName)) {
                if (paramName.includes('-') == false) {
                    return;
                }
                if (paramName.includes(':')) {
                    return;
                }
            }
            paramName = camelize(paramName);
            if (param.type == nodes_1.ParameterType.Attribute) {
                attributeParts.push(`'${paramName}' => true`);
                return;
            }
            if (param.value.trim().includes('{{')) {
                const paramDoc = bladeDocument_1.BladeDocument.fromText(param.value.trim());
                let newValue = '';
                paramDoc.getAllNodes().forEach((node) => {
                    if (node instanceof nodes_1.LiteralNode) {
                        newValue += node.content;
                    }
                    else if (node instanceof nodes_1.BladeEchoNode) {
                        newValue += '.e(' + node.content.trim() + ').';
                    }
                });
                attributeParts.push(`'${paramName}' => '${newValue}'`);
                return;
            }
            if (param.isExpression) {
                attributeParts.push(`'${paramName}' => ${param.value}`);
                return;
            }
            attributeParts.push(`'${paramName}' => '${param.value}'`);
        });
        attributes += attributeParts.join(', ');
        attributes += ']';
        return attributes;
    }
    componentClassAttributes(parameters, componentAttributes) {
        if (parameters.length == 0) {
            return '[]';
        }
        const attributeParts = [];
        let attributes = '[';
        parameters.forEach((param) => {
            let paramName = param.realName;
            if (param.type == nodes_1.ParameterType.Attribute) {
                paramName = param.name;
            }
            if (componentAttributes.includes(paramName)) {
                return;
            }
            if (paramName.includes('-') && !paramName.includes(':')) {
                return;
            }
            if (param.isEscapedExpression) {
                paramName = ':' + paramName;
            }
            if (param.type == nodes_1.ParameterType.InlineEcho && param.inlineEcho != null) {
                const echoContent = param.inlineEcho.content.trim().toLowerCase();
                if (echoContent.startsWith('$attributes')) {
                    attributeParts.push(`'attributes' => \\Illuminate\\View\\Compilers\\BladeCompiler::sanitizeComponentAttribute(${param.inlineEcho.content.trim()})`);
                    return;
                }
            }
            if (param.type == nodes_1.ParameterType.Attribute) {
                attributeParts.push(`'${paramName}' => true`);
                return;
            }
            if (param.value.trim().includes('{{')) {
                const paramDoc = bladeDocument_1.BladeDocument.fromText(param.value.trim());
                let newValue = '';
                paramDoc.getAllNodes().forEach((node) => {
                    if (node instanceof nodes_1.LiteralNode) {
                        newValue += node.content;
                    }
                    else if (node instanceof nodes_1.BladeEchoNode) {
                        newValue += '.e(' + node.content.trim() + ').';
                    }
                });
                attributeParts.push(`'${paramName}' => '${newValue}'`);
                return;
            }
            if (param.isExpression) {
                attributeParts.push(`'${paramName}' => \\Illuminate\\View\\Compilers\\BladeCompiler::sanitizeComponentAttribute(${param.value})`);
                return;
            }
            attributeParts.push(`'${paramName}' => '${param.value}'`);
        });
        attributes += attributeParts.join(', ');
        attributes += ']';
        return attributes;
    }
    compile(component) {
        var _a, _b, _c;
        if (((_a = component.name) === null || _a === void 0 ? void 0 : _a.name) == 'slot') {
            if (component.isClosingTag) {
                return '@endslot';
            }
            else {
                return this.compileSlot(component);
            }
        }
        if (component.isClosingTag && !component.isSelfClosing) {
            return ` @endComponentClass##END-COMPONENT-CLASS##`;
        }
        let componentName = (_b = component.name) === null || _b === void 0 ? void 0 : _b.name, alias = componentName;
        if (component.name != null && component.name.inlineName.length > 0) {
            componentName = componentName + ':' + ((_c = component.name) === null || _c === void 0 ? void 0 : _c.inlineName);
            alias = componentName;
        }
        if (this.aliases.has(componentName)) {
            componentName = this.aliases.get(componentName);
        }
        let propertyNames = [];
        if (this.detailsResolver != null) {
            const componentDetails = this.detailsResolver.getDetails(alias);
            if (componentDetails != null) {
                propertyNames = componentDetails.properties;
            }
        }
        const componentClass = this.componentNameResolver.resolveName(componentName), attributes = this.componentClassAttributes(component.parameters, propertyNames), dataAttributes = this.componentDataAttributes(component.parameters, propertyNames);
        let componentTag = `##BEGIN-COMPONENT-CLASS##@component('${componentClass}', '${alias}', ${dataAttributes})
<?php if (isset($attributes) && $constructor = (new ReflectionClass(${componentClass}::class))->getConstructor()): ?>
<?php $attributes = $attributes->except(collect($constructor->getParameters())->map->getName()->all()); ?>
<?php endif; ?>
<?php $component->withAttributes(${attributes}); ?>`;
        if (component.isSelfClosing) {
            componentTag += `
@endComponentClass##END-COMPONENT-CLASS##`;
        }
        return componentTag;
    }
}
exports.ComponentTagCompiler = ComponentTagCompiler;
//# sourceMappingURL=componentTagCompiler.js.map