"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DirectivePairAnalyzer = void 0;
const bladeDocument_1 = require("../document/bladeDocument");
const helpers_1 = require("../nodes/helpers");
const nodes_1 = require("../nodes/nodes");
const bladeKeywords_1 = require("../parser/bladeKeywords");
const arrayHelpers_1 = require("../utilities/arrayHelpers");
const componentSlotPairAnalyzer_1 = require("./componentSlotPairAnalyzer");
const conditionPairAnalyzer_1 = require("./conditionPairAnalyzer");
const forElsePairAnalyzer_1 = require("./forElsePairAnalyzer");
const pairManager_1 = require("./pairManager");
const speculativeConditionAnalyzer_1 = require("./speculativeConditionAnalyzer");
const switchPairAnalyzer_1 = require("./switchPairAnalyzer");
class DirectivePairAnalyzer {
    constructor() {
        this.document = null;
        this.parentNode = null;
        this.openDirectiveIndexCount = new Map();
        this.closingDirectiveIndex = new Map();
        this.closingDirectiveIndexCount = new Map();
        this.closingDirectiveNames = new Map();
        this.createdExecutionBranches = [];
        this.pairsCreated = 0;
        this.stackCount = 0;
    }
    buildCloseIndex(nodes) {
        var _a, _b, _c;
        nodes.forEach((node) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if ((node instanceof nodes_1.DirectiveNode) == false) {
                return;
            }
            const directive = node;
            if (directive.isClosingDirective == false) {
                return;
            }
            if (this.closingDirectiveIndex.has(this.stackCount) == false) {
                this.closingDirectiveIndex.set(this.stackCount, new Map());
            }
            if (this.closingDirectiveIndexCount.has(this.stackCount) == false) {
                this.closingDirectiveIndexCount.set(this.stackCount, new Map());
            }
            const directiveName = directive.name;
            if (((_a = this.closingDirectiveIndex.get(this.stackCount)) === null || _a === void 0 ? void 0 : _a.has(directiveName)) == false) {
                (_b = this.closingDirectiveIndex.get(this.stackCount)) === null || _b === void 0 ? void 0 : _b.set(directiveName, []);
                (_c = this.closingDirectiveIndexCount.get(this.stackCount)) === null || _c === void 0 ? void 0 : _c.set(directiveName, 0);
            }
            (_e = (_d = this.closingDirectiveIndex.get(this.stackCount)) === null || _d === void 0 ? void 0 : _d.get(directiveName)) === null || _e === void 0 ? void 0 : _e.push(node);
            const curCount = (_g = (_f = this.closingDirectiveIndexCount.get(this.stackCount)) === null || _f === void 0 ? void 0 : _f.get(directiveName)) !== null && _g !== void 0 ? _g : 0;
            (_h = this.closingDirectiveIndexCount.get(this.stackCount)) === null || _h === void 0 ? void 0 : _h.set(directiveName, curCount + 1);
        });
        if (this.closingDirectiveNames.has(this.stackCount) == false) {
            this.closingDirectiveNames.set(this.stackCount, []);
        }
        // Process the closing tag index, if it has been set for the current stack level.
        if (this.closingDirectiveIndex.has(this.stackCount)) {
            this.closingDirectiveNames.set(this.stackCount, (Array.from((_b = (_a = this.closingDirectiveIndex.get(this.stackCount)) === null || _a === void 0 ? void 0 : _a.keys()) !== null && _b !== void 0 ? _b : [])));
            (_c = this.closingDirectiveIndex.get(this.stackCount)) === null || _c === void 0 ? void 0 : _c.forEach((indexedNodes, directiveName) => {
                var _a, _b, _c, _d, _e;
                const indexedNodeCount = indexedNodes.length;
                if (indexedNodeCount == 0) {
                    return;
                }
                // Find the last closing directive candidate, and work up
                // to calculate a list of valid opening candidates.
                const lastIndexedNode = indexedNodes[indexedNodeCount - 1];
                for (let i = 0; i < indexedNodeCount; i++) {
                    const node = nodes[i];
                    if (node instanceof nodes_1.DirectiveNode) {
                        if (node.index >= lastIndexedNode.index) {
                            break;
                        }
                        const nodeDirectiveName = node.name;
                        if (node.isClosingDirective == false && nodeDirectiveName == directiveName) {
                            if (this.openDirectiveIndexCount.has(this.stackCount) == false) {
                                this.openDirectiveIndexCount.set(this.stackCount, new Map());
                            }
                            if (((_a = this.openDirectiveIndexCount.get(this.stackCount)) === null || _a === void 0 ? void 0 : _a.has(directiveName)) == false) {
                                (_b = this.openDirectiveIndexCount.get(this.stackCount)) === null || _b === void 0 ? void 0 : _b.set(directiveName, 0);
                            }
                            const curCount = (_d = (_c = this.openDirectiveIndexCount.get(this.stackCount)) === null || _c === void 0 ? void 0 : _c.get(directiveName)) !== null && _d !== void 0 ? _d : 0;
                            (_e = this.openDirectiveIndexCount.get(this.stackCount)) === null || _e === void 0 ? void 0 : _e.set(directiveName, curCount + 1);
                        }
                    }
                }
            });
        }
    }
    getClosingCandidates(node) {
        const candidates = [];
        candidates.push(node.name);
        return candidates;
    }
    getScanForList(node) {
        if (node.isClosingDirective == false) {
            const candidates = this.getClosingCandidates(node), indexValues = this.closingDirectiveNames.get(this.stackCount);
            return (0, arrayHelpers_1.intersect)(candidates, indexValues);
        }
        return [];
    }
    associate(documentNodes, document, refParent = null) {
        var _a;
        this.document = document;
        let nodesToReturn = [];
        const nodeStack = [{
                documentNodes: documentNodes,
                parent: refParent
            }];
        while (nodeStack.length > 0) {
            const details = nodeStack.pop();
            if (details == null) {
                continue;
            }
            let nodes = details.documentNodes;
            this.parentNode = details.parent;
            this.stackCount += 1;
            this.buildCloseIndex(nodes);
            // Ask the specialized control structure analyzer to do its job first.
            nodes = conditionPairAnalyzer_1.ConditionPairAnalyzer.pairConditionals(nodes);
            nodes = componentSlotPairAnalyzer_1.ComponentSlotPairAnalyzer.pairComponents(nodes);
            nodes.forEach((node) => {
                if ((node instanceof nodes_1.DirectiveNode) && pairManager_1.PairManager.canClose(node)) {
                    if (conditionPairAnalyzer_1.ConditionPairAnalyzer.isConditionalStructure(node)) {
                        this.pairsCreated += 1;
                        return;
                    }
                    const scanFor = this.getScanForList(node);
                    this.findClosingPair(nodes, node, scanFor);
                }
            });
            // Step 1: Set the node parent relationships.
            const nodeCount = nodes.length;
            for (let i = 0; i < nodeCount; i++) {
                const node = nodes[i];
                if (node instanceof nodes_1.DirectiveNode && node.isClosedBy != null) {
                    for (let j = i + 1; j < nodeCount; j++) {
                        const childNode = nodes[j];
                        if (childNode.index > node.isClosedBy.index) {
                            break;
                        }
                        childNode.parent = node;
                        node.children.push(childNode);
                        if (childNode instanceof nodes_1.DirectiveNode && childNode.index == node.index) {
                            childNode.parent = node;
                            break;
                        }
                    }
                }
            }
            // Step 2: Build up the inner children nodes.
            nodes.forEach((node) => {
                if ((node instanceof nodes_1.DirectiveNode) && node.children.length > 0) {
                    const newChildren = [], refIds = [];
                    node.children.forEach((childNode) => {
                        if (childNode.parent != null) {
                            if (childNode.parent.index == node.index) {
                                const refId = childNode.refId;
                                if (!refIds.includes(refId)) {
                                    childNode.parent = node;
                                    newChildren.push(childNode);
                                    refIds.push(refId);
                                }
                                else {
                                    return;
                                }
                            }
                        }
                    });
                    nodeStack.push({
                        documentNodes: newChildren,
                        parent: node
                    });
                }
            });
            // Step 3: Extract the "root" nodes. These will be our new "nested" nodes.
            let nestedNodes = [];
            nodes.forEach((node) => {
                var _a;
                if (this.parentNode == null) {
                    if (node.parent == null) {
                        nestedNodes.push(node);
                    }
                }
                else {
                    if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.refId) == this.parentNode.refId) {
                        nestedNodes.push(node);
                    }
                }
            });
            nestedNodes = this.reduceConditions(nestedNodes, document);
            nestedNodes = switchPairAnalyzer_1.SwitchPairAnalyzer.associate(nestedNodes, document);
            nestedNodes = forElsePairAnalyzer_1.ForElsePairAnalyzer.associate(nestedNodes, document);
            nestedNodes = speculativeConditionAnalyzer_1.SpeculativeConditionAnalyzer.analyze(nestedNodes, document);
            nestedNodes = this.cleanNodes(nestedNodes);
            const nestedNodeKeyMap = new Map();
            nodes.forEach((node) => {
                var _a, _b, _c, _d;
                if ((node instanceof nodes_1.DirectiveNode) && node.isClosedBy != null) {
                    if (this.document != null) {
                        const content = this.document.getText(((_b = (_a = node.endPosition) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : 0), ((_d = (_c = node.isClosedBy.startPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0) - 1);
                        node.documentContent = content;
                        if (node.name == 'php' || node.name == 'verbatim') {
                            if (node.innerContent.trim().length == 0) {
                                node.innerContent = node.documentContent;
                            }
                        }
                    }
                }
            });
            for (let i = 0; i < nestedNodes.length; i++) {
                const node = nestedNodes[i], refId = (_a = node.refId) !== null && _a !== void 0 ? _a : '';
                nestedNodeKeyMap.set(refId, 1);
            }
            if (this.parentNode != null && (this.parentNode instanceof nodes_1.DirectiveNode)) {
                this.parentNode.children = this.cleanNodes(nestedNodes);
                if (this.parentNode.parent != null && this.parentNode.parent instanceof nodes_1.DirectiveNode) {
                    const ancestorNodes = this.parentNode.parent.children, newAncestorNodes = [];
                    ancestorNodes.forEach((aNode) => {
                        // Because we are processing the deeply nested
                        // nodes *after* their parent nodes, we have
                        // to make sure to clean up the node tree.
                        var _a;
                        if (nestedNodeKeyMap.has((_a = aNode.refId) !== null && _a !== void 0 ? _a : '') == false) {
                            newAncestorNodes.push(aNode);
                        }
                    });
                    this.parentNode.parent.children = this.cleanNodes(newAncestorNodes);
                }
            }
            if (this.stackCount <= 1) {
                nodesToReturn = this.cleanNodes(nestedNodes);
            }
        }
        return nodesToReturn;
    }
    cleanNodes(nodes) {
        const cleaned = [], ids = [];
        for (let i = 0; i < nodes.length; i++) {
            const child = nodes[i], refId = child.refId;
            if (ids.includes(refId)) {
                break;
            }
            cleaned.push(child);
            ids.push(refId);
        }
        return cleaned;
    }
    reduceConditions(nodes, document) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        const reduced = [];
        for (let i = 0; i < nodes.length; i++) {
            let node = nodes[i];
            if ((node instanceof nodes_1.DirectiveNode) && node.isClosingDirective == false && node.isClosedBy != null) {
                const compound = node.name;
                if (compound == bladeKeywords_1.BladeKeywords.If) {
                    const conditionNode = new nodes_1.ConditionNode(), finalClosing = node.getFinalClosingDirective();
                    conditionNode.withParser(document);
                    conditionNode.index = node.index;
                    conditionNode.chain.push(node.index);
                    conditionNode.startPosition = node.startPosition;
                    conditionNode.endPosition = finalClosing.endPosition;
                    conditionNode.constructedFrom = node;
                    const startOffset = ((_b = (_a = node.startPosition) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : 0) - 1, length = (_d = (_c = finalClosing === null || finalClosing === void 0 ? void 0 : finalClosing.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0 - ((_f = (_e = node.startPosition) === null || _e === void 0 ? void 0 : _e.index) !== null && _f !== void 0 ? _f : 0), endOffset = startOffset + length;
                    conditionNode.nodeContent = document.getText(startOffset, length);
                    conditionNode.offset = {
                        start: startOffset,
                        end: endOffset,
                        length: length
                    };
                    if (this.parentNode != null) {
                        conditionNode.parent = this.parentNode;
                    }
                    let exitedOn = null, doContinue = true, currentDepth = 0;
                    while (doContinue) {
                        currentDepth += 1;
                        // Attempt to prevent infinite loops.
                        if (currentDepth > DirectivePairAnalyzer.ForceBreakLimit) {
                            doContinue = false;
                            break;
                        }
                        if ((node instanceof nodes_1.DirectiveNode)) {
                            const result = this.findEndOfBranch(nodes.slice(i + 1), node, i), executionBranch = new nodes_1.ExecutionBranchNode();
                            executionBranch.withParser(document);
                            let tail = result.tail;
                            executionBranch.head = node;
                            executionBranch.tail = tail;
                            executionBranch.nodes = this.cleanNodes(node.children);
                            const childDocNodes = [...executionBranch.nodes], lastNode = childDocNodes[childDocNodes.length - 1];
                            if (lastNode instanceof nodes_1.DirectiveNode && lastNode.refId == ((_g = node.isClosedBy) === null || _g === void 0 ? void 0 : _g.refId)) {
                                childDocNodes.pop();
                            }
                            const branchStart = ((_j = (_h = node.endPosition) === null || _h === void 0 ? void 0 : _h.index) !== null && _j !== void 0 ? _j : 0), branchEnd = ((_m = (_l = (_k = node.isClosedBy) === null || _k === void 0 ? void 0 : _k.startPosition) === null || _l === void 0 ? void 0 : _l.index) !== null && _m !== void 0 ? _m : 0) - 1, length = branchEnd - branchStart, branchDocStart = ((_p = (_o = node.startPosition) === null || _o === void 0 ? void 0 : _o.index) !== null && _p !== void 0 ? _p : 0) - 1, branchDocEnd = ((_s = (_r = (_q = node.isClosedBy) === null || _q === void 0 ? void 0 : _q.startPosition) === null || _r === void 0 ? void 0 : _r.index) !== null && _s !== void 0 ? _s : 0) - 1, branchDocLength = branchDocEnd - branchDocStart;
                            executionBranch.innerContent = document.getText(branchStart, branchEnd);
                            executionBranch.documentContent = document.getText(branchDocStart, branchDocEnd);
                            executionBranch.innerOffset = {
                                start: branchStart,
                                end: branchEnd,
                                length: length
                            };
                            executionBranch.offset = {
                                start: branchDocStart,
                                end: branchDocEnd,
                                length: branchDocLength
                            };
                            executionBranch.childDocument = bladeDocument_1.BladeDocument.childFromText(document.getNodeText(childDocNodes), document, (0, helpers_1.getStartPosition)(childDocNodes));
                            if (tail == null) {
                                tail = executionBranch.head.isClosedBy;
                            }
                            if (tail != null && tail.startPosition != null) {
                                executionBranch.startPosition = tail.startPosition;
                            }
                            if (tail != null) {
                                executionBranch.index = tail.index;
                            }
                            if (executionBranch.nodes.length > 0) {
                                const lastNode = executionBranch.nodes[executionBranch.nodes.length - 1];
                                if (lastNode.endPosition != null) {
                                    executionBranch.endPosition = lastNode.endPosition;
                                }
                            }
                            else {
                                if (tail != null && tail.endPosition != null) {
                                    executionBranch.endPosition = tail.endPosition;
                                }
                            }
                            // Maintain a record of all created execution branches.
                            this.createdExecutionBranches.push(executionBranch);
                            conditionNode.logicBranches.push(executionBranch);
                            if ((tail === null || tail === void 0 ? void 0 : tail.isClosingDirective) && tail.name == bladeKeywords_1.BladeKeywords.If) {
                                exitedOn = result.offset;
                                doContinue = false;
                                break;
                            }
                            else {
                                if (tail != null) {
                                    conditionNode.chain.push(tail.index);
                                }
                                i = result.offset;
                                if (tail instanceof nodes_1.DirectiveNode) {
                                    node = tail;
                                }
                            }
                        }
                        else {
                            doContinue = false;
                        }
                    }
                    reduced.push(conditionNode);
                    if (exitedOn != null) {
                        if (exitedOn == nodes.length) {
                            break;
                        }
                    }
                }
                else {
                    reduced.push(node);
                }
            }
            else {
                reduced.push(node);
            }
        }
        return reduced;
    }
    findEndOfBranch(nodes, start, startedAt) {
        const children = [], offset = startedAt;
        let tail = null;
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if ((node instanceof nodes_1.DirectiveNode) && node.isOpenedBy != null && node.isOpenedBy == start) {
                tail = node;
                break;
            }
            else {
                children.push(node);
            }
        }
        return {
            children: children,
            tail: tail,
            offset: offset
        };
    }
    getPairsCreated() {
        return this.pairsCreated;
    }
    findClosingPair(nodes, node, scanFor) {
        const nodeLength = nodes.length;
        let refStack = 0;
        for (let i = 0; i < nodeLength; i++) {
            const candidateNode = nodes[i];
            if ((candidateNode instanceof nodes_1.DirectiveNode) == false) {
                continue;
            }
            if (candidateNode.startPosition == null || node.endPosition == null) {
                continue;
            }
            if (!node.endPosition.isBefore(candidateNode.startPosition)) {
                continue;
            }
            const directiveCandidate = candidateNode;
            if (directiveCandidate.isClosingDirective && directiveCandidate.isOpenedBy != null) {
                continue;
            }
            if (!directiveCandidate.isClosingDirective && directiveCandidate.isClosedBy != null) {
                continue;
            }
            const directiveName = directiveCandidate.name;
            if (!directiveCandidate.isClosingDirective) {
                if (scanFor.includes(directiveName)) {
                    refStack += 1;
                    continue;
                }
            }
            if (scanFor.includes(directiveName)) {
                if (refStack > 0) {
                    refStack -= 1;
                    continue;
                }
            }
            if (refStack == 0 && scanFor.includes(directiveName)) {
                directiveCandidate.isOpenedBy = node;
                node.isClosedBy = directiveCandidate;
                this.pairsCreated += 1;
                break;
            }
        }
    }
}
exports.DirectivePairAnalyzer = DirectivePairAnalyzer;
DirectivePairAnalyzer.ForceBreakLimit = 100000;
//# sourceMappingURL=directivePairAnalyzer.js.map