"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndentLevel = void 0;
const stringUtilities_1 = require("../../utilities/stringUtilities");
class IndentLevel {
    static relativeIndentLevel(value, content) {
        const tempStructureLines = stringUtilities_1.StringUtilities.breakByNewLine(content);
        for (let i = 0; i < tempStructureLines.length; i++) {
            const thisLine = tempStructureLines[i];
            if (thisLine.includes(value)) {
                const trimmed = thisLine.trimLeft();
                return thisLine.length - trimmed.length;
            }
        }
        return 0;
    }
    static indentLast(value, indent, tabSize) {
        const replace = ' '.repeat(indent), lines = stringUtilities_1.StringUtilities.breakByNewLine(value), newLines = [];
        if (lines.length == 3) {
            newLines.push(lines[0]);
            newLines.push(replace + ' '.repeat(tabSize) + lines[1].trim());
            newLines.push(replace + lines[2]);
            return newLines.join("\n");
        }
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (i == 0) {
                newLines.push(line);
            }
            else {
                if (i == lines.length - 1) {
                    newLines.push(replace + line);
                }
                else {
                    if (line.includes('=') || (line.trim().includes(' ') == false && !line.trimLeft().startsWith('@'))) {
                        newLines.push(replace + ' '.repeat(tabSize) + line.trimLeft());
                    }
                    else {
                        newLines.push(replace + line);
                    }
                }
            }
        }
        return newLines.join("\n");
    }
    static indentRelative(value, targetIndent, tabSize) {
        const sourceLines = stringUtilities_1.StringUtilities.breakByNewLine(value);
        let reflowedLines = [];
        // Clean up leading new lines.
        for (let i = 0; i < sourceLines.length; i++) {
            const thisLine = sourceLines[i];
            if (thisLine.trim().length > 0) {
                reflowedLines = sourceLines.slice(i);
                break;
            }
        }
        // Clean up trailing whitespace.
        for (let i = reflowedLines.length - 1; i >= 0; i--) {
            const thisLine = reflowedLines[i];
            if (thisLine.trim().length == 0) {
                reflowedLines.pop();
            }
            else {
                break;
            }
        }
        let leastIndentChange = -1;
        let thatLine = '';
        // Find which line currently has the least amount of left whitespace.
        for (let i = 0; i < reflowedLines.length; i++) {
            const thisLine = reflowedLines[i], checkLine = thisLine.trimLeft(), wsDiff = thisLine.length - checkLine.length;
            if (thisLine.trim().length == 0) {
                continue;
            }
            if (i == 0) {
                leastIndentChange = wsDiff;
                thatLine = thisLine;
            }
            else {
                if (wsDiff < leastIndentChange) {
                    leastIndentChange = wsDiff;
                    thatLine = thisLine;
                }
            }
        }
        if (leastIndentChange == tabSize) {
            leastIndentChange = 0;
        }
        // Remove the discovered leading whitespace and then apply our new (relative) indent level.
        if (leastIndentChange >= 0) {
            const targetWs = ' '.repeat(targetIndent);
            for (let i = 0; i < reflowedLines.length; i++) {
                const thisLine = reflowedLines[i];
                if (thisLine.trim().length == 0) {
                    reflowedLines[i] = '';
                    continue;
                }
                const reflowed = thisLine.substring(leastIndentChange);
                if (i == 0) {
                    reflowedLines[i] = thisLine.trimLeft();
                    continue;
                }
                else {
                    reflowedLines[i] = targetWs + reflowed;
                }
            }
        }
        return reflowedLines.join("\n");
    }
    static shiftIndentWithLastLineInline(value, tabSize, targetIndent, skipFirst = false) {
        const lines = stringUtilities_1.StringUtilities.breakByNewLine(value.trim()), reflowedLines = [];
        if (lines.length > 1) {
            let isAlreadyIndentedRelative = true;
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i], diff = line.length - line.trim().length, iDiff = targetIndent - diff;
                if (iDiff != 0) {
                    isAlreadyIndentedRelative = false;
                    break;
                }
            }
            if (isAlreadyIndentedRelative) {
                return value.trim();
            }
        }
        for (let i = 0; i < lines.length; i++) {
            if (i == 0 && skipFirst) {
                reflowedLines.push(lines[i]);
                continue;
            }
            const line = lines[i];
            if (line.trim().length == 0) {
                reflowedLines.push('');
            }
            else {
                reflowedLines.push(' '.repeat(Math.max(0, targetIndent - tabSize)) + line);
            }
        }
        return reflowedLines.join("\n");
    }
    static shiftIndent(value, targetIndent, skipFirst = false, options, reflowRelative = false, dedentLast = false) {
        const lines = stringUtilities_1.StringUtilities.breakByNewLine(value.trim()), reflowedLines = [];
        if (lines.length > 1) {
            let isAlreadyIndentedRelative = true;
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i], diff = line.length - line.trim().length, iDiff = targetIndent - diff;
                if (iDiff != 0) {
                    isAlreadyIndentedRelative = false;
                    break;
                }
            }
            if (isAlreadyIndentedRelative) {
                if (lines[0].trimLeft().length == lines[0].length && targetIndent == options.tabSize && reflowRelative) {
                    const relativePadding = ' '.repeat(options.tabSize);
                    lines.forEach((line) => {
                        reflowedLines.push(relativePadding + line);
                    });
                    return reflowedLines.join("\n");
                }
                return value.trim();
            }
        }
        for (let i = 0; i < lines.length; i++) {
            if (i == 0 && skipFirst) {
                reflowedLines.push(lines[i]);
                continue;
            }
            const line = lines[i];
            if (line.trim().length == 0) {
                reflowedLines.push('');
            }
            else {
                if (dedentLast && i == lines.length - 1) {
                    reflowedLines.push(' '.repeat(targetIndent - options.tabSize) + line);
                }
                else {
                    reflowedLines.push(' '.repeat(targetIndent) + line);
                }
            }
        }
        return reflowedLines.join("\n");
    }
    static shiftClean(value, indent) {
        const lines = stringUtilities_1.StringUtilities.breakByNewLine(value), reflowedLines = [], pad = ' '.repeat(indent);
        let hasFoundContent = false;
        lines.forEach((line) => {
            if (line.trim().length > 0) {
                hasFoundContent = true;
            }
            if (!hasFoundContent) {
                return;
            }
            if (line.trim().length == 0) {
                reflowedLines.push('');
            }
            else {
                reflowedLines.push(pad + line);
            }
        });
        return reflowedLines.join("\n");
    }
    static indentAll(content, tabSize, indentLevel) {
        const spaces = indentLevel * tabSize, lines = stringUtilities_1.StringUtilities.breakByNewLine(content);
    }
    static inferIndentLevel(structureLines, value, defaultIndent) {
        let targetLevel = 0, targetLevelFoundOn = -1;
        for (let i = 0; i < structureLines.length; i++) {
            const thisLine = structureLines[i];
            if (thisLine.includes(value)) {
                const trimmed = thisLine.trimLeft();
                targetLevel = thisLine.length - trimmed.length;
                targetLevelFoundOn = i;
                break;
            }
        }
        if (targetLevelFoundOn > 0) {
            for (let i = targetLevelFoundOn - 1; i >= 0; i--) {
                const thisLine = structureLines[i], trimmed = thisLine.trim(), trimmedLeft = thisLine.trimLeft(), checkLevel = thisLine.length - trimmed.length;
                if (trimmedLeft.length == 0) {
                    continue;
                }
                if (checkLevel != targetLevel && checkLevel < targetLevel) {
                    const inferred = targetLevel - checkLevel;
                    return {
                        targetLevel: targetLevel,
                        referenceLevel: checkLevel,
                        sourceTabSize: inferred
                    };
                }
            }
        }
        return {
            targetLevel: targetLevel,
            referenceLevel: targetLevel,
            sourceTabSize: defaultIndent
        };
    }
    static indent(structureLines, value, defaultIndent) {
        const levels = IndentLevel.inferIndentLevel(structureLines, value, defaultIndent);
        return ' '.repeat(levels.targetLevel);
    }
}
exports.IndentLevel = IndentLevel;
//# sourceMappingURL=indentLevel.js.map