import { DocumentParser } from '../parser/documentParser';
import { Position, Range } from './position';
import { BladeDocument } from '../document/bladeDocument';
import { Offset } from './offset';
import { BladeError } from '../errors/bladeError';
export declare enum FragmentPosition {
    IsDynamicFragmentName = 0,
    InsideFragmentParameter = 1,
    InsideFragment = 2,
    Unresolved = 3
}
export declare class FragmentNode {
    startPosition: Position | null;
    endPosition: Position | null;
    index: number;
    embeddedIndex: number;
    refId: string | null;
    parameters: FragmentParameterNode[];
    isSelfClosing: boolean;
    isClosingFragment: boolean;
    name: string;
    containsStructures: boolean;
    constructor();
}
export interface StructuralFragment {
    start: FragmentNode;
    end: FragmentNode;
}
export declare class FragmentParameterNode {
    startPosition: Position | null;
    endPosition: Position | null;
}
export declare class AbstractNode {
    protected parser: DocumentParser | null;
    refId: string | null;
    startPosition: Position | null;
    endPosition: Position | null;
    sourceContent: string;
    index: number;
    parentIndex: number;
    parentTypeIndex: number;
    parent: AbstractNode | null;
    originalAbstractNode: AbstractNode | null;
    fragment: FragmentNode | null;
    fragmentPosition: FragmentPosition;
    containsAnyFragments: boolean;
    containsChildStructures: boolean;
    offset: Offset | null;
    errors: BladeError[];
    isInScriptTag: boolean;
    isInStyleTag: boolean;
    isPartOfHtmlTag(): boolean;
    isEmbedded(): boolean;
    prevNode: AbstractNode | null;
    nextNode: AbstractNode | null;
    constructor();
    hasNeighborsOnLine(): boolean;
    getErrors(): BladeError[];
    pushError(error: BladeError): void;
    relativeOffset(offset: number): number;
    withParser(parser: DocumentParser): this;
    getParser(): DocumentParser | null;
}
export declare enum ParameterType {
    Parameter = 0,
    Directive = 1,
    Attribute = 2,
    InlineEcho = 3,
    Comment = 4
}
export declare class ParameterNode extends AbstractNode {
    private cachedHasValidPhp;
    private cachedPhpLastError;
    name: string;
    realName: string;
    value: string;
    terminatorStyle: string;
    wrappedValue: string;
    content: string;
    type: ParameterType;
    directive: DirectiveNode | null;
    inlineEcho: BladeEchoNode | null;
    inlineComment: BladeCommentNode | null;
    namePosition: Range | null;
    valuePosition: Range | null;
    isEscapedExpression: boolean;
    isExpression: boolean;
    overrideValue: string;
    hasValidPhpExpression(): boolean;
}
export declare class ComponentNameNode extends AbstractNode {
    name: string;
    inlineName: string;
}
export declare class BladeComponentNode extends AbstractNode {
    name: ComponentNameNode | null;
    isClosingTag: boolean;
    isSelfClosing: boolean;
    innerContent: string;
    parameterContent: string;
    receivesAttributeBag: boolean;
    hasParameters: boolean;
    parameters: ParameterNode[];
    isOpenedBy: BladeComponentNode | null;
    isClosedBy: BladeComponentNode | null;
    isShorthandSlot: boolean;
    getComponentName(): string;
    hasParameter(name: string): boolean;
    getParameter(name: string): ParameterNode | null;
    getParametersExcept(parameters: string[]): ParameterNode[];
}
export declare class LiteralNode extends AbstractNode {
    content: string;
    getOutputContent(): string;
}
export declare class BladeCommentNode extends AbstractNode {
    innerContentPosition: Range | null;
    innerContent: string;
    isMultiline(): boolean;
}
export declare class InlinePhpNode extends AbstractNode {
    private cachedHasValidPhp;
    private cachedPhpLastError;
    isInline: boolean;
    overrideContent: string | null;
    hasValidPhp(): boolean;
    getPhpError(): SyntaxError | null;
}
export declare class ShorthandInlinePhpNode extends InlinePhpNode {
}
export declare class DirectiveNode extends AbstractNode {
    name: string;
    directiveName: string;
    namePosition: Range | null;
    hasDirectiveParameters: boolean;
    directiveParameters: string;
    overrideParams: string | null;
    directiveParametersPosition: Range | null;
    children: AbstractNode[];
    childrenDocument: ChildDocument | null;
    childTypeCounts: Map<string, number>;
    _conditionParserAbandonPairing: boolean;
    hasJsonParameters: boolean;
    ref: number;
    isClosedBy: DirectiveNode | null;
    isOpenedBy: DirectiveNode | null;
    isClosingDirective: boolean;
    innerContent: string;
    documentContent: string;
    nodeContent: string;
    private cachedHasValidJson;
    private cachedHasValidPhp;
    private cachedPhpLastError;
    hasValidJson(): boolean;
    hasValidPhp(): boolean;
    getPhpError(): SyntaxError | null;
    isFirstOfType(): boolean;
    hasInnerExpression(): boolean;
    getInnerContent(): string;
    getImmediateChildren(): AbstractNode[];
    getPhpContent(): string;
    getChildren(): AbstractNode[];
    hasChildDirectiveOfType(name: string): boolean;
    findFirstChildDirectiveOfType(name: string): DirectiveNode | null;
    findFirstDirectChildDirectiveOfType(name: string): DirectiveNode | null;
    findDirectivesOfType(name: string): DirectiveNode[];
    findDirectChildDirectivesOfType(name: string): DirectiveNode[];
    clone(): DirectiveNode;
    getFinalClosingDirective(): DirectiveNode;
}
export declare class ExecutionBranchNode extends AbstractNode {
    head: DirectiveNode | null;
    tail: DirectiveNode | null;
    nodes: AbstractNode[];
    childDocument: ChildDocument | null;
    documentContent: string;
    innerContent: string;
    innerOffset: Offset | null;
}
export declare class ConditionNode extends DirectiveNode {
    constructedFrom: AbstractNode | null;
    nodeContent: string;
    logicBranches: ExecutionBranchNode[];
    chain: number[];
    getParent(): DirectiveNode | null;
}
export declare class SwitchStatementNode extends AbstractNode {
    constructedFrom: AbstractNode | null;
    nodeContent: string;
    originalNode: DirectiveNode | null;
    tail: DirectiveNode | null;
    cases: SwitchCaseNode[];
}
export declare class SwitchCaseNode extends AbstractNode {
    order: number;
    leadingNodes: AbstractNode[];
    leadingDocument: ChildDocument | null;
    head: DirectiveNode | null;
    children: AbstractNode[];
    isDefault: boolean;
    isClosedBy: DirectiveNode | null;
    childDocument: ChildDocument | null;
    documentContent: string;
    innerContent: string;
    innerOffset: Offset | null;
}
export declare class ForElseNode extends AbstractNode {
    constructedFrom: AbstractNode | null;
    nodeContent: string;
    originalNode: DirectiveNode | null;
    truthNodes: AbstractNode[];
    elseNode: DirectiveNode | null;
    falseNodes: AbstractNode[];
    tailNode: DirectiveNode | null;
    truthDocument: ChildDocument | null;
    falseDocument: ChildDocument | null;
    documentContent: string;
    truthDocumentContent: string;
    truthInnerContent: string;
    truthDocumentOffset: Offset | null;
    truthInnerOffset: Offset | null;
    falseDocumentContent: string;
    falseInnerContent: string;
    falseDocumentOffset: Offset | null;
    falseInnerOffset: Offset | null;
}
export declare class BladeEchoNode extends AbstractNode {
    content: string;
    private cachedHasValidPhp;
    private cachedPhpLastError;
    isInlineEcho: boolean;
    overrideContent: string | null;
    hasValidPhp(): boolean;
    getPhpError(): SyntaxError | null;
}
export declare class BladeEscapedEchoNode extends BladeEchoNode {
}
export declare class BladeEntitiesEchoNode extends BladeEchoNode {
}
export declare class BladePhpNode extends AbstractNode {
}
export declare class BladeStaticNode extends AbstractNode {
}
export declare class BladeVerbatimNode extends AbstractNode {
}
export declare class OperatorNode extends AbstractNode {
}
export declare class ArrayStartNode extends AbstractNode {
    tokenLength: number;
}
export declare class ArrayEndNode extends AbstractNode {
}
export declare class ArrayElementSeparatorNode extends AbstractNode {
}
export declare class ArrayKeyValueNode extends AbstractNode {
}
export declare class ArrayElementNode extends AbstractNode {
    key: AbstractNode | null;
    value: AbstractNode | null;
    isLast: boolean;
}
export declare class ArrayNode extends AbstractNode {
    elements: ArrayElementNode[];
    containsKeys: boolean;
    maxKeyLength: number;
}
export interface ChildDocument {
    renderNodes: AbstractNode[];
    content: string;
    document: BladeDocument;
}
//# sourceMappingURL=nodes.d.ts.map