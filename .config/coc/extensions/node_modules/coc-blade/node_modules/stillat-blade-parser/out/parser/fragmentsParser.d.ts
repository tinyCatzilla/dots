import { FragmentNode, StructuralFragment } from '../nodes/nodes';
import { Position } from '../nodes/position';
import { DocumentOffset } from './documentOffset';
import { IExtractedAttribute } from './extractedAttribute';
import { IndexRange } from './indexRange';
import { StringIterator } from './stringIterator';
export declare class FragmentsParser implements StringIterator {
    private content;
    private nodeIndex;
    private nodeIndexSkipMap;
    private fragmentStartIndex;
    private charLen;
    private documentOffsets;
    private inputLen;
    private seedOffset;
    private shiftLine;
    private chars;
    private currentIndex;
    private lastDocumentOffsetKey;
    private cur;
    private next;
    private prev;
    private chunkSize;
    private currentChunkOffset;
    private fragments;
    private isScript;
    private fragmentOpeningIndex;
    private indexedFragments;
    private embeddedIndexedFragments;
    private extractAttributePositions;
    private extractAttributeNames;
    private excludeAttributeNames;
    private extractedAttributes;
    private lastFragmentEnded;
    private parsingTracedStringHitEof;
    advance(count: number): void;
    getParsingTracedStringHitEof(): boolean;
    encounteredFailure(): void;
    updateIndex(index: number): void;
    inputLength(): number;
    incrementIndex(): void;
    getCurrentIndex(): number;
    getCurrent(): string | null;
    getNext(): string | null;
    getPrev(): string | null;
    pushChar(value: string): void;
    getChar(index: number): string;
    getSeedOffset(): number;
    setDocumentOffsets(offsets: Map<number, DocumentOffset>, lastOffsetIndex: number | null): this;
    getClosingFragmentAfter(fragment: FragmentNode): FragmentNode | null;
    setExcludeAttributes(excludeAttributes: string[]): void;
    setExtractAttributes(extractAttributes: boolean): void;
    setExtractAttributeNames(attributeNames: string[]): void;
    getContentSubstring(from: number, length: number): string;
    getExtractedAttributes(): IExtractedAttribute[];
    private resetState;
    protected resetIntermediateState(): void;
    private positionFromOffset;
    getFragments(): FragmentNode[];
    getFragmentsBetween(startIndex: number, endIndex: number): FragmentNode[];
    getFragmentContaining(position: Position): FragmentNode | null;
    checkCurrentOffsets(): void;
    private processInputText;
    setIndexRanges(index: IndexRange[]): this;
    private fetchAt;
    getEmbeddedDocumentStructures(): StructuralFragment[];
    getFragmentsContainingStructures(): StructuralFragment[];
    parse(text: string): FragmentNode[];
    getFragment(index: number): FragmentNode;
    getEmbeddedFragment(index: number): FragmentNode;
    getEmbeddedFragments(): FragmentNode[];
    hasFragments(): boolean;
    private getCheckAttributeName;
    private shouldSkip;
    private skipToEndOfPhp;
    private scanBackToName;
    private shouldExtract;
    private parseIntermediateText;
    private skipToEndOfStringWithIndex;
}
//# sourceMappingURL=fragmentsParser.d.ts.map