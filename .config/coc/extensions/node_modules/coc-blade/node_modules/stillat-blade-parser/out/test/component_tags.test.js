"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const bladeDocument_1 = require("../document/bladeDocument");
const nodes_1 = require("../nodes/nodes");
const assertions_1 = require("./testUtils/assertions");
suite('Component Tags', () => {
    test('it can parse component tags', () => {
        const nodes = bladeDocument_1.BladeDocument.fromText(`<x-slot name="foo">a
    Test
b</x-slot>`).getAllNodes();
        (0, assertions_1.assertCount)(3, nodes);
        (0, assertions_1.assertInstanceOf)(nodes_1.BladeComponentNode, nodes[0]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[1]);
        (0, assertions_1.assertInstanceOf)(nodes_1.BladeComponentNode, nodes[2]);
        (0, assertions_1.assertLiteralContent)("a\n    Test\nb", nodes[1]);
        const componentOne = nodes[0], componentTwo = nodes[2];
        assert.strictEqual(componentOne.isClosingTag, false);
        assert.strictEqual(componentOne.isSelfClosing, false);
        assert.strictEqual(componentOne.sourceContent, "<x-slot name=\"foo\">");
        assert.strictEqual(componentTwo.isClosingTag, true);
        assert.strictEqual(componentTwo.isSelfClosing, false);
        assert.strictEqual(componentTwo.sourceContent, "</x-slot>");
    });
    test('it can parse self-closing tags', () => {
        const nodes = bladeDocument_1.BladeDocument.fromText(`<x-slot name="foo" /><x-slot name="bar"/>`).getAllNodes();
        (0, assertions_1.assertCount)(2, nodes);
        (0, assertions_1.assertInstanceOf)(nodes_1.BladeComponentNode, nodes[0]);
        (0, assertions_1.assertInstanceOf)(nodes_1.BladeComponentNode, nodes[1]);
        const componentOne = nodes[0], componentTwo = nodes[1];
        assert.strictEqual(componentOne.isClosingTag, false);
        assert.strictEqual(componentOne.isSelfClosing, true);
        assert.strictEqual(componentOne.sourceContent, "<x-slot name=\"foo\" />");
        assert.strictEqual(componentTwo.isClosingTag, false);
        assert.strictEqual(componentTwo.isSelfClosing, true);
        assert.strictEqual(componentTwo.sourceContent, "<x-slot name=\"bar\"/>");
    });
    test('it can parse tag inner content', () => {
        const nodes = bladeDocument_1.BladeDocument.fromText(`<x-slot name="foo" a/><x-slot name="bar" b>`).getAllNodes();
        (0, assertions_1.assertCount)(2, nodes);
        (0, assertions_1.assertInstanceOf)(nodes_1.BladeComponentNode, nodes[0]);
        (0, assertions_1.assertInstanceOf)(nodes_1.BladeComponentNode, nodes[1]);
        const componentOne = nodes[0], componentTwo = nodes[1];
        assert.strictEqual(componentOne.isClosingTag, false);
        assert.strictEqual(componentOne.isSelfClosing, true);
        assert.strictEqual(componentOne.sourceContent, "<x-slot name=\"foo\" a/>");
        assert.strictEqual(componentOne.innerContent, "slot name=\"foo\" a");
        assert.strictEqual(componentTwo.isClosingTag, false);
        assert.strictEqual(componentTwo.isSelfClosing, false);
        assert.strictEqual(componentTwo.innerContent, "slot name=\"bar\" b");
        assert.strictEqual(componentTwo.sourceContent, "<x-slot name=\"bar\" b>");
    });
    test('it can parse tag names', () => {
        const nodes = bladeDocument_1.BladeDocument.fromText(`
     a<x-slot name="foo" a/>b
  c<x-slot name="bar" b>d`).getAllNodes();
        (0, assertions_1.assertCount)(5, nodes);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[0]);
        (0, assertions_1.assertInstanceOf)(nodes_1.BladeComponentNode, nodes[1]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[2]);
        (0, assertions_1.assertInstanceOf)(nodes_1.BladeComponentNode, nodes[3]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[4]);
        (0, assertions_1.assertLiteralContent)("\n     a", nodes[0]);
        (0, assertions_1.assertLiteralContent)("b\n  c", nodes[2]);
        (0, assertions_1.assertLiteralContent)("d", nodes[4]);
        const c1 = nodes[1], c2 = nodes[3];
        assert.strictEqual(c1.innerContent, "slot name=\"foo\" a");
        assert.strictEqual(c1.isClosingTag, false);
        assert.strictEqual(c1.isSelfClosing, true);
        (0, assertions_1.assertNotNull)(c1.name);
        const c1Name = c1.name;
        assert.strictEqual(c1Name.name, 'slot');
        (0, assertions_1.assertPosition)(c1Name.startPosition, 2, 10);
        (0, assertions_1.assertPosition)(c1Name.endPosition, 2, 13);
        assert.strictEqual(c2.innerContent, "slot name=\"bar\" b");
        assert.strictEqual(c2.isClosingTag, false);
        assert.strictEqual(c2.isSelfClosing, false);
        (0, assertions_1.assertNotNull)(c2.name);
        const c2Name = c2.name;
        assert.strictEqual(c2Name.name, 'slot');
        (0, assertions_1.assertPosition)(c2Name.startPosition, 3, 7);
        (0, assertions_1.assertPosition)(c2Name.endPosition, 3, 10);
    });
    test('it can parse parameter content', () => {
        const nodes = bladeDocument_1.BladeDocument.fromText(`
     a<x-slot name="foo" a/>b
  c<x-slot name="bar" b>d`).getAllNodes();
        (0, assertions_1.assertCount)(5, nodes);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[0]);
        (0, assertions_1.assertInstanceOf)(nodes_1.BladeComponentNode, nodes[1]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[2]);
        (0, assertions_1.assertInstanceOf)(nodes_1.BladeComponentNode, nodes[3]);
        (0, assertions_1.assertInstanceOf)(nodes_1.LiteralNode, nodes[4]);
        (0, assertions_1.assertLiteralContent)("\n     a", nodes[0]);
        (0, assertions_1.assertLiteralContent)("b\n  c", nodes[2]);
        (0, assertions_1.assertLiteralContent)("d", nodes[4]);
        const c1 = nodes[1], c2 = nodes[3];
        assert.strictEqual(c1.parameterContent, " name=\"foo\" a");
        assert.strictEqual(c2.parameterContent, " name=\"bar\" b");
    });
    test('it can parse parameters', () => {
        const nodes = bladeDocument_1.BladeDocument.fromText(`<x-slot name="foo"
    name-two="bar" value_thing="that" ::this="that" param-with_chars='this'
    :another='one' hello="world"
/>`).getAllNodes();
        (0, assertions_1.assertCount)(1, nodes);
        (0, assertions_1.assertInstanceOf)(nodes_1.BladeComponentNode, nodes[0]);
        const component = nodes[0];
        assert.strictEqual(component.innerContent, "slot name=\"foo\"\n    name-two=\"bar\" value_thing=\"that\" ::this=\"that\" param-with_chars='this'\n    :another='one' hello=\"world\"\n");
        assert.strictEqual(component.parameterContent, " name=\"foo\"\n    name-two=\"bar\" value_thing=\"that\" ::this=\"that\" param-with_chars='this'\n    :another='one' hello=\"world\"\n");
        assert.strictEqual(component.sourceContent, "<x-slot name=\"foo\"\n    name-two=\"bar\" value_thing=\"that\" ::this=\"that\" param-with_chars='this'\n    :another='one' hello=\"world\"\n/>");
        assert.strictEqual(component.hasParameters, true);
        (0, assertions_1.assertCount)(7, component.parameters);
        assertParameterDetails(component.parameters[0], "name=\"foo\"", "name", "foo", "\"foo\"", "\"");
        assertParameterDetails(component.parameters[1], "name-two=\"bar\"", "name-two", "bar", "\"bar\"", "\"");
        assertParameterDetails(component.parameters[2], "value_thing=\"that\"", "value_thing", "that", "\"that\"", "\"");
        assertParameterDetails(component.parameters[3], "::this=\"that\"", "::this", "that", "\"that\"", "\"");
        assertParameterDetails(component.parameters[4], "param-with_chars='this'", "param-with_chars", "this", "'this'", "'");
        assertParameterDetails(component.parameters[5], ":another='one'", ":another", "one", "'one'", "'");
        assertParameterDetails(component.parameters[6], "hello=\"world\"", "hello", "world", "\"world\"", "\"");
    });
    test('it can detect variable expressions in parameters', () => {
        const nodes = bladeDocument_1.BladeDocument.fromText(`<x-slot :another='one' ::hello="world" />`).getAllNodes();
        (0, assertions_1.assertCount)(1, nodes);
        (0, assertions_1.assertInstanceOf)(nodes_1.BladeComponentNode, nodes[0]);
        const component = nodes[0];
        assert.strictEqual(component.hasParameters, true);
        (0, assertions_1.assertCount)(2, component.parameters);
        const param1 = component.parameters[0], param2 = component.parameters[1];
        assert.strictEqual(param1.realName, 'another');
        assert.strictEqual(param1.isExpression, true);
        assert.strictEqual(param2.realName, 'hello');
        assert.strictEqual(param2.isExpression, false);
    });
});
function assertParameterDetails(parameter, content, name, value, wrappedValue, terminator) {
    assert.strictEqual(parameter.content, content);
    assert.strictEqual(parameter.name, name);
    assert.strictEqual(parameter.value, value);
    assert.strictEqual(parameter.wrappedValue, wrappedValue);
    assert.strictEqual(parameter.terminatorStyle, terminator);
}
//# sourceMappingURL=component_tags.test.js.map