"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassStringRuleEngine = exports.classConfigFromObject = exports.getDefaultClassStringConfig = void 0;
const genericLanguageStructures_1 = require("../analyzers/genericLanguageStructures");
const nodes_1 = require("../nodes/nodes");
function getDefaultClassStringConfig() {
    return {
        enabled: true,
        directivesEnabled: true,
        excludedDirectives: [
            'if', 'unless', 'elseif', 'for', 'forelse', 'foreach',
        ],
        allowedMethodNames: ['class'],
        directives: [],
        bladePhpEnabled: true,
        phpTagsEnabled: true,
        phpTagRules: [],
        ignoredLanguageStructures: [
            genericLanguageStructures_1.GenericLanguageStructures.CallStatement,
            genericLanguageStructures_1.GenericLanguageStructures.IfStatement,
            genericLanguageStructures_1.GenericLanguageStructures.TernaryStatement,
            genericLanguageStructures_1.GenericLanguageStructures.BinCompare,
            genericLanguageStructures_1.GenericLanguageStructures.Addition,
            genericLanguageStructures_1.GenericLanguageStructures.Substraction,
            genericLanguageStructures_1.GenericLanguageStructures.Multiplication,
            genericLanguageStructures_1.GenericLanguageStructures.Division,
            genericLanguageStructures_1.GenericLanguageStructures.Modulus,
            genericLanguageStructures_1.GenericLanguageStructures.Exponentiation,
            genericLanguageStructures_1.GenericLanguageStructures.Concat,
            genericLanguageStructures_1.GenericLanguageStructures.GreaterThan,
            genericLanguageStructures_1.GenericLanguageStructures.GreaterThanEqual,
            genericLanguageStructures_1.GenericLanguageStructures.LessThan,
            genericLanguageStructures_1.GenericLanguageStructures.LessThanEqual,
            genericLanguageStructures_1.GenericLanguageStructures.BitwiseAnd,
            genericLanguageStructures_1.GenericLanguageStructures.BitwiseOr,
            genericLanguageStructures_1.GenericLanguageStructures.BitwiseXor,
            genericLanguageStructures_1.GenericLanguageStructures.LeftShift,
            genericLanguageStructures_1.GenericLanguageStructures.RightShift,
            genericLanguageStructures_1.GenericLanguageStructures.Equality,
            genericLanguageStructures_1.GenericLanguageStructures.Identity,
            genericLanguageStructures_1.GenericLanguageStructures.Inequality,
            genericLanguageStructures_1.GenericLanguageStructures.NotIdentity,
            genericLanguageStructures_1.GenericLanguageStructures.CompAnd,
            genericLanguageStructures_1.GenericLanguageStructures.CompOr,
            genericLanguageStructures_1.GenericLanguageStructures.Xor,
            genericLanguageStructures_1.GenericLanguageStructures.AdditionAssignment,
            genericLanguageStructures_1.GenericLanguageStructures.SubtractionAssignment,
            genericLanguageStructures_1.GenericLanguageStructures.MultiplicationAssignment,
            genericLanguageStructures_1.GenericLanguageStructures.DivisionAssignment,
            genericLanguageStructures_1.GenericLanguageStructures.ModulusAssignment,
            genericLanguageStructures_1.GenericLanguageStructures.ConcatenationAssignment,
            genericLanguageStructures_1.GenericLanguageStructures.BitwiseAndAssignment,
            genericLanguageStructures_1.GenericLanguageStructures.BitwiseOrAssignment,
            genericLanguageStructures_1.GenericLanguageStructures.BitwiseXorAssignment,
            genericLanguageStructures_1.GenericLanguageStructures.LeftShiftAssignment,
            genericLanguageStructures_1.GenericLanguageStructures.RightShiftAssignment,
        ],
        bladeEchoEnabled: true,
        bladeEchoRules: [],
        documentRules: {
            includeWhen: [],
            excludeWhen: []
        },
        stringRules: {
            includeWhen: [],
            excludeWhen: []
        }
    };
}
exports.getDefaultClassStringConfig = getDefaultClassStringConfig;
function classConfigFromObject(config) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const defaults = getDefaultClassStringConfig();
    function validateRuleset(ruleset) {
        var _a, _b;
        return {
            includeWhen: (_a = ruleset.includeWhen) !== null && _a !== void 0 ? _a : [],
            excludeWhen: (_b = ruleset.excludeWhen) !== null && _b !== void 0 ? _b : []
        };
    }
    function getSingleRuleset(config, defaults) {
        var _a, _b;
        if (!config) {
            return defaults;
        }
        if (!config.includeWhen && !config.excludeWhen) {
            return defaults;
        }
        return {
            excludeWhen: (_a = config.excludeWhen) !== null && _a !== void 0 ? _a : [],
            includeWhen: (_b = config.includeWhen) !== null && _b !== void 0 ? _b : []
        };
    }
    return {
        enabled: (_a = config.enabled) !== null && _a !== void 0 ? _a : defaults.enabled,
        allowedMethodNames: (_b = config.allowedMethodNames) !== null && _b !== void 0 ? _b : defaults.allowedMethodNames,
        directivesEnabled: (_c = config.directivesEnabled) !== null && _c !== void 0 ? _c : defaults.directivesEnabled,
        excludedDirectives: (_d = config.excludedDirectives) !== null && _d !== void 0 ? _d : defaults.excludedDirectives,
        directives: ((_e = config.directives) !== null && _e !== void 0 ? _e : defaults.directives).map(validateRuleset),
        bladePhpEnabled: (_f = config.bladePhpEnabled) !== null && _f !== void 0 ? _f : defaults.bladePhpEnabled,
        phpTagsEnabled: (_g = config.phpTagsEnabled) !== null && _g !== void 0 ? _g : defaults.phpTagsEnabled,
        phpTagRules: ((_h = config.phpTagRules) !== null && _h !== void 0 ? _h : defaults.phpTagRules).map(validateRuleset),
        ignoredLanguageStructures: (_j = config.ignoredLanguageStructures) !== null && _j !== void 0 ? _j : defaults.ignoredLanguageStructures,
        bladeEchoEnabled: (_k = config.bladeEchoEnabled) !== null && _k !== void 0 ? _k : defaults.bladeEchoEnabled,
        bladeEchoRules: ((_l = config.bladeEchoRules) !== null && _l !== void 0 ? _l : defaults.bladeEchoRules).map(validateRuleset),
        documentRules: getSingleRuleset(config.documentRules, defaults.documentRules),
        stringRules: getSingleRuleset(config.stringRules, defaults.stringRules)
    };
}
exports.classConfigFromObject = classConfigFromObject;
class ClassStringRuleEngine {
    constructor(config) {
        this.directiveExcludeRules = [];
        this.directiveIncludeRules = [];
        this.phpTagExcludeRules = [];
        this.phpTagIncludeRules = [];
        this.echoExcludeRules = [];
        this.echoIncludeRules = [];
        this.documentExcludeRules = [];
        this.documentIncludeRules = [];
        this.stringExcludeRules = [];
        this.stringIncludeRules = [];
        this.config = config;
        // Build up the internal reference lists.
        this.directiveExcludeRules = this.getExcludeRules(config.directives);
        this.directiveIncludeRules = this.getIncludeRules(config.directives);
        this.phpTagExcludeRules = this.getExcludeRules(config.phpTagRules);
        this.phpTagIncludeRules = this.getIncludeRules(config.phpTagRules);
        this.echoExcludeRules = this.getExcludeRules(config.bladeEchoRules);
        this.echoIncludeRules = this.getIncludeRules(config.bladeEchoRules);
        this.documentExcludeRules = config.documentRules.excludeWhen;
        this.documentIncludeRules = config.documentRules.includeWhen;
        this.stringExcludeRules = config.stringRules.excludeWhen;
        this.stringIncludeRules = config.stringRules.includeWhen;
    }
    getIncludeRules(rules) {
        let includeRules = [];
        rules.forEach((rule) => {
            includeRules = includeRules.concat(rule.includeWhen);
        });
        return includeRules;
    }
    getExcludeRules(rules) {
        let excludeRules = [];
        rules.forEach((rule) => {
            excludeRules = excludeRules.concat(rule.excludeWhen);
        });
        return excludeRules;
    }
    passes(content, patterns) {
        if (patterns.length == 0) {
            return true;
        }
        for (let i = 0; i < patterns.length; i++) {
            if ((new RegExp(patterns[i])).test(content)) {
                return true;
            }
        }
        return false;
    }
    canTransformDocument(document) {
        if (!this.config.enabled) {
            return false;
        }
        const docText = document.getContent();
        if (this.documentExcludeRules.length > 0 && !this.passes(docText, this.documentExcludeRules)) {
            return false;
        }
        return this.passes(docText, this.documentIncludeRules);
    }
    canTransformString(content) {
        if (this.stringExcludeRules.length > 0 && this.passes(content, this.stringExcludeRules)) {
            return false;
        }
        return this.passes(content, this.stringIncludeRules);
    }
    canTransform(content, specificExcludes, specificIncludes) {
        if (specificExcludes.length > 0 && this.passes(content, specificExcludes)) {
            return false;
        }
        if (!this.passes(content, specificIncludes)) {
            return false;
        }
        // Test against the generic rules, if available.
        if (this.stringExcludeRules.length > 0 && this.passes(content, this.stringExcludeRules)) {
            return false;
        }
        return this.passes(content, this.stringIncludeRules);
    }
    canTransformBladeEcho(echo) {
        if (!this.config.enabled || !this.config.bladeEchoEnabled) {
            return false;
        }
        return this.canTransform(echo.content, this.echoExcludeRules, this.echoIncludeRules);
    }
    canTransformBladePhp(bladePhp) {
        if (!this.config.enabled || !this.config.bladePhpEnabled) {
            return false;
        }
        return this.canTransform(bladePhp.documentContent, this.phpTagExcludeRules, this.phpTagIncludeRules);
    }
    canTransformInlinePhp(inlinePhp) {
        if (!this.config.enabled || !this.config.phpTagsEnabled) {
            return false;
        }
        return this.canTransform(inlinePhp.sourceContent, this.phpTagExcludeRules, this.phpTagIncludeRules);
    }
    canTransformDirective(directiveNode) {
        if (!this.config.enabled || !this.config.directivesEnabled) {
            return false;
        }
        let checkName = directiveNode.directiveName;
        if (directiveNode.originalAbstractNode != null) {
            if (directiveNode.originalAbstractNode instanceof nodes_1.DirectiveNode) {
                checkName = directiveNode.originalAbstractNode.directiveName;
            }
        }
        checkName = checkName.toLowerCase();
        if (this.config.excludedDirectives.length > 0 && (this.config.excludedDirectives.includes(checkName) || this.config.excludedDirectives.includes(directiveNode.directiveName.toLocaleLowerCase()))) {
            return false;
        }
        return this.canTransform(directiveNode.sourceContent, this.directiveExcludeRules, this.directiveIncludeRules);
    }
}
exports.ClassStringRuleEngine = ClassStringRuleEngine;
//# sourceMappingURL=classStringsConfig.js.map