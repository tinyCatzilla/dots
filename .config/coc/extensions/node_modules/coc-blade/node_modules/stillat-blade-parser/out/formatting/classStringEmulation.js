"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassStringEmulation = void 0;
const stringUtilities_1 = require("../utilities/stringUtilities");
const bladeDocument_1 = require("../document/bladeDocument");
const nodes_1 = require("../nodes/nodes");
const classEmulator_1 = require("../parser/classEmulator");
const parserOptions_1 = require("../parser/parserOptions");
const classStringsConfig_1 = require("./classStringsConfig");
const transformIgnore_1 = require("../document/transformIgnore");
class ClassStringEmulation {
    constructor(classStringConfig) {
        this.phpValidator = null;
        this.isIgnoring = false;
        this.classStringConfig = classStringConfig;
        this.classRuleEngine = new classStringsConfig_1.ClassStringRuleEngine(this.classStringConfig);
        this.parserOptions = (0, parserOptions_1.getParserOptions)();
    }
    withPhpValidator(phpValidator) {
        this.phpValidator = phpValidator;
        return this;
    }
    withParserOptions(parserOptions) {
        this.parserOptions = parserOptions;
        return this;
    }
    getEmulator() {
        const emulator = new classEmulator_1.ClassEmulator(this.classRuleEngine);
        emulator.setExcludedLanguageStructures(this.classStringConfig.ignoredLanguageStructures);
        emulator.setAllowedMethodNames(this.classStringConfig.allowedMethodNames);
        return emulator;
    }
    transform(content) {
        var _a;
        const document = new bladeDocument_1.BladeDocument();
        document.getParser()
            .withParserOptions(this.parserOptions)
            .withPhpValidator(this.phpValidator);
        document.loadString(content);
        const nodes = document.getAllNodes();
        // If something went horribly wrong while parsing
        // the input document, we will skip class string
        // emulation, as we cannot guarantee anything
        // about the placement of strings inside.
        if (document.getParser().getDidRecovery()) {
            return content;
        }
        let stringResults = '';
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node instanceof nodes_1.LiteralNode) {
                stringResults += node.content;
            }
            else if (node instanceof nodes_1.SwitchStatementNode) {
                stringResults += node.nodeContent;
            }
            else if (node instanceof nodes_1.ConditionNode) {
                stringResults += node.nodeContent;
            }
            else if (node instanceof nodes_1.DirectiveNode) {
                if (this.isIgnoring || this.classStringConfig.excludedDirectives.includes(node.directiveName.toLowerCase())) {
                    stringResults += node.sourceContent;
                }
                else {
                    if (node.directiveName == 'php') {
                        if (node.isClosedBy != null) {
                            if (this.isIgnoring || !this.classRuleEngine.canTransformBladePhp(node)) {
                                stringResults += node.sourceContent + node.documentContent;
                            }
                            else {
                                if ((_a = this.phpValidator) === null || _a === void 0 ? void 0 : _a.isValid(node.documentContent, true)) {
                                    const phpEmulate = this.getEmulator();
                                    stringResults += '@php' + phpEmulate.emulatePhpNode(node.documentContent);
                                }
                                else {
                                    stringResults += node.sourceContent + node.documentContent;
                                }
                            }
                        }
                        else {
                            stringResults += node.sourceContent;
                        }
                    }
                    else if (node.directiveName == 'verbatim') {
                        stringResults += node.sourceContent + node.innerContent;
                    }
                    else {
                        if (this.isIgnoring || node.hasJsonParameters || !this.classRuleEngine.canTransformDirective(node)) {
                            stringResults += node.sourceContent;
                        }
                        else {
                            if (!node.hasDirectiveParameters || !node.hasValidPhp()) {
                                stringResults += node.sourceContent;
                            }
                            else {
                                const dirEmulate = this.getEmulator();
                                stringResults += dirEmulate.emulateString(node.sourceContent);
                            }
                            if (i + 1 < nodes.length && nodes[i + 1] instanceof nodes_1.LiteralNode) {
                                const literal = nodes[i + 1];
                                if (literal.content.length == 0) {
                                    continue;
                                }
                                const firstCh = literal.content[0];
                                if (stringUtilities_1.StringUtilities.ctypePunct(firstCh)) {
                                    continue;
                                }
                                if (!stringUtilities_1.StringUtilities.ctypeSpace(firstCh)) {
                                    stringResults += ' ';
                                }
                            }
                        }
                    }
                }
            }
            else if (node instanceof nodes_1.BladeEchoNode) {
                if (this.isIgnoring || !this.classRuleEngine.canTransformBladeEcho(node) || !node.hasValidPhp()) {
                    stringResults += node.sourceContent;
                }
                else {
                    const phpEmulate = this.getEmulator(), echoResults = phpEmulate.emulatePhpNode(node.content).trim();
                    let start = '{{ ', end = ' }}';
                    if (node instanceof nodes_1.BladeEscapedEchoNode) {
                        start = '{!! ';
                        end = ' !!}';
                    }
                    else if (node instanceof nodes_1.BladeEntitiesEchoNode) {
                        start = '{{{ ';
                        end = ' }}}';
                    }
                    stringResults += start + echoResults + end;
                }
            }
            else if (node instanceof nodes_1.ForElseNode) {
                stringResults += node.nodeContent;
            }
            else if (node instanceof nodes_1.BladeCommentNode) {
                stringResults += node.sourceContent;
                if (node.innerContent.trim() == transformIgnore_1.TransformIgnore.FormatIgnoreStart) {
                    this.isIgnoring = true;
                }
                else if (node.innerContent.trim() == transformIgnore_1.TransformIgnore.FormatIgnoreEnd) {
                    this.isIgnoring = false;
                }
            }
            else if (node instanceof nodes_1.BladeComponentNode) {
                stringResults += node.sourceContent;
            }
            else if (node instanceof nodes_1.InlinePhpNode) {
                if (this.isIgnoring || !this.classRuleEngine.canTransformInlinePhp(node) || !node.hasValidPhp()) {
                    stringResults += node.sourceContent;
                }
                else {
                    const phpEmulate = this.getEmulator();
                    stringResults += phpEmulate.emulatePhpTag(node.sourceContent);
                }
            }
        }
        return stringResults;
    }
}
exports.ClassStringEmulation = ClassStringEmulation;
//# sourceMappingURL=classStringEmulation.js.map