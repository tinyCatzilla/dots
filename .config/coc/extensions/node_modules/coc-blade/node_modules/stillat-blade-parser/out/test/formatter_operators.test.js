"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("../formatting/prettier/utils");
suite('Operator Formatting Tests', () => {
    test('it reflows not operator inside echos', () => {
        assert_1.default.strictEqual((0, utils_1.formatBladeString)('{{ ! $foo }}').trim(), '{{ ! $foo }}');
        assert_1.default.strictEqual((0, utils_1.formatBladeString)('{{ !                 $foo }}').trim(), '{{ ! $foo }}');
        assert_1.default.strictEqual((0, utils_1.formatBladeString)('{{ !$foo }}').trim(), '{{ ! $foo }}');
        assert_1.default.strictEqual((0, utils_1.formatBladeString)('{{{ !$foo }}}').trim(), '{{{ ! $foo }}}');
        assert_1.default.strictEqual((0, utils_1.formatBladeString)('{!! !$foo !!}').trim(), '{!! ! $foo !!}');
    });
    test('it reflows not operator inside conditions', () => {
        const template = `
        @if(!$something)
            Do the thing.
                @endif
        `;
        const out = `@if (! $something)
    Do the thing.
@endif
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(template), out);
    });
    test('it does not break up inequality', () => {
        const template = `@if ($foo !== 'bar')
@endif`;
        const out = `@if ($foo !== "bar")
@endif
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeString)(template), out);
    });
});
//# sourceMappingURL=formatter_operators.test.js.map