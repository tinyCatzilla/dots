"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringRemover = void 0;
const stringUtilities_1 = require("../utilities/stringUtilities");
const isStartOfString_1 = require("./scanners/isStartOfString");
const skipToEndOfString_1 = require("./scanners/skipToEndOfString");
class StringRemover {
    constructor() {
        this.chars = [];
        this.cur = null;
        this.prev = null;
        this.next = null;
        this.currentIndex = 0;
        this.inputLen = 0;
        this.currentContent = [];
        this.strings = [];
    }
    advance(count) {
        for (let i = 0; i < count; i++) {
            this.currentIndex++;
            this.checkCurrentOffsets();
        }
    }
    encounteredFailure() {
        return;
    }
    updateIndex(index) {
        this.currentIndex = index;
    }
    inputLength() {
        return this.inputLen;
    }
    getCurrentIndex() {
        return this.currentIndex;
    }
    incrementIndex() {
        this.currentIndex += 1;
    }
    getCurrent() {
        return this.cur;
    }
    getNext() {
        return this.next;
    }
    getPrev() {
        return this.prev;
    }
    checkCurrentOffsets() {
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (this.currentIndex > 0) {
            this.prev = this.chars[this.currentIndex - 1];
        }
        if ((this.currentIndex + 1) < this.inputLen) {
            this.next = this.chars[this.currentIndex + 1];
        }
    }
    pushChar(value) {
        this.currentContent.push(value);
    }
    getChar(index) {
        return this.chars[index];
    }
    getSeedOffset() {
        return 0;
    }
    getContentSubstring(from, length) {
        return '';
    }
    static fromText(value) {
        const splitter = new StringRemover();
        return splitter.remove(value);
    }
    getStrings() {
        return this.strings;
    }
    remove(value) {
        this.strings = [];
        this.chars = value.split('');
        this.inputLen = this.chars.length;
        for (this.currentIndex = 0; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
                const results = (0, skipToEndOfString_1.skipToEndOfStringTraced)(this);
                this.strings.push(results.value);
                this.currentIndex = results.endedOn;
                if (this.currentIndex == this.inputLen - 1) {
                    break;
                }
                continue;
            }
            this.currentContent.push(this.cur);
        }
        const cleanedChars = [];
        for (let i = 0; i < this.currentContent.length; i++) {
            const char = this.currentContent[i];
            if (i == 0 && char == '@') {
                cleanedChars.push(char);
                continue;
            }
            if (char != '.' && stringUtilities_1.StringUtilities.ctypePunct(char)) {
                break;
            }
            cleanedChars.push(char);
        }
        return cleanedChars.join('');
    }
}
exports.StringRemover = StringRemover;
//# sourceMappingURL=stringRemover.js.map