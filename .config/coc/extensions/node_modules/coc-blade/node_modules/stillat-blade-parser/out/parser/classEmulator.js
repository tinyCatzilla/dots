"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassEmulator = void 0;
const javaScriptStructuresAnalyzer_1 = require("../analyzers/javaScriptStructuresAnalyzer");
const phpStructuresAnalyzer_1 = require("../analyzers/phpStructuresAnalyzer");
const utils_1 = require("../formatting/prettier/utils");
const stringUtilities_1 = require("../utilities/stringUtilities");
const inlineStringParser_1 = require("./inlineStringParser");
const stringRemover_1 = require("./stringRemover");
class ClassEmulator {
    constructor(rules) {
        this.mergeRanges = [];
        this.charsToAvoid = ["\n", '$', '{', '"', "'"];
        this.foundAnyStrings = true;
        this.classRuleEngine = rules;
        this.phpStructuresAnalyzer = new phpStructuresAnalyzer_1.PhpStructuresAnalyzer();
        this.jsStructuresAnalyzer = new javaScriptStructuresAnalyzer_1.JavaScriptStructuresAnalyzer();
        this.stringParser = new inlineStringParser_1.InlineStringParser();
    }
    setAllowedMethodNames(allowedMethodNames) {
        this.phpStructuresAnalyzer.setAllowedMethods(allowedMethodNames);
        this.jsStructuresAnalyzer.setAllowedMethods(allowedMethodNames);
    }
    setExcludedLanguageStructures(structures) {
        this.phpStructuresAnalyzer.setExcludedStructures(structures);
        this.jsStructuresAnalyzer.setExcludedStructures(structures);
    }
    withAdditionalRanges(mergeRanges) {
        this.mergeRanges = this.mergeRanges.concat(mergeRanges);
    }
    isSafeToProcess(value) {
        // Return early if there are no spaces in the content.
        if (!value.includes(' ')) {
            return false;
        }
        // Probably shouldn't continue with this, either.
        if (value.includes(', ')) {
            return false;
        }
        for (let i = 0; i < this.charsToAvoid.length; i++) {
            if (value.includes(this.charsToAvoid[i])) {
                return false;
            }
        }
        return this.classRuleEngine.canTransformString(value);
    }
    getFoundAnyStrings() {
        return this.foundAnyStrings;
    }
    emulateString(content) {
        const uniqueSlug = stringUtilities_1.StringUtilities.makeSlug(32), prefix = `Emulate:${uniqueSlug}=`;
        this.stringParser.setIgnoreRanges(this.phpStructuresAnalyzer.getStructures()
            .concat(this.mergeRanges)
            .concat(this.jsStructuresAnalyzer.getStructures()));
        this.stringParser.parse(content);
        if (!this.stringParser.hasStringNodes()) {
            this.foundAnyStrings = false;
            return content;
        }
        const stringNodes = this.stringParser.getParsedNodes(), stringStartMapping = new Map(), stringTransformMapping = new Map();
        let emulateDocument = '', extractedCount = 0;
        stringNodes.forEach((node) => {
            if (node.type == 'string') {
                const innerContent = node.content.substring(1, node.content.length - 1);
                if (!this.isSafeToProcess(innerContent)) {
                    return;
                }
                stringStartMapping.set(node.index, node.content[0]);
                emulateDocument += `<!-- "${prefix}${node.index}"-->\n`;
                emulateDocument += `<div class="${innerContent}"></div>\n`;
                extractedCount += 2;
            }
        });
        try {
            emulateDocument = (0, utils_1.formatAsHtmlStrings)(emulateDocument);
        }
        catch (err) {
            // If the transformation process failed, we cannot safely
            // continue with anything and to not have things get
            // destroyed we will simply return the original.
            return content;
        }
        // Now that we have formatted our emulated document,
        // we need to get the newly transformed strings.
        // To do this, we can simply use the string
        // remover utility and populate our map.
        const remover = new stringRemover_1.StringRemover();
        remover.remove(emulateDocument);
        const extracted = remover.getStrings();
        // If we do not get the same amount of
        // strings after transforming the
        // content, bail out early.
        if (extracted.length != extractedCount) {
            return content;
        }
        for (let i = 0; i < extracted.length; i++) {
            let line = extracted[i];
            if (line.startsWith(prefix)) {
                line = line.substring(prefix.length).trim();
                const originalNodeIndex = parseInt(line);
                if (i + 1 < extracted.length) {
                    const transformed = extracted[i + 1];
                    stringTransformMapping.set(originalNodeIndex, transformed);
                    i++;
                }
            }
        }
        // Now we can rebuild the document!
        let newDocument = '';
        stringNodes.forEach((node) => {
            if (node.type == 'literal' || !stringTransformMapping.has(node.index)) {
                newDocument += node.content;
                return;
            }
            const originalStringStart = stringStartMapping.get(node.index), transformedResult = stringTransformMapping.get(node.index);
            newDocument += originalStringStart + transformedResult + originalStringStart;
        });
        return newDocument;
    }
    emulatePhpNode(content) {
        const analyzeContent = '<?php ' + content;
        this.phpStructuresAnalyzer.getStructureLocations(analyzeContent, 0);
        return this.emulateString(analyzeContent).trimLeft().substring(6);
    }
    emulatePhpTag(content) {
        this.phpStructuresAnalyzer.getStructureLocations(content, 0);
        return this.emulateString(content);
    }
    emulateJavaScriptString(content) {
        this.jsStructuresAnalyzer.getStructureLocations(content, 0);
        return this.emulateString(content).trimLeft();
    }
}
exports.ClassEmulator = ClassEmulator;
//# sourceMappingURL=classEmulator.js.map