"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JavaScriptStructuresAnalyzer = void 0;
const esprima_1 = require("esprima");
const genericLanguageStructures_1 = require("./genericLanguageStructures");
class JavaScriptStructuresAnalyzer {
    constructor() {
        this.structures = [];
        this.hasStructuresWithUnknownLocations = false;
        this.excludedStructures = [];
        this.allowedMethods = [];
    }
    hasUnknownLocations() {
        return this.hasStructuresWithUnknownLocations;
    }
    getStructureLocations(code, locationOffset) {
        try {
            const ast = (0, esprima_1.parseScript)(code, { loc: true });
            this.findStructureLocations(ast, code, locationOffset);
        }
        catch (error) {
        }
    }
    setExcludedStructures(structures) {
        this.excludedStructures = structures;
    }
    setAllowedMethods(methods) {
        this.allowedMethods = methods;
    }
    getStructures() {
        return this.structures;
    }
    findStructureLocations(ast, code, locationOffset) {
        const ranges = [], excludedStructures = this.excludedStructures, allowedMethodNames = this.allowedMethods;
        let foundUnknownLocations = false;
        function getOffsetFromLineColumn(line, column) {
            const lines = code.split('\n');
            let offset = 0;
            for (let i = 0; i < line - 1; i++) {
                offset += lines[i].length + 1; // +1 to account for the newline character
            }
            offset += column - 1;
            return offset;
        }
        function traverse(node) {
            if (node.loc) {
                const startOffset = getOffsetFromLineColumn(node.loc.start.line, node.loc.start.column) - locationOffset;
                const endOffset = getOffsetFromLineColumn(node.loc.end.line, node.loc.end.column) - locationOffset;
                if (node.type === 'IfStatement') {
                    if (node.test.loc == null) {
                        foundUnknownLocations = true;
                    }
                    if (excludedStructures.includes(genericLanguageStructures_1.GenericLanguageStructures.IfStatement)) {
                        ranges.push({
                            label: genericLanguageStructures_1.GenericLanguageStructures.IfStatement,
                            start: startOffset,
                            end: endOffset,
                        });
                    }
                }
                else if (node.type === 'ConditionalExpression') {
                    if (node.test.loc == null) {
                        foundUnknownLocations = true;
                    }
                    if (excludedStructures.includes(genericLanguageStructures_1.GenericLanguageStructures.TernaryStatement)) {
                        ranges.push({
                            label: genericLanguageStructures_1.GenericLanguageStructures.TernaryStatement,
                            start: startOffset,
                            end: endOffset,
                        });
                    }
                }
                else if (node.type === 'AssignmentExpression') {
                    let addRange = true;
                    if (node.left.loc == null || node.right.loc == null) {
                        foundUnknownLocations = true;
                    }
                    if (!excludedStructures.includes(genericLanguageStructures_1.GenericLanguageStructures.Assignment)) {
                        addRange = false;
                    }
                    if (addRange) {
                        ranges.push({
                            label: genericLanguageStructures_1.GenericLanguageStructures.Assignment,
                            start: startOffset,
                            end: endOffset,
                        });
                    }
                }
                else if (node.type === 'BinaryExpression') {
                    let addRange = true;
                    if (node.left.loc == null || node.right.loc == null) {
                        foundUnknownLocations = true;
                    }
                    if (!excludedStructures.includes(genericLanguageStructures_1.GenericLanguageStructures.BinCompare)) {
                        addRange = false;
                    }
                    if (addRange) {
                        ranges.push({
                            label: genericLanguageStructures_1.GenericLanguageStructures.BinCompare,
                            start: startOffset,
                            end: endOffset,
                        });
                    }
                }
                else if (node.type === 'CallExpression') {
                    let addRange = true;
                    if (node.callee.type === 'MemberExpression') {
                        const memberExpr = node.callee;
                        if (memberExpr.property.type === 'Identifier') {
                            const identifier = memberExpr.property;
                            if (allowedMethodNames.includes(identifier.name)) {
                                addRange = false;
                            }
                        }
                    }
                    if (!excludedStructures.includes(genericLanguageStructures_1.GenericLanguageStructures.CallStatement)) {
                        addRange = false;
                    }
                    if (addRange) {
                        if (node.loc == null) {
                            foundUnknownLocations = true;
                        }
                        ranges.push({
                            label: genericLanguageStructures_1.GenericLanguageStructures.CallStatement,
                            start: startOffset,
                            end: endOffset,
                        });
                    }
                }
            }
            for (const key in node) {
                if (isObject(node[key])) {
                    traverse(node[key]);
                }
            }
        }
        traverse(ast);
        this.hasStructuresWithUnknownLocations = foundUnknownLocations;
        this.structures = ranges;
    }
}
exports.JavaScriptStructuresAnalyzer = JavaScriptStructuresAnalyzer;
function isObject(variable) {
    return typeof variable === 'object' && variable !== null;
}
//# sourceMappingURL=javaScriptStructuresAnalyzer.js.map