"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentParser = void 0;
const nodes_1 = require("../nodes/nodes");
const stringUtilities_1 = require("../utilities/stringUtilities");
const documentParser_1 = require("./documentParser");
const isStartOfString_1 = require("./scanners/isStartOfString");
const nextNonWhitespace_1 = require("./scanners/nextNonWhitespace");
const scanToEndOfLogicGroup_1 = require("./scanners/scanToEndOfLogicGroup");
const skipToEndOfLine_1 = require("./scanners/skipToEndOfLine");
const skipToEndOfMultilineComment_1 = require("./scanners/skipToEndOfMultilineComment");
const skipToEndOfString_1 = require("./scanners/skipToEndOfString");
class ComponentParser {
    constructor(document) {
        this.content = '';
        this.inputLen = 0;
        this.chars = [];
        this.currentContent = [];
        this.prev = null;
        this.cur = null;
        this.next = null;
        this.currentIndex = 0;
        this.hasFoundName = false;
        this.nameStartsOn = 0;
        this.nameEndsOn = -1;
        this.name = '';
        this.parameterContent = '';
        this.activeComponent = null;
        this.document = document;
    }
    advance(count) {
        for (let i = 0; i < count; i++) {
            this.currentIndex++;
            this.checkCurrentOffsets();
        }
    }
    encounteredFailure() {
        return;
    }
    pushChar(value) {
        this.currentContent.push(value);
    }
    updateIndex(index) {
        this.currentIndex = index;
    }
    inputLength() {
        return this.inputLen;
    }
    incrementIndex() {
        this.currentIndex += 1;
    }
    getCurrentIndex() {
        return this.currentIndex;
    }
    getCurrent() {
        return this.cur;
    }
    getNext() {
        return this.next;
    }
    getPrev() {
        return this.prev;
    }
    getChar(index) {
        return this.chars[index];
    }
    getSeedOffset() {
        return 0;
    }
    getContentSubstring(from, length) {
        return this.content.substr(from, length);
    }
    resetState() {
        this.name = '';
        this.parameterContent = '';
        this.hasFoundName = false;
        this.nameStartsOn = 0;
        this.nameEndsOn = -1;
        this.currentIndex = 0;
        this.content = '';
        this.chars = [];
        this.currentContent = [];
        this.inputLen = 0;
        this.prev = null;
        this.cur = null;
        this.next = null;
        return this;
    }
    checkCurrentOffsets() {
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (this.currentIndex > 0) {
            this.prev = this.chars[this.currentIndex - 1];
        }
        if ((this.currentIndex + 1) < this.inputLen) {
            this.next = this.chars[this.currentIndex + 1];
        }
    }
    makeDirective(name, nameStartsOn, nameEndsOn) {
        const directive = new nodes_1.DirectiveNode(), componentOffset = this.getComponentOffset();
        directive.withParser(this.document);
        if (name.startsWith('@')) {
            name = name.substring(1);
        }
        directive.directiveName = name.trim();
        directive.name = name.trim();
        if (name.startsWith('end')) {
            directive.name = name.substring(3);
        }
        else if (name.startsWith('else') && name != 'elseif' && name != 'else') {
            directive.name = 'elseif';
        }
        const nameStartPosition = this.document.positionFromOffset(componentOffset + nameStartsOn, componentOffset + nameStartsOn), nameEndPosition = this.document.positionFromOffset(componentOffset + nameEndsOn, componentOffset + nameEndsOn);
        directive.startPosition = nameStartPosition;
        directive.endPosition = nameEndPosition;
        directive.namePosition = {
            start: nameStartPosition,
            end: nameEndPosition
        };
        directive.hasDirectiveParameters = false;
        if (directive.startPosition != null && directive.endPosition != null) {
            const startOffset = directive.startPosition.index, length = (directive.endPosition.index - directive.startPosition.index), endOffset = startOffset + length;
            directive.sourceContent = this.document.getContentSubstring(startOffset, length);
            directive.offset = {
                start: startOffset,
                end: endOffset,
                length: length
            };
        }
        return directive;
    }
    getComponentOffset() {
        var _a, _b, _c;
        return ((_c = (_b = (_a = this.activeComponent) === null || _a === void 0 ? void 0 : _a.startPosition) === null || _b === void 0 ? void 0 : _b.offset) !== null && _c !== void 0 ? _c : 0) + 3;
    }
    makeDirectiveWithParameters(name, nameStartsOn, nameEndsOn, params) {
        var _a, _b;
        const directive = this.makeDirective(name, nameStartsOn, nameEndsOn), componentOffset = this.getComponentOffset();
        directive.hasDirectiveParameters = true;
        directive.directiveParameters = params.content;
        // Check to see if the directive probably contains JSON params.
        let checkParams = params.content.trim();
        if (checkParams.startsWith('(') && checkParams.endsWith(')')) {
            checkParams = checkParams.substring(1);
            checkParams = checkParams.substring(0, checkParams.length - 1);
            checkParams = checkParams.trim();
            directive.hasJsonParameters = checkParams.startsWith('{') && checkParams.endsWith('}');
        }
        const directiveParamtersStartPosition = this.document.positionFromOffset(params.start + componentOffset, params.start + componentOffset), directiveParametersEndPosition = this.document.positionFromOffset(params.end + componentOffset, params.end + componentOffset);
        directive.startPosition = (_b = (_a = directive.namePosition) === null || _a === void 0 ? void 0 : _a.start) !== null && _b !== void 0 ? _b : null;
        directive.endPosition = directiveParametersEndPosition;
        directive.directiveParametersPosition = {
            start: directiveParamtersStartPosition,
            end: directiveParametersEndPosition
        };
        if (directive.startPosition != null && directive.endPosition != null) {
            const startOffset = directive.startPosition.index, length = (directive.endPosition.index - directive.startPosition.index), endOffset = startOffset + length;
            directive.sourceContent = this.document.getContentSubstring(startOffset, length);
            directive.offset = {
                start: startOffset,
                end: endOffset,
                length: length
            };
        }
        return directive;
    }
    prepare(content) {
        this.content = stringUtilities_1.StringUtilities.normalizeLineEndings(content);
        this.chars = this.content.split('');
        this.inputLen = this.chars.length;
        return this;
    }
    peek(count) {
        return this.chars[count];
    }
    peekRelative(count) {
        return this.peek(this.currentIndex + count);
    }
    scanToEndOfComment(startedOn) {
        const componentOffset = this.getComponentOffset();
        let hasObservedNewLine = false, hasObservedSpace = false, newlineRecoveryIndex = -1, spaceRecoveryIndex = -1;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (this.cur == documentParser_1.DocumentParser.NewLine && !hasObservedNewLine) {
                hasObservedNewLine = true;
                newlineRecoveryIndex = this.currentIndex;
            }
            if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) && !hasObservedSpace) {
                hasObservedSpace = true;
                spaceRecoveryIndex = this.currentIndex;
            }
            if ((this.cur == documentParser_1.DocumentParser.Punctuation_Minus && this.next == documentParser_1.DocumentParser.Punctuation_Minus) || this.next == null) {
                const peekOne = this.peekRelative(2), peekTwo = this.peekRelative(3);
                if ((peekOne == documentParser_1.DocumentParser.RightBrace && peekTwo == documentParser_1.DocumentParser.RightBrace) || this.next == null) {
                    const comment = new nodes_1.BladeCommentNode();
                    comment.startPosition = this.document.positionFromOffset((startedOn - 2) + componentOffset, (startedOn - 2) + componentOffset);
                    comment.endPosition = this.document.positionFromOffset(this.currentIndex + 4 + componentOffset, this.currentIndex + 4 + componentOffset);
                    comment.innerContent = this.chars.slice(startedOn + 2, this.currentIndex).join('');
                    comment.sourceContent = this.chars.slice(startedOn - 2, this.currentIndex + 4).join('');
                    return comment;
                }
                else {
                    if (this.cur != null) {
                        this.currentContent.push(this.cur);
                    }
                    continue;
                }
            }
            if (this.cur == null) {
                break;
            }
            this.currentContent.push(this.cur);
        }
        return null;
    }
    scanToEndOfDirective() {
        const directiveNameStartsOn = this.currentIndex, directiveBrokeForNewline = false;
        let directiveName = '', directiveNameEndsOn = 0;
        let directive = null;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.next == documentParser_1.DocumentParser.Punctuation_Asterisk) {
                (0, skipToEndOfMultilineComment_1.skipToEndOfMultilineComment)(this, true);
                continue;
            }
            if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.next == documentParser_1.DocumentParser.Punctuation_ForwardSlash) {
                (0, skipToEndOfLine_1.skipToEndOfLine)(this, true);
                continue;
            }
            if (this.cur == documentParser_1.DocumentParser.NewLine) {
                directiveNameEndsOn = this.currentIndex;
                directiveName = this.currentContent.join('');
                this.currentContent = [];
                directive = this.makeDirective(directiveName, directiveNameStartsOn, directiveNameEndsOn);
                break;
            }
            else if (this.next == null) {
                this.currentContent.push(this.cur);
                directiveNameEndsOn = this.currentIndex + 1;
                directiveName = this.currentContent.join('');
                this.currentContent = [];
                directive = this.makeDirective(directiveName, directiveNameStartsOn, directiveNameEndsOn);
                break;
            }
            const nextNonWs = (0, nextNonWhitespace_1.nextNonWhitespace)(this);
            if (this.cur != documentParser_1.DocumentParser.LeftParen && nextNonWs.didFind && stringUtilities_1.StringUtilities.ctypePunct(nextNonWs.char)) {
                if (nextNonWs.char != documentParser_1.DocumentParser.LeftParen && nextNonWs.char != documentParser_1.DocumentParser.Punctuation_Minus && nextNonWs.char != '.') {
                    this.currentContent.push(this.cur);
                    directiveNameEndsOn = this.currentIndex + 1;
                    directiveName = this.currentContent.join('');
                    this.currentContent = [];
                    directive = this.makeDirective(directiveName, directiveNameStartsOn, directiveNameEndsOn);
                    break;
                }
            }
            if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
                const nextNonWs = (0, nextNonWhitespace_1.nextNonWhitespace)(this);
                if (nextNonWs.didFind && nextNonWs.char == documentParser_1.DocumentParser.LeftParen) {
                    directiveNameEndsOn = this.currentIndex - 1;
                    directiveName = this.currentContent.join('');
                    this.currentContent = [];
                    this.currentIndex = nextNonWs.index;
                    this.checkCurrentOffsets();
                    const logicGroupResults = (0, scanToEndOfLogicGroup_1.scanToEndOfLogicGroup)(this);
                    directive = this.makeDirectiveWithParameters(directiveName, directiveNameStartsOn, directiveNameEndsOn, logicGroupResults);
                    break;
                }
                else {
                    directiveNameEndsOn = this.currentIndex;
                    directiveName = this.currentContent.join('');
                    this.currentContent = [];
                    directive = this.makeDirective(directiveName, directiveNameStartsOn, directiveNameEndsOn);
                    break;
                }
            }
            else if (this.cur == documentParser_1.DocumentParser.LeftParen) {
                directiveNameEndsOn = this.currentIndex - 1;
                directiveName = this.currentContent.join('');
                this.currentContent = [];
                const logicGroupResults = (0, scanToEndOfLogicGroup_1.scanToEndOfLogicGroup)(this);
                directive = this.makeDirectiveWithParameters(directiveName, directiveNameStartsOn, directiveNameEndsOn, logicGroupResults);
                break;
            }
            if (this.cur == null) {
                break;
            }
            this.currentContent.push(this.cur);
        }
        return directive;
    }
    nextPunctuation() {
        for (let i = this.currentIndex + 1; i < this.inputLen; i++) {
            const char = this.chars[i];
            if (stringUtilities_1.StringUtilities.ctypePunct(char)) {
                return char;
            }
        }
        return null;
    }
    scanToEndOfBladeEcho(startedOn) {
        const componentOffset = this.getComponentOffset(), echoNode = new nodes_1.BladeEchoNode();
        this.currentContent.unshift();
        this.currentContent.unshift();
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (this.cur == documentParser_1.DocumentParser.RightBrace && this.next == documentParser_1.DocumentParser.RightBrace) {
                const echoEnd = this.currentIndex + 1;
                echoNode.startPosition = this.document.positionFromOffset(startedOn + componentOffset, startedOn + componentOffset);
                echoNode.endPosition = this.document.positionFromOffset(echoEnd + componentOffset, echoEnd + componentOffset);
                echoNode.withParser(this.document);
                const startOffset = echoNode.startPosition.index - 5, length = (echoNode.endPosition.index - echoNode.startPosition.index) + 3, endOffset = startOffset + length;
                echoNode.sourceContent = this.content.substr(startOffset, length);
                echoNode.offset = {
                    start: startOffset,
                    end: endOffset,
                    length: length
                };
                echoNode.content = this.currentContent.join('');
                break;
            }
            if (this.cur == null) {
                break;
            }
            this.currentContent.push(this.cur);
        }
        return echoNode;
    }
    parse(node) {
        var _a;
        this.resetState().prepare(node.innerContent);
        this.activeComponent = node;
        const parser = node.getParser();
        let isParsingParameter = false, parameterStartedOn = -1, parameterNameEndedOn = -1, parameterValueStartedOn = -1, terminatorStyle = '"';
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (this.hasFoundName && this.cur == documentParser_1.DocumentParser.LeftBrace && this.next == documentParser_1.DocumentParser.LeftBrace) {
                this.currentIndex += 2;
                const peek = this.peekRelative(0), peekTwo = this.peekRelative(1);
                if (peek == documentParser_1.DocumentParser.Punctuation_Minus && peekTwo == documentParser_1.DocumentParser.Punctuation_Minus) {
                    const comment = this.scanToEndOfComment(this.currentIndex);
                    if (comment != null) {
                        const param = new nodes_1.ParameterNode();
                        param.type = nodes_1.ParameterType.Directive;
                        param.startPosition = comment.startPosition;
                        param.endPosition = comment.endPosition;
                        param.inlineComment = comment;
                        param.type = nodes_1.ParameterType.Comment;
                        node.hasParameters = true;
                        node.parameters.push(param);
                        this.currentContent = [];
                        this.currentIndex += 3;
                        continue;
                    }
                    debugger;
                }
                else {
                    const echoNode = this.scanToEndOfBladeEcho(this.currentIndex);
                    if (echoNode != null) {
                        const param = new nodes_1.ParameterNode();
                        param.type = nodes_1.ParameterType.Directive;
                        param.startPosition = echoNode.startPosition;
                        param.endPosition = echoNode.endPosition;
                        param.inlineEcho = echoNode;
                        param.type = nodes_1.ParameterType.InlineEcho;
                        node.hasParameters = true;
                        node.parameters.push(param);
                        this.currentContent = [];
                        this.currentIndex += 1;
                        continue;
                    }
                }
            }
            if (this.hasFoundName && this.cur == documentParser_1.DocumentParser.AtChar && this.currentContent.length == 0 && this.nextPunctuation() != documentParser_1.DocumentParser.Punctuation_Equals) {
                const directive = this.scanToEndOfDirective();
                if (directive != null) {
                    const param = new nodes_1.ParameterNode();
                    param.type = nodes_1.ParameterType.Directive;
                    param.startPosition = directive.startPosition;
                    param.endPosition = directive.endPosition;
                    param.name = directive.directiveName;
                    param.directive = directive;
                    node.hasParameters = true;
                    node.parameters.push(param);
                    continue;
                }
            }
            if (!this.hasFoundName) {
                if ((stringUtilities_1.StringUtilities.ctypeSpace(this.cur) || this.next == null) && this.hasFoundName == false) {
                    if (this.next == null && !stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
                        this.currentContent.push(this.cur);
                    }
                    this.name = this.currentContent.join('');
                    this.nameEndsOn = this.currentIndex - 1;
                    this.hasFoundName = true;
                    this.currentContent = [];
                    this.parameterContent = this.chars.slice(this.currentIndex).join('');
                    continue;
                }
            }
            else {
                if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) || this.next == null) {
                    if (this.currentContent.length > 0) {
                        const param = new nodes_1.ParameterNode(), componentOffset = this.getComponentOffset();
                        param.type = nodes_1.ParameterType.Attribute;
                        if (this.next == null && !stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
                            this.currentContent.push(this.cur);
                        }
                        param.name = this.currentContent.join('');
                        const startOffset = this.currentIndex + componentOffset - param.name.length;
                        param.startPosition = this.document.positionFromCursor(startOffset, startOffset);
                        param.endPosition = this.document.positionFromCursor(this.currentIndex + componentOffset, this.currentIndex + componentOffset);
                        param.namePosition = {
                            start: param.startPosition,
                            end: param.endPosition
                        };
                        node.parameters.push(param);
                        node.hasParameters = true;
                        this.currentContent = [];
                        continue;
                    }
                    continue;
                }
                else {
                    if (!isParsingParameter) {
                        isParsingParameter = true;
                        parameterStartedOn = this.currentIndex;
                    }
                }
                if (this.cur == documentParser_1.DocumentParser.Punctuation_Equals && (0, isStartOfString_1.isStartOfString)(this.next)) {
                    terminatorStyle = this.next;
                    parameterNameEndedOn = this.currentIndex - 1;
                    this.currentIndex += 1;
                    this.checkCurrentOffsets();
                    parameterValueStartedOn = this.currentIndex;
                    const paramValue = (0, skipToEndOfString_1.skipToEndOfStringTraced)(this), param = new nodes_1.ParameterNode();
                    param.withParser(parser);
                    param.name = this.currentContent.join('');
                    param.value = paramValue.value;
                    const nameStartOffset = node.relativeOffset(parameterStartedOn + 3), nameEndOffset = node.relativeOffset(parameterNameEndedOn + 3), valueStartOffset = node.relativeOffset(parameterValueStartedOn + 3), valueEndOffset = node.relativeOffset(paramValue.endedOn + 3);
                    param.namePosition = {
                        start: parser.positionFromOffset(nameStartOffset, nameStartOffset),
                        end: parser.positionFromOffset(nameEndOffset, nameEndOffset)
                    };
                    param.valuePosition = {
                        start: parser.positionFromOffset(valueStartOffset, valueStartOffset),
                        end: parser.positionFromOffset(valueEndOffset, valueEndOffset)
                    };
                    param.terminatorStyle = terminatorStyle;
                    param.wrappedValue = terminatorStyle + param.value + terminatorStyle;
                    param.content = param.name + '=' + param.wrappedValue;
                    param.realName = param.name;
                    if (param.realName.startsWith(':')) {
                        param.isExpression = true;
                        param.realName = param.realName.substring(1);
                        if (param.realName.startsWith(':')) {
                            param.isExpression = false;
                            param.realName = param.realName.substring(1);
                            param.isEscapedExpression = true;
                        }
                    }
                    node.hasParameters = true;
                    node.parameters.push(param);
                    this.currentContent = [];
                    isParsingParameter = false;
                    parameterStartedOn = -1;
                    parameterNameEndedOn = -1;
                    parameterValueStartedOn = -1;
                    terminatorStyle = '"';
                    continue;
                }
            }
            this.currentContent.push(this.cur);
        }
        node.name = this.makeComponentName(node);
        node.parameterContent = this.parameterContent;
        if (node.hasParameters) {
            for (let i = 0; i < node.parameters.length; i++) {
                const thisParam = node.parameters[i];
                if (thisParam.type == nodes_1.ParameterType.InlineEcho) {
                    const content = (_a = thisParam.inlineEcho) === null || _a === void 0 ? void 0 : _a.content.trim();
                    if (content.toLowerCase().startsWith('$attributes')) {
                        node.receivesAttributeBag = true;
                        break;
                    }
                }
            }
        }
    }
    makeComponentName(component) {
        const parser = component.getParser(), componentName = new nodes_1.ComponentNameNode(), nameStartOffset = component.relativeOffset(this.nameStartsOn + 3), nameEndsOffset = component.relativeOffset(this.nameEndsOn + 3);
        componentName.withParser(parser);
        componentName.name = this.name;
        if (component.isClosingTag) {
            componentName.name = component.innerContent.trim().substring(1);
        }
        if (componentName.name.includes(':')) {
            const parts = componentName.name.split(':');
            componentName.name = parts[0];
            componentName.inlineName = parts.slice(1).join(':');
        }
        componentName.startPosition = parser.positionFromOffset(nameStartOffset, nameStartOffset);
        componentName.endPosition = parser.positionFromOffset(nameEndsOffset, nameEndsOffset);
        return componentName;
    }
}
exports.ComponentParser = ComponentParser;
//# sourceMappingURL=componentParser.js.map