"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoidHtmlTagsManager = void 0;
const bladeDocument_1 = require("../../document/bladeDocument");
const fragmentsParser_1 = require("../../parser/fragmentsParser");
const stringUtilities_1 = require("../../utilities/stringUtilities");
class VoidHtmlTagsManager {
    static adjustInput(content) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const tmpDoc = bladeDocument_1.BladeDocument.fromText(content), fragmentsParser = new fragmentsParser_1.FragmentsParser(), tmpSlug = 'Void' + stringUtilities_1.StringUtilities.makeSlug(15);
        fragmentsParser.setIndexRanges(tmpDoc.getParser().getNodeIndexRanges());
        let hasAnyCustomVoidElements = false;
        const fragments = fragmentsParser.parse(content), voidFragments = [], discoveredCustomVoidElements = [];
        fragments.forEach((fragment) => {
            const checkName = fragment.name.toLowerCase();
            if (checkName != fragment.name && VoidHtmlTagsManager.voidElementNames.includes(checkName)) {
                hasAnyCustomVoidElements = true;
                discoveredCustomVoidElements.push(checkName);
                voidFragments.push(fragment);
            }
        });
        if (!hasAnyCustomVoidElements) {
            return content;
        }
        let newText = '', lastEnd = 0;
        for (let i = 0; i < voidFragments.length; i++) {
            const fragment = voidFragments[i], checkName = fragment.name.toLowerCase(), safeName = tmpSlug + fragment.name;
            if (!VoidHtmlTagsManager.voidTagMapping.has(safeName)) {
                VoidHtmlTagsManager.voidTagMapping.set(safeName, fragment.name);
            }
            let fragmentOffset = 1;
            if (fragment.isClosingFragment) {
                fragmentOffset = 2;
            }
            if (i == 0) {
                const part = content.substring(0, ((_b = (_a = fragment.startPosition) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0) + fragmentOffset);
                newText += part;
                newText += safeName;
                lastEnd = ((_d = (_c = fragment.startPosition) === null || _c === void 0 ? void 0 : _c.offset) !== null && _d !== void 0 ? _d : 0) + fragmentOffset + checkName.length;
                if (voidFragments.length == 1) {
                    newText += content.substring(lastEnd);
                }
                continue;
            }
            else if (i == voidFragments.length - 1) {
                if (voidFragments.length == 1) {
                    const part = content.substring(0, ((_f = (_e = fragment.startPosition) === null || _e === void 0 ? void 0 : _e.offset) !== null && _f !== void 0 ? _f : 0) + fragmentOffset);
                    newText += part;
                }
                else {
                    const part = content.substring(lastEnd, ((_h = (_g = fragment.startPosition) === null || _g === void 0 ? void 0 : _g.offset) !== null && _h !== void 0 ? _h : 0) + fragmentOffset);
                    newText += part;
                }
                newText += safeName;
                lastEnd = ((_k = (_j = fragment.startPosition) === null || _j === void 0 ? void 0 : _j.offset) !== null && _k !== void 0 ? _k : 0) + fragmentOffset + checkName.length;
                newText += content.substring(lastEnd);
                break;
            }
            else {
                const part = content.substring(lastEnd, ((_m = (_l = fragment.startPosition) === null || _l === void 0 ? void 0 : _l.offset) !== null && _m !== void 0 ? _m : 0) + fragmentOffset);
                newText += part;
                newText += safeName;
                lastEnd = ((_p = (_o = fragment.startPosition) === null || _o === void 0 ? void 0 : _o.offset) !== null && _p !== void 0 ? _p : 0) + fragmentOffset + checkName.length;
                continue;
            }
        }
        return newText;
    }
}
exports.VoidHtmlTagsManager = VoidHtmlTagsManager;
VoidHtmlTagsManager.voidElementNames = [
    'area',
    'base',
    'br',
    'col',
    'command',
    'embed',
    'hr',
    'img',
    'input',
    'keygen',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr'
];
VoidHtmlTagsManager.voidTagMapping = new Map();
//# sourceMappingURL=voidHtmlTagsManager.js.map