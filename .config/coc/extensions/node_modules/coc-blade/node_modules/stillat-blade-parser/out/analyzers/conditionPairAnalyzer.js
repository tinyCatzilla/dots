"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConditionPairAnalyzer = void 0;
const bladeError_1 = require("../errors/bladeError");
const bladeErrorCodes_1 = require("../errors/bladeErrorCodes");
const nodes_1 = require("../nodes/nodes");
const bladeKeywords_1 = require("../parser/bladeKeywords");
class ConditionPairAnalyzer {
    static isConditionalStructure(node) {
        if (node instanceof nodes_1.DirectiveNode == false) {
            return false;
        }
        const directive = node, name = directive.name;
        if (name == bladeKeywords_1.BladeKeywords.If || name == bladeKeywords_1.BladeKeywords.ElseIf || name == bladeKeywords_1.BladeKeywords.Else) {
            return true;
        }
        return false;
    }
    static requiresClose(node) {
        const name = node.name;
        if (name == bladeKeywords_1.BladeKeywords.ElseIf || name == bladeKeywords_1.BladeKeywords.Else) {
            if (node.isClosedBy != null) {
                return false;
            }
            return true;
        }
        if (node.isClosingDirective) {
            return false;
        }
        if (node.isClosedBy != null) {
            return false;
        }
        return true;
    }
    /**
     * Returns a list of valid closing node names for the provided node.
     *
     * @param current The current node's name.
     * @returns
     */
    static getValidClosingPairs(current) {
        if (current == bladeKeywords_1.BladeKeywords.If || current == bladeKeywords_1.BladeKeywords.ElseIf) {
            return ConditionPairAnalyzer.conditionClosingPairs;
        }
        return [];
    }
    /**
    * Descends through the nodes to find the closest logical
    * closing node for each opening conditional node type.
    *
    * @param nodes  The nodes to analyze.
    * @param node The primary node.
    * @param index  The primary node starting index.
    */
    static findClosestStructurePair(nodes, node, index) {
        const stack = [], nodeLen = nodes.length, conditionCloseIndex = new Map();
        stack.push({
            node: node,
            index: index
        });
        for (let i = 0; i < nodeLen; i += 1) {
            const node = nodes[i];
            if (node instanceof nodes_1.DirectiveNode) {
                const name = node.name;
                if (node.isClosingDirective && name == bladeKeywords_1.BladeKeywords.If) {
                    conditionCloseIndex.set(i, i);
                    continue;
                }
                else {
                    if (name == bladeKeywords_1.BladeKeywords.ElseIf || name == bladeKeywords_1.BladeKeywords.Else) {
                        conditionCloseIndex.set(i, i);
                        continue;
                    }
                }
            }
        }
        while (stack.length > 0) {
            const curItem = stack.pop();
            if (curItem == null) {
                continue;
            }
            if (curItem.node._conditionParserAbandonPairing) {
                break;
            }
            const curNode = curItem.node, thisValidPairs = ConditionPairAnalyzer.getValidClosingPairs(curNode.name);
            let curIndex = curItem.index, doSkipValidation = false;
            for (let i = curIndex; i < nodeLen; i++) {
                const subNode = nodes[i];
                if (subNode instanceof nodes_1.DirectiveNode) {
                    if (ConditionPairAnalyzer.isConditionalStructure(subNode)) {
                        if (ConditionPairAnalyzer.requiresClose(subNode)) {
                            if (i == nodeLen - 1) {
                                doSkipValidation = false;
                                break;
                            }
                            stack.push(curItem);
                            stack.push({
                                node: subNode,
                                index: i + 1
                            });
                            doSkipValidation = true;
                            break;
                        }
                        if (curNode.isClosedBy != null) {
                            continue;
                        }
                        const subNodeName = subNode.name;
                        let canClose = false;
                        if (subNode.ref == 0 && ((subNode.isClosingDirective && subNodeName == bladeKeywords_1.BladeKeywords.If) ||
                            thisValidPairs.includes(subNodeName))) {
                            canClose = true;
                        }
                        if (subNode.refId == curNode.refId) {
                            canClose = false;
                        }
                        if (canClose) {
                            conditionCloseIndex.delete(i);
                            curNode.isClosedBy = subNode;
                            subNode.isOpenedBy = curNode;
                            subNode.ref += 1;
                            doSkipValidation = true;
                            break;
                        }
                    }
                }
            }
            if (!doSkipValidation) {
                if (curNode instanceof nodes_1.DirectiveNode) {
                    const nodeName = curNode.name;
                    if ((nodeName == bladeKeywords_1.BladeKeywords.ElseIf || nodeName == bladeKeywords_1.BladeKeywords.Else) && curNode.isOpenedBy == null) {
                        curNode.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_CONDITION, curNode, 'Unpaired condition control structure'));
                        curNode._conditionParserAbandonPairing = true;
                    }
                    if (curNode.isClosedBy == null && ConditionPairAnalyzer.requiresClose(curNode)) {
                        curNode.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_CONDITION, curNode, 'Unpaired condition control structure'));
                        curNode._conditionParserAbandonPairing = true;
                    }
                }
            }
        }
    }
    static pairConditionals(nodes) {
        for (let i = 0; i < nodes.length; i += 1) {
            const node = nodes[i];
            if (node instanceof nodes_1.DirectiveNode && ConditionPairAnalyzer.isConditionalStructure(node)) {
                if (ConditionPairAnalyzer.requiresClose(node)) {
                    ConditionPairAnalyzer.findClosestStructurePair(nodes, node, i + 1);
                }
            }
        }
        nodes.forEach((node) => {
            if (node instanceof nodes_1.DirectiveNode && ConditionPairAnalyzer.isConditionalStructure(node)) {
                const name = node.name;
                if ((name == bladeKeywords_1.BladeKeywords.ElseIf || name == bladeKeywords_1.BladeKeywords.Else) && node.isOpenedBy == null) {
                    node.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_CONDITION, node, 'Unpaired condition control structure'));
                    node._conditionParserAbandonPairing = true;
                    return;
                }
                if (node.isClosedBy == null && ConditionPairAnalyzer.requiresClose(node)) {
                    node.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_CONDITION, node, 'Unpaired condition control structure'));
                    node._conditionParserAbandonPairing = true;
                    return;
                }
            }
        });
        return nodes;
    }
}
exports.ConditionPairAnalyzer = ConditionPairAnalyzer;
/**
 * A list of valid closing names for common conditional node types.
 */
ConditionPairAnalyzer.conditionClosingPairs = ['elseif', 'else'];
//# sourceMappingURL=conditionPairAnalyzer.js.map