"use strict";
// ctype regexes adapted from: https://github.com/locutusjs/locutus/blob/master/src/php/strings/setlocale.js
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringUtilities = void 0;
const isNumeric_1 = require("./isNumeric");
class StringUtilities {
    static normalizeLineEndings(string, to = "\n") {
        return string.replace(/\r?\n/g, to);
    }
    static split(text) {
        return text.split('');
    }
    static substring(text, start, length) {
        return text.substr(start, length);
    }
    static ctypeSpace(char) {
        return (char === null || char === void 0 ? void 0 : char.search(/^[\f\n\r\t\v ]+$/g)) !== -1;
    }
    static ctypeAlpha(char) {
        return (char === null || char === void 0 ? void 0 : char.search(/^[A-Za-z]+$/g)) !== -1;
    }
    static ctypeDigit(char) {
        return (char === null || char === void 0 ? void 0 : char.search(/^[\d]+$/g)) !== -1;
    }
    static ctypePunct(char) {
        return (char === null || char === void 0 ? void 0 : char.search(/^[\u0021-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007E]+$/g)) !== -1;
    }
    static trimLeft(value, charList = "\\s") {
        return value.replace(new RegExp("^[" + charList + "]+"), '');
    }
    static trimRight(value, charList = "\\s") {
        return value.replace(new RegExp("[" + charList + "]+$"), '');
    }
    static isNumeric(string) {
        return (0, isNumeric_1.is_numeric)(string);
    }
    static substringCount(haystack, needle) {
        const subStr = needle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        return (haystack.match(new RegExp(subStr, 'gi')) || []).length;
    }
    static lastWord(value) {
        const chars = value.split(''), wordChars = [];
        for (let i = chars.length; i >= 0; i--) {
            if (chars[i] == ' ') {
                break;
            }
            wordChars.push(chars[i]);
        }
        return wordChars.reverse().join();
    }
    static breakByNewLine(value) {
        return value.replace(/(\r\n|\n|\r)/gm, "\n").split("\n");
    }
    static removeEmptyNewLines(value) {
        const newLines = [], lines = StringUtilities.breakByNewLine(StringUtilities.normalizeLineEndings(value));
        lines.forEach((line) => {
            if (line.trim().length > 0) {
                newLines.push(line);
            }
        });
        return newLines.join("\n");
    }
    static replaceAllInString(value, oldString, newString) {
        return value.replace(new RegExp(oldString, 'g'), newString);
    }
    static getTrimmedMatch(expression, value, index) {
        const match = expression.exec(value);
        if (match == null || match.length < index) {
            return null;
        }
        const candidate = match[index].trim();
        if (candidate.length == 0) {
            return null;
        }
        return candidate;
    }
    static assertMatchIs(expression, value, index, testValue) {
        const candidate = StringUtilities.getTrimmedMatch(expression, value, index);
        if (candidate != null && candidate == testValue) {
            return true;
        }
        return false;
    }
    static truncateString(str, num) {
        if (str.length <= num) {
            return str;
        }
        return str.slice(0, num) + '...';
    }
    static unwrapString(value) {
        const returnValue = value.substring(1);
        return returnValue.substring(0, returnValue.length - 1);
    }
    static getLastLine(content) {
        const lines = StringUtilities.breakByNewLine(content);
        if (lines.length == 0) {
            return '';
        }
        return lines[lines.length - 1];
    }
    static getFirstLine(content) {
        const lines = StringUtilities.breakByNewLine(content);
        if (lines.length == 0) {
            return '';
        }
        return lines[0];
    }
    static collapse(content) {
        const lines = StringUtilities.breakByNewLine(content);
        let newContent = '';
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (i + 1 < lines.length) {
                const nextLine = lines[i + 1].trim();
                if (nextLine.length > 0 && StringUtilities.ctypePunct(nextLine[0])) {
                    const char = nextLine[0];
                    newContent += line;
                    if (char == '?' || char == ':' || char == '&') {
                        newContent += ' ';
                    }
                }
                else {
                    newContent += line + ' ';
                }
            }
            else {
                newContent += line;
            }
        }
        return newContent.trimRight();
        ;
    }
    static makeSlug(length) {
        if (length <= 2) {
            length = 7;
        }
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', charactersLength = characters.length;
        for (let i = 0; i < length - 1; i++) {
            result += characters.charAt(Math.floor(Math.random() *
                charactersLength));
        }
        return 'B' + result + 'B';
    }
    static replaceWithFillerExceptNewlines(input) {
        const result = input.replace(/./g, (match) => {
            if (match === '\n') {
                return match;
            }
            return 'P';
        });
        return result;
    }
    static safeReplaceAllInString(originalString, searchValue, replaceValue) {
        const regex = new RegExp(searchValue, 'g'), replacedString = originalString.split(regex).join(replaceValue);
        return replacedString;
    }
    static safeReplace(originalString, searchValue, replaceValue) {
        const replacedString = originalString.split(searchValue).join(replaceValue);
        return replacedString;
    }
}
exports.StringUtilities = StringUtilities;
//# sourceMappingURL=stringUtilities.js.map