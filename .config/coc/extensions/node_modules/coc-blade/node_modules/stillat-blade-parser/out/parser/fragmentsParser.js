"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FragmentsParser = void 0;
const bladeDocument_1 = require("../document/bladeDocument");
const nodes_1 = require("../nodes/nodes");
const position_1 = require("../nodes/position");
const stringUtilities_1 = require("../utilities/stringUtilities");
const documentParser_1 = require("./documentParser");
const unsafe_1 = require("./excludeAttributes/unsafe");
const isStartOfString_1 = require("./scanners/isStartOfString");
const skipToEndOfLine_1 = require("./scanners/skipToEndOfLine");
const skipToEndOfMultilineComment_1 = require("./scanners/skipToEndOfMultilineComment");
const skipToEndOfString_1 = require("./scanners/skipToEndOfString");
class FragmentsParser {
    constructor() {
        this.content = '';
        this.nodeIndex = [];
        this.nodeIndexSkipMap = new Map();
        this.fragmentStartIndex = [];
        this.charLen = 0;
        this.documentOffsets = new Map();
        this.inputLen = 0;
        this.seedOffset = 0;
        this.shiftLine = 0;
        this.chars = [];
        this.currentIndex = 0;
        this.lastDocumentOffsetKey = null;
        this.cur = null;
        this.next = null;
        this.prev = null;
        this.chunkSize = 5;
        this.currentChunkOffset = 0;
        this.fragments = [];
        this.isScript = false;
        this.fragmentOpeningIndex = new Map();
        this.indexedFragments = new Map();
        this.embeddedIndexedFragments = new Map();
        this.extractAttributePositions = false;
        this.extractAttributeNames = [];
        this.excludeAttributeNames = [];
        this.extractedAttributes = [];
        this.lastFragmentEnded = -1;
        this.parsingTracedStringHitEof = false;
    }
    advance(count) {
        for (let i = 0; i < count; i++) {
            this.currentIndex++;
            this.checkCurrentOffsets();
        }
    }
    getParsingTracedStringHitEof() {
        return this.parsingTracedStringHitEof;
    }
    encounteredFailure() {
        return;
    }
    updateIndex(index) {
        this.currentIndex = index;
    }
    inputLength() {
        return this.inputLen;
    }
    incrementIndex() {
        this.currentIndex += 1;
    }
    getCurrentIndex() {
        return this.currentIndex;
    }
    getCurrent() {
        return this.cur;
    }
    getNext() {
        return this.next;
    }
    getPrev() {
        return this.prev;
    }
    pushChar(value) {
        return;
    }
    getChar(index) {
        return this.chars[index];
    }
    getSeedOffset() {
        return this.seedOffset;
    }
    setDocumentOffsets(offsets, lastOffsetIndex) {
        this.documentOffsets = offsets;
        this.lastDocumentOffsetKey = lastOffsetIndex;
        return this;
    }
    getClosingFragmentAfter(fragment) {
        const lowerName = fragment.name.toLowerCase();
        for (let i = 0; i < this.fragments.length; i++) {
            const thisFragment = this.fragments[i];
            if (thisFragment.isClosingFragment && !thisFragment.isSelfClosing && thisFragment.name.toLowerCase() == lowerName && thisFragment.index > fragment.index) {
                return thisFragment;
            }
        }
        return null;
    }
    setExcludeAttributes(excludeAttributes) {
        this.excludeAttributeNames = excludeAttributes;
    }
    setExtractAttributes(extractAttributes) {
        this.extractAttributePositions = extractAttributes;
    }
    setExtractAttributeNames(attributeNames) {
        this.extractAttributeNames = attributeNames;
    }
    getContentSubstring(from, length) {
        return this.content.substr(from, length);
    }
    getExtractedAttributes() {
        return this.extractedAttributes;
    }
    resetState() {
        this.fragments = [];
        this.inputLen = 0;
        this.fragmentStartIndex = [];
        this.fragmentOpeningIndex.clear();
        return this;
    }
    resetIntermediateState() {
        this.chars = [];
        this.charLen = 0;
        this.currentIndex = 0;
        this.seedOffset = 0;
        this.cur = null;
        this.next = null;
        this.prev = null;
    }
    positionFromOffset(offset, index, isRelativeOffset = false) {
        let lineToUse = 0, charToUse = 0;
        if (!this.documentOffsets.has(offset)) {
            if (this.documentOffsets.size == 0) {
                lineToUse = 1;
                charToUse = offset + 1;
            }
            else {
                let nearestOffset = null, nearestOffsetIndex = null, lastOffset = null, lastOffsetIndex = null;
                for (const documentOffset of this.documentOffsets.keys()) {
                    if (documentOffset >= offset) {
                        if (lastOffsetIndex != null && offset > lastOffsetIndex) {
                            nearestOffset = lastOffset;
                            nearestOffsetIndex = lastOffsetIndex;
                        }
                        else {
                            nearestOffset = this.documentOffsets.get(documentOffset);
                            nearestOffsetIndex = documentOffset;
                        }
                        break;
                    }
                    lastOffset = this.documentOffsets.get(documentOffset);
                    lastOffsetIndex = documentOffset;
                }
                if (nearestOffset == null) {
                    nearestOffset = lastOffset;
                    nearestOffsetIndex = lastOffsetIndex;
                }
                if (nearestOffset != null) {
                    if (isRelativeOffset) {
                        const tChar = offset - (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0);
                        charToUse = tChar;
                        lineToUse = nearestOffset.line;
                        if (offset <= (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0)) {
                            lineToUse = nearestOffset.line;
                            charToUse = offset + 1;
                        }
                        else {
                            lineToUse = nearestOffset.line + 1;
                        }
                    }
                    else {
                        const tChar = offset - (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0);
                        charToUse = tChar;
                        lineToUse = nearestOffset.line;
                        if (offset <= (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0)) {
                            lineToUse = nearestOffset.line;
                            charToUse = offset + 1;
                        }
                        else {
                            lineToUse = nearestOffset.line + 1;
                        }
                    }
                }
                else {
                    if (this.lastDocumentOffsetKey != null) {
                        const lastOffset = this.documentOffsets.get(this.lastDocumentOffsetKey);
                        lineToUse = lastOffset.line + 1;
                        charToUse = offset + this.lastDocumentOffsetKey;
                    }
                }
            }
        }
        else {
            const offsetDetails = this.documentOffsets.get(offset);
            lineToUse = offsetDetails.line;
            charToUse = offsetDetails.char;
        }
        const position = new position_1.Position();
        position.index = index;
        position.offset = offset;
        position.line = lineToUse + this.shiftLine;
        position.char = charToUse;
        return position;
    }
    getFragments() {
        return this.fragments;
    }
    getFragmentsBetween(startIndex, endIndex) {
        const returnFragments = [];
        this.fragments.forEach((fragment) => {
            var _a, _b, _c, _d;
            const start = (_b = (_a = fragment.startPosition) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : 0, end = (_d = (_c = fragment.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0;
            if (start > startIndex && end < endIndex) {
                returnFragments.push(fragment);
            }
        });
        return returnFragments;
    }
    getFragmentContaining(position) {
        var _a, _b, _c, _d;
        for (let i = 0; i < this.fragments.length; i++) {
            const thisFragment = this.fragments[i];
            if (((_b = (_a = thisFragment.startPosition) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : 0) < position.index && ((_d = (_c = thisFragment.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0) > position.index) {
                return thisFragment;
            }
        }
        return null;
    }
    checkCurrentOffsets() {
        if (this.currentIndex > this.chars.length) {
            this.cur = null;
            this.prev = null;
            this.next = null;
            return;
        }
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (this.currentIndex > 0) {
            this.prev = this.chars[this.currentIndex - 1];
        }
        if ((this.currentIndex + 1) < this.inputLen) {
            let doPeek = true;
            if (this.currentIndex == this.charLen - 1) {
                const nextChunk = stringUtilities_1.StringUtilities.split(stringUtilities_1.StringUtilities.substring(this.content, this.currentChunkOffset + this.chunkSize, this.chunkSize));
                this.currentChunkOffset += this.chunkSize;
                if (this.currentChunkOffset == this.inputLen) {
                    doPeek = false;
                }
                nextChunk.forEach((nextChar) => {
                    this.chars.push(nextChar);
                    this.charLen += 1;
                });
            }
            if (doPeek && (this.currentIndex + 1) < this.chars.length) {
                this.next = this.chars[this.currentIndex + 1];
            }
        }
    }
    processInputText(input) {
        this.content = input;
        this.inputLen = this.content.length;
        const fragmentCandidates = [...this.content.matchAll(/(<(?!\?[php|\?=]))/gm)], newCandidates = [];
        fragmentCandidates.forEach((candidate) => {
            var _a;
            const candidateIndex = (_a = candidate.index) !== null && _a !== void 0 ? _a : 0;
            for (let i = 0; i < this.nodeIndex.length; i++) {
                const thisIndex = this.nodeIndex[i];
                if (candidateIndex >= thisIndex.start && candidateIndex <= thisIndex.end) {
                    return;
                }
            }
            const sanityCheck = this.fetchAt(candidateIndex, 2);
            if (sanityCheck == '<=' || sanityCheck == '<>') {
                return;
            }
            newCandidates.push(candidateIndex);
        });
        this.fragmentStartIndex = newCandidates;
    }
    setIndexRanges(index) {
        this.nodeIndex = index;
        this.nodeIndex.forEach((item) => {
            this.nodeIndexSkipMap.set(item.start, item.end - item.start);
        });
        return this;
    }
    fetchAt(start, length) {
        return this.content.substr(start, length);
    }
    getEmbeddedDocumentStructures() {
        const structures = [];
        this.getEmbeddedFragments().forEach((fragment) => {
            if (!fragment.isClosingFragment && !fragment.isSelfClosing) {
                const close = this.getClosingFragmentAfter(fragment);
                if (close != null) {
                    structures.push({
                        start: fragment,
                        end: close
                    });
                }
            }
        });
        return structures;
    }
    getFragmentsContainingStructures() {
        const structures = [];
        this.fragments.forEach((fragment) => {
            if (!fragment.isClosingFragment && !fragment.isSelfClosing && fragment.containsStructures) {
                const close = this.getClosingFragmentAfter(fragment);
                if (close != null) {
                    structures.push({
                        start: fragment,
                        end: close
                    });
                }
            }
        });
        return structures;
    }
    parse(text) {
        this.resetState().processInputText(text);
        const indexCount = this.fragmentStartIndex.length;
        if (indexCount == 0) {
            return [];
        }
        for (let i = 0; i < this.fragmentStartIndex.length; i++) {
            const offset = this.fragmentStartIndex[i];
            this.resetIntermediateState();
            if (offset < this.lastFragmentEnded) {
                continue;
            }
            this.seedOffset = offset;
            this.currentChunkOffset = offset;
            this.parseIntermediateText();
            if (this.isScript) {
                let didFind = false;
                for (let j = i + 1; j < this.fragmentStartIndex.length; j++) {
                    const checkIndex = this.fragmentStartIndex[j], thisChunk = this.fetchAt(checkIndex, 8).toLowerCase();
                    if (thisChunk == '</script') {
                        i = j - 1;
                        this.isScript = false;
                        didFind = true;
                        break;
                    }
                }
                if (!didFind) {
                    // Break if we get to this point since the script is not closed.
                    break;
                }
            }
        }
        let fragmentIndex = 0, embeddedIndex = 0;
        this.fragments.forEach((fragment) => {
            const lowerName = fragment.name.toLowerCase();
            if (lowerName == 'script' || lowerName == 'style') {
                fragment.embeddedIndex = embeddedIndex;
                this.embeddedIndexedFragments.set(embeddedIndex, fragment);
                embeddedIndex += 1;
            }
            fragment.index = fragmentIndex;
            this.indexedFragments.set(fragmentIndex, fragment);
            fragmentIndex += 1;
        });
        return this.fragments;
    }
    getFragment(index) {
        return this.indexedFragments.get(index);
    }
    getEmbeddedFragment(index) {
        return this.embeddedIndexedFragments.get(index);
    }
    getEmbeddedFragments() {
        const fragments = [];
        this.embeddedIndexedFragments.forEach((fragment) => {
            fragments.push(fragment);
        });
        return fragments;
    }
    hasFragments() {
        return this.fragments.length > 0;
    }
    getCheckAttributeName(attributeName) {
        const dotIndex = attributeName.indexOf('.');
        const colonIndex = attributeName.indexOf(':');
        if (dotIndex !== -1 && (colonIndex === -1 || dotIndex < colonIndex)) {
            return attributeName.substring(0, dotIndex);
        }
        else if (colonIndex !== -1 && (dotIndex === -1 || colonIndex < dotIndex)) {
            return attributeName.substring(0, colonIndex);
        }
        return attributeName;
    }
    shouldSkip(attributeName) {
        const name = this.getCheckAttributeName(attributeName).toLowerCase();
        if (unsafe_1.UnsafeJsAttributes.includes(name)) {
            return true;
        }
        return false;
    }
    skipToEndOfPhp() {
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
                (0, skipToEndOfString_1.skipToEndOfString)(this);
            }
            if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.next == documentParser_1.DocumentParser.Punctuation_ForwardSlash) {
                (0, skipToEndOfLine_1.skipToEndOfLine)(this, true);
                continue;
            }
            if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.next == documentParser_1.DocumentParser.Punctuation_Asterisk) {
                (0, skipToEndOfMultilineComment_1.skipToEndOfMultilineComment)(this, true);
                continue;
            }
            if ((this.cur == documentParser_1.DocumentParser.Punctuation_QuestionMark && this.next == documentParser_1.DocumentParser.Punctuation_GreaterThan) || this.next == null) {
                break;
            }
        }
    }
    scanBackToName(startedOn) {
        const chars = [];
        for (let i = startedOn; i > 0; i--) {
            const char = this.chars[i];
            if (stringUtilities_1.StringUtilities.ctypeSpace(char)) {
                break;
            }
            chars.push(char);
        }
        return chars.reverse().join('');
    }
    shouldExtract(candidate) {
        for (let i = 0; i < this.excludeAttributeNames.length; i++) {
            if (new RegExp(this.excludeAttributeNames[i]).test(candidate)) {
                return false;
            }
        }
        if (this.extractAttributeNames.length > 0) {
            for (let i = 0; i < this.extractAttributeNames.length; i++) {
                if (new RegExp(this.extractAttributeNames[i]).test(candidate)) {
                    return true;
                }
            }
            return false;
        }
        return true;
    }
    parseIntermediateText() {
        this.chars = this.content.substr(this.currentChunkOffset, this.chunkSize).split('');
        this.charLen = this.chars.length;
        const fragmentStartedAt = this.currentIndex, potentialParameterRanges = [], nameChars = [];
        let hasFoundName = false, isClosingFragment = false, dynamicAttributeNameOverride = null;
        let justSkippedPhp = false;
        for (this.currentIndex = 0; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
                hasFoundName = true;
            }
            if (!(0, isStartOfString_1.isStartOfString)(this.cur) && this.next == documentParser_1.DocumentParser.Punctuation_LessThan) {
                let shift = 1;
                if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash) {
                    shift = 2;
                }
                const curFetch = this.fetchAt(this.currentChunkOffset + shift, 5);
                if (curFetch.toLowerCase() == '<?php' || curFetch.startsWith('<?=')) {
                    this.skipToEndOfPhp();
                    justSkippedPhp = true;
                    continue;
                }
            }
            if (this.currentIndex > 0 && this.cur == documentParser_1.DocumentParser.Punctuation_LessThan) {
                break;
            }
            if (this.next == null && this.cur != documentParser_1.DocumentParser.Punctuation_GreaterThan) {
                break;
            }
            if (!hasFoundName && this.cur == documentParser_1.DocumentParser.Punctuation_LessThan && this.next == documentParser_1.DocumentParser.Punctuation_ForwardSlash) {
                isClosingFragment = true;
            }
            if (!hasFoundName && this.cur != documentParser_1.DocumentParser.Punctuation_LessThan &&
                this.cur != documentParser_1.DocumentParser.Punctuation_ForwardSlash &&
                this.cur != documentParser_1.DocumentParser.Punctuation_GreaterThan) {
                nameChars.push(this.cur);
            }
            if (hasFoundName && this.cur == '@') {
                const offsetIndex = this.currentIndex + this.seedOffset + 1;
                if (this.nodeIndexSkipMap.has(offsetIndex)) {
                    const dynamicLen = this.nodeIndexSkipMap.get(offsetIndex);
                    this.advance(dynamicLen);
                    continue;
                }
            }
            if (hasFoundName && this.cur == '{') {
                const offsetIndex = this.currentIndex + this.seedOffset;
                if (this.nodeIndexSkipMap.has(offsetIndex)) {
                    const dynamicLen = this.nodeIndexSkipMap.get(offsetIndex), dynamciAttributeNameCheck = this.fetchAt(offsetIndex, dynamicLen + 3);
                    if (dynamciAttributeNameCheck.endsWith('"') || dynamciAttributeNameCheck.endsWith("'")) {
                        const attributePrefix = this.scanBackToName(this.currentIndex - 1);
                        if (this.shouldExtract(attributePrefix)) {
                            dynamicAttributeNameOverride = attributePrefix + dynamciAttributeNameCheck.substring(0, dynamciAttributeNameCheck.length - 2);
                        }
                    }
                    this.advance(dynamicLen);
                    continue;
                }
            }
            if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
                const stringStartedOn = this.currentIndex;
                this.skipToEndOfStringWithIndex();
                const fragmentParameter = new nodes_1.FragmentParameterNode();
                fragmentParameter.startPosition = this.positionFromOffset(stringStartedOn + this.seedOffset, stringStartedOn + this.seedOffset);
                fragmentParameter.endPosition = this.positionFromOffset(this.currentIndex + this.seedOffset, this.currentIndex + this.seedOffset);
                potentialParameterRanges.push(fragmentParameter);
                if (this.extractAttributePositions == true) {
                    let potentialName = this.scanBackToName(stringStartedOn - 2);
                    if (dynamicAttributeNameOverride != null) {
                        potentialName = dynamicAttributeNameOverride;
                    }
                    if (this.shouldExtract(potentialName)) {
                        const attributeContent = this.getContentSubstring(fragmentParameter.startPosition.offset, fragmentParameter.endPosition.offset - fragmentParameter.startPosition.offset + 1), tmpDocument = bladeDocument_1.BladeDocument.fromText(attributeContent);
                        let shouldAdd = true;
                        if (this.nodeIndexSkipMap.has(fragmentParameter.startPosition.offset + 2)) {
                            const featureLen = this.nodeIndexSkipMap.get(fragmentParameter.startPosition.offset + 2), checkOffset = featureLen + fragmentParameter.startPosition.offset + 3;
                            if (checkOffset == fragmentParameter.endPosition.offset) {
                                shouldAdd = false;
                            }
                        }
                        if (attributeContent.trim() == '{}') {
                            shouldAdd = false;
                        }
                        if (this.shouldSkip(potentialName)) {
                            shouldAdd = false;
                        }
                        if (shouldAdd && !tmpDocument.getParser().getHasPairedStructures() && tmpDocument.getParser().getFragmentsContainingStructures().length == 0) {
                            this.extractedAttributes.push({
                                content: attributeContent,
                                name: potentialName,
                                startedOn: fragmentParameter.startPosition.offset,
                                endedOn: fragmentParameter.endPosition.offset + 1
                            });
                        }
                    }
                }
                dynamicAttributeNameOverride = null;
                continue;
            }
            if (this.cur == documentParser_1.DocumentParser.Punctuation_ForwardSlash && this.next == documentParser_1.DocumentParser.Punctuation_GreaterThan) {
                const fragment = new nodes_1.FragmentNode();
                fragment.startPosition = this.positionFromOffset(fragmentStartedAt + this.seedOffset, fragmentStartedAt + this.seedOffset);
                fragment.endPosition = this.positionFromOffset(this.currentIndex + this.seedOffset + 1, this.currentIndex + this.seedOffset + 1);
                fragment.parameters = potentialParameterRanges;
                fragment.isSelfClosing = true;
                fragment.name = nameChars.join('');
                fragment.isClosingFragment = isClosingFragment;
                this.fragments.push(fragment);
                if (isClosingFragment) {
                    this.fragmentOpeningIndex.set(fragment.startPosition.index + 1, 1);
                }
                else {
                    this.fragmentOpeningIndex.set(fragment.startPosition.index, 1);
                }
                break;
            }
            if (this.cur == documentParser_1.DocumentParser.Punctuation_GreaterThan) {
                const fragment = new nodes_1.FragmentNode();
                fragment.startPosition = this.positionFromOffset(fragmentStartedAt + this.seedOffset, fragmentStartedAt + this.seedOffset);
                fragment.endPosition = this.positionFromOffset(this.currentIndex + this.seedOffset, this.currentIndex + this.seedOffset);
                fragment.parameters = potentialParameterRanges;
                fragment.name = nameChars.join('');
                fragment.isClosingFragment = isClosingFragment;
                this.fragments.push(fragment);
                if (isClosingFragment) {
                    this.fragmentOpeningIndex.set(fragment.startPosition.index + 1, 1);
                }
                else {
                    this.fragmentOpeningIndex.set(fragment.startPosition.index, 1);
                }
                if (fragment.name.toLowerCase() == 'script' && fragment.isClosingFragment == false) {
                    this.isScript = true;
                }
                break;
            }
        }
        this.lastFragmentEnded = this.currentIndex + this.seedOffset;
    }
    skipToEndOfStringWithIndex() {
        const stringInitializer = this.cur;
        this.incrementIndex();
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex++) {
            this.checkCurrentOffsets();
            const offsetIndex = this.currentIndex + this.seedOffset;
            if (this.nodeIndexSkipMap.has(offsetIndex)) {
                const skipCount = this.nodeIndexSkipMap.get(offsetIndex);
                this.advance(skipCount - 1);
                if (this.next == null) {
                    this.parsingTracedStringHitEof = true;
                }
                continue;
            }
            if (this.cur == stringInitializer && this.prev != documentParser_1.DocumentParser.String_EscapeCharacter) {
                break;
            }
        }
    }
}
exports.FragmentsParser = FragmentsParser;
//# sourceMappingURL=fragmentsParser.js.map