"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transformer = void 0;
const bladeJavaScriptFormatter_1 = require("../formatting/bladeJavaScriptFormatter");
const classStringsConfig_1 = require("../formatting/classStringsConfig");
const generalSyntaxReflow_1 = require("../formatting/generalSyntaxReflow");
const utils_1 = require("../formatting/prettier/utils");
const voidHtmlTagsManager_1 = require("../formatting/prettier/voidHtmlTagsManager");
const syntaxReflow_1 = require("../formatting/syntaxReflow");
const nodes_1 = require("../nodes/nodes");
const simpleArrayParser_1 = require("../parser/simpleArrayParser");
const stringUtilities_1 = require("../utilities/stringUtilities");
const attributeRangeRemover_1 = require("./attributeRangeRemover");
const bladeDocument_1 = require("./bladeDocument");
const pintTransformer_1 = require("./pintTransformer");
const arrayPrinter_1 = require("./printers/arrayPrinter");
const commentPrinter_1 = require("./printers/commentPrinter");
const directivePrinter_1 = require("./printers/directivePrinter");
const echoPrinter_1 = require("./printers/echoPrinter");
const indentLevel_1 = require("./printers/indentLevel");
const printWidthUtils_1 = require("./printers/printWidthUtils");
const transformIgnore_1 = require("./transformIgnore");
class Transformer {
    constructor(doc) {
        this.isInsideIgnoreFormatter = false;
        this.ignoredLiteralBlocks = new Map();
        this.activeLiteralSlug = '';
        this.shadowDoc = null;
        this.inlineDirectiveBlocks = new Map();
        this.contentDirectives = new Map();
        this.dynamicEchoBlocks = new Map();
        this.dynamicAttributeEchoBlocks = new Map();
        this.pairedDirectives = new Map();
        this.dynamicInlineDirectives = new Map();
        this.inlineDirectives = new Map();
        this.attachedDirectives = new Map();
        this.inlineEchos = new Map();
        this.spanEchos = new Map();
        this.inlinePhpNodes = new Map();
        this.echoBlockSlugs = new Map();
        this.parentTransformer = null;
        this.forElseWithEmpty = [];
        this.forElseNoEmpty = [];
        this.conditions = [];
        this.switchStatements = [];
        this.removeLines = [];
        this.virtualStructureOpens = [];
        this.virtualStructureClose = [];
        this.inlineComments = new Map();
        this.htmlTagComments = new Map();
        this.blockComments = [];
        this.blockPhpNodes = new Map();
        this.breakDirectives = new Map();
        this.htmlTagDirectives = new Map();
        this.dynamicElementDirectives = new Map();
        this.dynamicElementDirectiveNodes = new Map();
        this.dynamicElementConditions = new Map();
        this.dynamicElementConditionNodes = new Map();
        this.dynamicElementSwitch = new Map();
        this.dynamicElementSwitchNodes = new Map();
        this.dynamicElementForElse = new Map();
        this.dynamicElementForElseNodes = new Map();
        this.dynamicElementPhpNodes = new Map();
        this.dynamicElementPhp = new Map();
        this.embeddedEchos = new Map();
        this.embeddedDirectives = new Map();
        this.structureLines = [];
        this.directiveParameters = new Map();
        this.expressionParameters = new Map();
        this.echoParameters = new Map();
        this.commentParameters = new Map();
        this.slugs = [];
        this.extractedEmbeddedDocuments = new Map();
        this.propDirectives = new Map();
        this.useLaravelPint = false;
        this.pintTransformer = null;
        this.filePath = '';
        this.formattingOptions = null;
        this.didPintFail = false;
        this.removedAttributes = new Map();
        this.shorthandSlotAttributes = new Map();
        this.shorthandSlotAttributeReference = new Map();
        this.phpFormatter = null;
        this.blockPhpFormatter = null;
        this.phpTagFormatter = null;
        this.jsonFormatter = null;
        this.transformOptions = {
            spacesAfterDirective: 0,
            spacesAfterControlDirective: 1,
            tabSize: 4,
            formatDirectiveJsonParameters: true,
            formatDirectivePhpParameters: true,
            formatInsideEcho: true,
            phpOptions: null,
            attributeJsOptions: null,
            echoStyle: 'block',
            useLaravelPint: false,
            pintCommand: 'pint {filename}',
            pintTempDirectory: '',
            pintCacheDirectory: '',
            pintCacheEnabled: true,
            pintConfigPath: '',
            classStrings: (0, classStringsConfig_1.getDefaultClassStringConfig)(),
            formatJsAttributes: true,
            excludeJsAttributes: [],
            safeWrappingJsAttributes: [
                '^x-data',
            ],
            includeJsAttributes: [
                '^x-'
            ]
        };
        this.forceCleanLines = [
            '@endphp',
            '@elseif',
            '@else',
            '@endif',
            '@endswitch',
            '@endverbatim',
            '@case',
            '@default',
        ];
        this.doc = doc;
    }
    withShadowDocument(shadow = null) {
        this.shadowDoc = shadow;
        return this;
    }
    getPintTransformer() {
        return this.pintTransformer;
    }
    setPintTransformer(transformer) {
        this.pintTransformer = transformer;
    }
    setUsingLaravelPint(usingPint) {
        this.useLaravelPint = usingPint;
    }
    getUsingLaravelPint() {
        return this.useLaravelPint;
    }
    withRemovedAttributes(attributes) {
        this.removedAttributes = attributes;
        return this;
    }
    setParentTransformer(transformer) {
        this.parentTransformer = transformer;
        this.cloneOptions(transformer);
        return this;
    }
    cloneOptions(transformer) {
        this.setUsingLaravelPint(transformer.getUsingLaravelPint());
        this.setPintTransformer(transformer.getPintTransformer());
        return this;
    }
    getFormattingOptions() {
        return this.formattingOptions;
    }
    setFormattingOptions(formattingOptions) {
        this.formattingOptions = formattingOptions;
        return this;
    }
    withJsonFormatter(formatter) {
        this.jsonFormatter = formatter;
        return this;
    }
    getJsonFormatter() {
        return this.jsonFormatter;
    }
    withFilePath(path) {
        this.filePath = path;
        return this;
    }
    withBlockPhpFormatter(formatter) {
        this.blockPhpFormatter = formatter;
        return this;
    }
    getBlockPhpFormatter() {
        return this.blockPhpFormatter;
    }
    withPhpTagFormatter(formatter) {
        this.phpTagFormatter = formatter;
        return this;
    }
    getPhpTagFormatter() {
        return this.phpTagFormatter;
    }
    withPhpFormatter(formatter) {
        this.phpFormatter = formatter;
        return this;
    }
    getPhpFormatter() {
        return this.phpFormatter;
    }
    /**
     * Returns a document with Blade removed.
     * @returns string
     */
    removeBlade() {
        const allNodes = this.doc.getAllNodes();
        let text = '';
        allNodes.forEach((node) => {
            if (node instanceof nodes_1.LiteralNode) {
                text += node.getOutputContent();
            }
            else if (node instanceof nodes_1.InlinePhpNode) {
                text += node.sourceContent;
            }
            else if (node instanceof nodes_1.DirectiveNode && node.directiveName == 'verbatim') {
                text += node.innerContent;
            }
        });
        return text;
    }
    close(value) {
        return '</' + value + '>';
    }
    open(value) {
        return '<' + value + '>';
    }
    selfClosing(value) {
        return '<' + value + ' />';
    }
    pair(value, innerContent = '') {
        return '<' + value + '>' + innerContent + '</' + value + '>';
    }
    printDirective(directive, indentLevel) {
        var _a;
        return directivePrinter_1.DirectivePrinter.printDirective(directive, this.transformOptions, this.phpFormatter, this.jsonFormatter, indentLevel, (_a = this.pintTransformer) !== null && _a !== void 0 ? _a : Transformer.sharedPintTransformer);
    }
    makeSlug(length) {
        const slug = stringUtilities_1.StringUtilities.makeSlug(length);
        if (this.slugs.includes(slug)) {
            return this.makeSlug(length + 1);
        }
        this.slugs.push(slug);
        return slug;
    }
    registerDirectiveParameter(slug, param) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerDirectiveParameter(slug, param);
        }
        else {
            this.directiveParameters.set(slug, param);
        }
    }
    registerShorthandSlot(component) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerShorthandSlot(component);
        }
        const slug = this.makeSlug(20);
        this.shorthandSlotAttributes.set(component.refId, slug);
        this.shorthandSlotAttributeReference.set(slug, component);
        return slug;
    }
    getSlotSlug(refId) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.getSlotSlug(refId);
        }
        if (this.shorthandSlotAttributes.has(refId)) {
            return this.shorthandSlotAttributes.get(refId);
        }
        return '';
    }
    registerCommentParameter(slug, param) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerCommentParameter(slug, param);
        }
        else {
            this.commentParameters.set(slug, param);
        }
    }
    registerEchoParameter(slug, param) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerEchoParameter(slug, param);
        }
        else {
            this.echoParameters.set(slug, param);
        }
    }
    registerExpressionParameter(slug, param) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerExpressionParameter(slug, param);
        }
        else {
            this.expressionParameters.set(slug, param);
        }
    }
    registerCondition(transformedCondition) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerCondition(transformedCondition);
        }
        else {
            this.conditions.push(transformedCondition);
        }
    }
    registerSwitchStatement(transformedSwitch) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerSwitchStatement(transformedSwitch);
        }
        else {
            this.switchStatements.push(transformedSwitch);
        }
    }
    registerPairedDirective(slug, directive) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerPairedDirective(slug, directive);
        }
        else {
            if (directive.isInline == false) {
                this.pairedDirectives.set(slug, directive);
            }
            else {
                this.inlineDirectives.set(directive.slug, directive);
                this.dynamicInlineDirectives.set(directive.directive.nodeContent, directive.slug);
            }
        }
    }
    registerAttachedDirective(slug, directive) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerAttachedDirective(slug, directive);
        }
        else {
            this.attachedDirectives.set(slug, directive);
        }
    }
    registerInlineDirectiveBlock(slug, directive) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerInlineDirectiveBlock(slug, directive);
        }
        else {
            this.inlineDirectiveBlocks.set(slug, directive);
        }
    }
    registerContentDirective(slug, directive) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerContentDirective(slug, directive);
        }
        else {
            this.contentDirectives.set(slug, directive);
        }
    }
    registerComment(slug, comment) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerComment(slug, comment);
        }
        else {
            this.inlineComments.set(slug, comment);
        }
    }
    registerDynamicDirective(slug, directive) {
        if (this.parentTransformer != null) {
            this.dynamicElementDirectives.set(directive.nodeContent, slug);
            this.parentTransformer.registerDynamicDirective(slug, directive);
        }
        else {
            this.dynamicElementDirectives.set(directive.nodeContent, slug);
            this.dynamicElementDirectiveNodes.set(slug, directive);
        }
    }
    prepareConditionalDirective(directive) {
        if (this.dynamicElementDirectives.has(directive.nodeContent)) {
            return this.dynamicElementDirectives.get(directive.nodeContent);
        }
        const slug = this.makeSlug(directive.nodeContent.length);
        this.registerDynamicDirective(slug, directive);
        return slug;
    }
    prepareInlineBlockDirective(directive) {
        const slug = this.makeSlug(directive.sourceContent.length);
        this.registerInlineDirectiveBlock(slug, directive);
        return this.selfClosing(slug);
    }
    prepareContentDirective(directive) {
        var _a, _b, _c, _d;
        const slug = this.makeSlug(directive.sourceContent.length);
        this.registerContentDirective(slug, directive);
        if (directive.nextNode != null) {
            const placementDiff = ((_b = (_a = directive.nextNode.startPosition) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0) - ((_d = (_c = directive.endPosition) === null || _c === void 0 ? void 0 : _c.offset) !== null && _d !== void 0 ? _d : 0);
            if (directive.nextNode instanceof nodes_1.LiteralNode) {
                const trailingLiteral = directive.nextNode;
                if ((trailingLiteral.content.length - trailingLiteral.content.trimLeft().length) > 0) {
                    return slug;
                }
                else {
                    if (trailingLiteral.content.length == 0) {
                        return slug;
                    }
                    else {
                        const firstTrailingChar = trailingLiteral.content[0];
                        if (stringUtilities_1.StringUtilities.ctypePunct(firstTrailingChar) || stringUtilities_1.StringUtilities.ctypeSpace(firstTrailingChar)) {
                            return slug;
                        }
                        else {
                            return slug + ' ';
                        }
                    }
                }
            }
            else {
                if (placementDiff > 0) {
                    return slug + ' ';
                }
                else {
                    return slug;
                }
            }
        }
        return slug;
    }
    registerPhpBlock(slug, php) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerPhpBlock(slug, php);
        }
        else {
            this.removeLines.push(this.close(slug));
            this.blockPhpNodes.set(slug, php);
        }
    }
    registerConditionalPhpBlock(slug, php) {
        if (this.parentTransformer != null) {
            this.dynamicElementPhp.set(php.sourceContent, slug);
            this.parentTransformer.registerConditionalPhpBlock(slug, php);
        }
        else {
            this.dynamicElementPhp.set(php.sourceContent, slug);
            this.dynamicElementPhpNodes.set(slug, php);
        }
    }
    prepareConditionalPhpBlock(php) {
        if (this.dynamicElementPhp.has(php.sourceContent)) {
            return this.dynamicElementPhp.get(php.sourceContent);
        }
        const slug = this.makeSlug(php.sourceContent.length);
        this.registerConditionalPhpBlock(slug, php);
        return slug;
    }
    registerInlinePhpBlock(php) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerInlinePhpBlock(php);
        }
        else {
            const slug = this.makeSlug(php.sourceContent.length);
            this.inlinePhpNodes.set(slug, php);
            return slug;
        }
    }
    prepareInlinePhpBlock(php) {
        return this.registerInlinePhpBlock(php);
    }
    transformComponentSlots(content) {
        let result = content;
        this.shorthandSlotAttributeReference.forEach((component, slug) => {
            var _a;
            const open = `<x-${slug}`, close = `</x-${slug}`, inlineName = (_a = component.name) === null || _a === void 0 ? void 0 : _a.inlineName, replace = `<x-slot:${inlineName}`;
            result = stringUtilities_1.StringUtilities.safeReplaceAllInString(result, close, '</x-slot');
            result = stringUtilities_1.StringUtilities.safeReplaceAllInString(result, open, replace);
        });
        return result;
    }
    preparePhpBlock(php) {
        if (php.fragmentPosition == nodes_1.FragmentPosition.IsDynamicFragmentName) {
            return this.prepareConditionalPhpBlock(php);
        }
        if (php.isInline || php.fragmentPosition == nodes_1.FragmentPosition.InsideFragment || php.fragmentPosition == nodes_1.FragmentPosition.InsideFragmentParameter) {
            return this.prepareInlinePhpBlock(php);
        }
        const slug = this.makeSlug(35);
        this.registerPhpBlock(slug, php);
        const open = this.open(slug), close = this.close(slug);
        return "\n" + open + close + "\n";
    }
    transformPhpBlock(content) {
        let value = content;
        this.blockPhpNodes.forEach((php, slug) => {
            const open = this.open(slug), targetIndent = this.indentLevel(open);
            let result = php.sourceContent;
            if (this.transformOptions.formatDirectivePhpParameters && php.hasValidPhp()) {
                if (this.useLaravelPint) {
                    if (this.pintTransformer != null) {
                        result = this.pintTransformer.getPhpBlockContent(php);
                    }
                    else if (Transformer.sharedPintTransformer != null) {
                        result = Transformer.sharedPintTransformer.getPhpBlockContent(php);
                    }
                }
                else {
                    if (this.phpTagFormatter != null) {
                        result = this.phpTagFormatter(result, this.transformOptions, null);
                        if (generalSyntaxReflow_1.GeneralSyntaxReflow.couldReflow(result)) {
                            result = generalSyntaxReflow_1.GeneralSyntaxReflow.instance.reflow(result);
                        }
                        if (syntaxReflow_1.SyntaxReflow.couldReflow(result)) {
                            result = syntaxReflow_1.SyntaxReflow.instance.reflow(result);
                        }
                    }
                }
                result = indentLevel_1.IndentLevel.shiftIndent(result, targetIndent, true, this.transformOptions);
            }
            value = stringUtilities_1.StringUtilities.safeReplace(value, open, result);
        });
        this.dynamicElementPhpNodes.forEach((php, slug) => {
            value = stringUtilities_1.StringUtilities.safeReplaceAllInString(value, slug, this.printInlinePhp(php));
        });
        this.inlinePhpNodes.forEach((php, slug) => {
            value = stringUtilities_1.StringUtilities.safeReplace(value, slug, this.printInlinePhp(php));
        });
        return value;
    }
    printInlinePhp(php) {
        let phpContent = php.sourceContent;
        if (this.phpTagFormatter && php.hasValidPhp()) {
            phpContent = this.phpTagFormatter(phpContent, this.transformOptions, null);
            if (generalSyntaxReflow_1.GeneralSyntaxReflow.couldReflow(phpContent)) {
                phpContent = generalSyntaxReflow_1.GeneralSyntaxReflow.instance.reflow(phpContent);
            }
            if (syntaxReflow_1.SyntaxReflow.couldReflow(phpContent)) {
                phpContent = syntaxReflow_1.SyntaxReflow.instance.reflow(phpContent);
            }
            phpContent = stringUtilities_1.StringUtilities.safeReplaceAllInString(phpContent, "\n", ' ');
        }
        return phpContent;
    }
    shouldCreateVirutal(directive) {
        const children = directive.getImmediateChildren();
        if (children.length == 0) {
            return true;
        }
        let allEchosInline = true, allLiteralsWhitespace = true, inlineEchos = 0, bladeCount = 0, literalCount = 0, createVirtual = true;
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child instanceof nodes_1.BladeEchoNode && child.isInlineEcho) {
                allEchosInline = false;
                inlineEchos += 1;
                bladeCount += 1;
            }
            else if (child instanceof nodes_1.LiteralNode) {
                literalCount += 1;
                if (child.content.trim().length > 0) {
                    allLiteralsWhitespace = false;
                }
            }
            else {
                bladeCount += 1;
            }
        }
        if (inlineEchos == 0) {
            createVirtual = true;
        }
        if (bladeCount > 0 && allEchosInline == true) {
            return false;
        }
        if (allLiteralsWhitespace == false && bladeCount == 0) {
            createVirtual = true;
        }
        if (allLiteralsWhitespace == true && bladeCount == 0) {
            createVirtual = true;
        }
        return createVirtual;
    }
    preparePairedDirective(directive) {
        var _a, _b, _c, _d, _e, _f, _g;
        const slug = this.makeSlug(directive.sourceContent.length), directiveName = directive.directiveName.toLowerCase(), innerDoc = (_a = directive.childrenDocument) === null || _a === void 0 ? void 0 : _a.document.transform().setParentTransformer(this).toStructure();
        if (directive.fragmentPosition != nodes_1.FragmentPosition.IsDynamicFragmentName) {
            if (directive.originalAbstractNode != null && directive.originalAbstractNode.prevNode instanceof nodes_1.BladeEchoNode && directive.originalAbstractNode instanceof nodes_1.DirectiveNode && directive.originalAbstractNode.directiveName == 'if') {
                const distance = ((_c = (_b = directive.originalAbstractNode.startPosition) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : 0) - ((_e = (_d = directive.originalAbstractNode.prevNode.endPosition) === null || _d === void 0 ? void 0 : _d.index) !== null && _e !== void 0 ? _e : 0);
                if (distance > 0 && distance < 3) {
                    this.registerAttachedDirective(slug, {
                        directive: directive,
                        innerDoc: innerDoc,
                        slug: slug,
                        isInline: false,
                        virtualElementSlug: ''
                    });
                    return slug;
                }
            }
            let virtualSlug = '';
            let result = `${this.open(slug)}\n`;
            if (directiveName == 'php' || directiveName == 'verbatim') {
                virtualSlug = this.makeSlug(15);
                result += this.pair(virtualSlug);
            }
            else {
                const contentContainsAllInline = this.isAllInlineNodes((_f = directive.children) !== null && _f !== void 0 ? _f : []), containsBladeStructures = this.containsBladeStructures((_g = directive.children) !== null && _g !== void 0 ? _g : []);
                if (attributeRangeRemover_1.isAttributeFormatter) {
                    result += ' ' + innerDoc.trim() + ' ';
                }
                else {
                    if ((this.shouldCreateVirutal(directive) && directive.containsChildStructures == false &&
                        directive.containsAnyFragments == false &&
                        !contentContainsAllInline &&
                        !containsBladeStructures) || (!directive.containsAnyFragments && contentContainsAllInline && containsBladeStructures)) {
                        virtualSlug = this.makeSlug(15);
                        result += this.pair(virtualSlug, innerDoc);
                    }
                    else {
                        result += innerDoc;
                    }
                }
            }
            result += `${this.close(slug)}\n`;
            this.virtualStructureOpens.push(this.open(virtualSlug));
            this.virtualStructureClose.push(this.close(virtualSlug));
            this.virtualStructureClose.push(this.close(slug));
            this.registerPairedDirective(slug, {
                innerDoc: innerDoc,
                slug: slug,
                directive: directive,
                virtualElementSlug: virtualSlug,
                isInline: false
            });
            return result;
        }
        if (this.dynamicInlineDirectives.has(directive.nodeContent)) {
            const existingSlug = this.dynamicInlineDirectives.get(directive.nodeContent);
            return existingSlug + ' ';
        }
        const dynamicSlug = this.makeSlug(directive.nodeContent.length);
        this.registerPairedDirective(slug, {
            innerDoc: innerDoc,
            slug: dynamicSlug,
            directive: directive,
            virtualElementSlug: '',
            isInline: true
        });
        return dynamicSlug + ' ';
    }
    registerForElseWithEmpty(forElse) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerForElseWithEmpty(forElse);
        }
        else {
            this.forElseWithEmpty.push(forElse);
        }
    }
    prepareForElse(forElse) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (forElse.fragmentPosition == nodes_1.FragmentPosition.Unresolved || forElse.fragmentPosition == nodes_1.FragmentPosition.InsideFragment) {
            if (forElse.elseNode != null) {
                const truthSlug = this.makeSlug((_b = (_a = forElse.constructedFrom) === null || _a === void 0 ? void 0 : _a.sourceContent.length) !== null && _b !== void 0 ? _b : 0), elseSlug = this.makeSlug((_d = (_c = forElse.elseNode) === null || _c === void 0 ? void 0 : _c.sourceContent.length) !== null && _d !== void 0 ? _d : 0), truthTransform = (_e = forElse.truthDocument) === null || _e === void 0 ? void 0 : _e.document.transform().setParentTransformer(this).toStructure(), falseTransform = (_f = forElse.falseDocument) === null || _f === void 0 ? void 0 : _f.document.transform().setParentTransformer(this).toStructure();
                const repForElse = {
                    truthDoc: truthTransform,
                    falseDoc: falseTransform,
                    forElse: forElse,
                    truthClose: this.close(truthSlug),
                    emptyOpen: this.open(elseSlug),
                    pairClose: this.close(elseSlug),
                    truthSlug: truthSlug,
                    falseSlug: elseSlug
                };
                let result = this.open(truthSlug);
                result += truthTransform;
                result += repForElse.truthClose;
                result += "\n" + repForElse.emptyOpen + "\n"; // This replacement will be the @empty
                result += falseTransform + "";
                result += repForElse.pairClose;
                this.registerForElseWithEmpty(repForElse);
                return result;
            }
            const construction = forElse.constructedFrom, truthDoc = (_g = forElse.truthDocument) === null || _g === void 0 ? void 0 : _g.document.transform().setParentTransformer(this).toStructure(), openSlug = this.makeSlug(construction.sourceContent.length), closeSlug = this.makeSlug((_j = (_h = construction.isClosedBy) === null || _h === void 0 ? void 0 : _h.sourceContent.length) !== null && _j !== void 0 ? _j : 0);
            const noElseForElse = {
                truthDoc: truthDoc,
                falseDoc: '',
                forElse: forElse,
                truthSlug: openSlug,
                falseSlug: '',
                pairClose: this.close(closeSlug),
                emptyOpen: '',
                truthClose: ''
            };
            this.forElseNoEmpty.push(noElseForElse);
            let result = this.open(openSlug);
            result += truthDoc;
            result += this.close(openSlug);
            return result;
        }
        if (this.dynamicElementForElse.has(forElse.nodeContent)) {
            const existingSlug = this.dynamicElementForElse.get(forElse.nodeContent);
            return existingSlug + ' ';
        }
        const slug = this.makeSlug(forElse.nodeContent.length);
        this.registerDynamicElementForElse(slug, forElse);
        return slug + ' ';
    }
    registerBreak(slug, directive) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerBreak(slug, directive);
        }
        else {
            this.breakDirectives.set(slug, directive);
        }
    }
    registerProps(slug, directive) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerProps(slug, directive);
        }
        else {
            this.propDirectives.set(slug, directive);
        }
    }
    preparePropsDirective(directive) {
        const virtualSlug = this.makeSlug(10);
        this.registerProps(virtualSlug, directive);
        return `\n\n${this.pair(virtualSlug)}`;
    }
    prepareBreakDirective(directive) {
        const virtualSlug = this.makeSlug(10);
        this.registerBreak(virtualSlug, directive);
        return `\n\n${this.pair(virtualSlug)}`;
    }
    registerEmbeddedDirective(directive) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerEmbeddedDirective(directive);
        }
        const slug = this.makeSlug(directive.nodeContent.length);
        this.embeddedDirectives.set(slug, directive);
        return slug;
    }
    prepareHtmlTagDirective(directive) {
        if (Transformer.rootTransformer != null && Transformer.rootTransformer != this) {
            return Transformer.rootTransformer.prepareHtmlTagDirective(directive);
        }
        const slug = stringUtilities_1.StringUtilities.makeSlug(64);
        this.htmlTagDirectives.set(slug, directive);
        return slug;
    }
    registerEmbeddedDocument(slug, content, isScript) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerEmbeddedDocument(slug, content, isScript);
        }
        this.extractedEmbeddedDocuments.set(slug, {
            slug: slug,
            content: content,
            isScript: isScript
        });
        return slug;
    }
    prepareDirective(directive) {
        if (directive.fragmentPosition == nodes_1.FragmentPosition.InsideFragment && directive.isClosedBy != null) {
            return "\n" + this.prepareHtmlTagDirective(directive);
        }
        if (directive.isEmbedded()) {
            return this.registerEmbeddedDirective(directive);
        }
        if (directive.directiveName.trim().toLowerCase() == 'break') {
            return this.prepareBreakDirective(directive);
        }
        if (directive.directiveName.trim().toLowerCase() == 'props') {
            return this.preparePropsDirective(directive);
        }
        if (directive.isClosedBy != null) {
            return this.preparePairedDirective(directive);
        }
        if (directive.fragmentPosition == nodes_1.FragmentPosition.Unresolved) {
            return this.prepareInlineBlockDirective(directive);
        }
        else if (directive.fragmentPosition == nodes_1.FragmentPosition.IsDynamicFragmentName) {
            return this.prepareConditionalDirective(directive);
        }
        return this.prepareContentDirective(directive);
    }
    registerVirtualComment(structure) {
        if (this.parentTransformer != null) {
            this.parentTransformer.registerVirtualComment(structure);
        }
        else {
            this.blockComments.push(structure);
        }
    }
    registerHtmlTagComment(comment) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerHtmlTagComment(comment);
        }
        const slug = stringUtilities_1.StringUtilities.makeSlug(64);
        this.htmlTagComments.set(slug, comment);
        return slug;
    }
    prepareComment(comment) {
        if (!attributeRangeRemover_1.isAttributeFormatter && comment.isPartOfHtmlTag()) {
            return this.registerHtmlTagComment(comment);
        }
        if (comment.isMultiline()) {
            const slug = this.makeSlug(10), virtualSlug = this.makeSlug(10);
            const virtualStructure = {
                node: comment,
                pairOpen: this.open(slug),
                pairClose: this.close(slug),
                virtualElement: this.selfClosing(virtualSlug)
            };
            this.registerVirtualComment(virtualStructure);
            return virtualStructure.pairOpen + "\n" + virtualStructure.virtualElement + "\n" + virtualStructure.pairClose;
        }
        const slug = this.makeSlug(comment.sourceContent.length);
        if (attributeRangeRemover_1.isAttributeFormatter && comment.hasNeighborsOnLine()) {
            Transformer.inlineComments.push(this.selfClosing(slug));
        }
        this.registerComment(slug, comment);
        return this.selfClosing(slug);
    }
    registerDynamicFragmentEcho(echo) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerDynamicFragmentEcho(echo);
        }
        else {
            if (!this.echoBlockSlugs.has(echo.sourceContent)) {
                const slug = this.makeSlug(echo.sourceContent.length);
                this.dynamicEchoBlocks.set(slug, echo);
                this.echoBlockSlugs.set(echo.sourceContent, slug);
                return slug;
            }
            else {
                return this.echoBlockSlugs.get(echo.sourceContent);
            }
        }
    }
    registerDynamicAttributeFragmentEcho(echo) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerDynamicFragmentEcho(echo);
        }
        else {
            const slug = this.makeSlug(echo.sourceContent.length);
            this.dynamicAttributeEchoBlocks.set(slug, echo);
            return `${slug}="${slug}"`;
        }
    }
    registerInlineEcho(echo) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerInlineEcho(echo);
        }
        else {
            const slug = this.makeSlug(echo.sourceContent.length);
            if (echo.isInlineEcho) {
                this.spanEchos.set(slug, echo);
                return slug;
            }
            else {
                this.inlineEchos.set(slug, echo);
                return this.selfClosing(slug);
            }
        }
    }
    prepareComponent(component) {
        var _a, _b;
        if (component.isClosingTag) {
            if (((_a = component.name) === null || _a === void 0 ? void 0 : _a.name) == 'slot') {
                if (component.isOpenedBy != null) {
                    if (component.isOpenedBy.isShorthandSlot) {
                        const parentRefId = component.isOpenedBy.refId, parentSlug = this.getSlotSlug(parentRefId);
                        return `</x-${parentSlug}>`;
                    }
                }
                return '</x-slot>';
            }
            return '</x-' + component.getComponentName() + '>';
        }
        let value = '<x-';
        if (((_b = component.name) === null || _b === void 0 ? void 0 : _b.name) == 'slot' && component.isSelfClosing == false) {
            if (component.name.inlineName.trim().length > 0) {
                let slotName = component.name.inlineName;
                if (slotName.startsWith(':')) {
                    slotName = slotName.substring(1);
                }
                if (component.isClosedBy != null) {
                    value += this.registerShorthandSlot(component);
                }
                else {
                    value += 'slot name="' + slotName + '"';
                }
            }
            else {
                value += component.getComponentName();
            }
        }
        else {
            value += component.getComponentName();
        }
        if (component.hasParameters) {
            value += ' ';
            component.parameters.forEach((param) => {
                var _a, _b;
                if (param.type == nodes_1.ParameterType.Parameter) {
                    if (param.isExpression) {
                        const expressionSlug = this.makeSlug(param.content.length);
                        this.registerExpressionParameter(expressionSlug, param);
                        value += expressionSlug + ' ';
                    }
                    else {
                        value += param.content + ' ';
                    }
                }
                else if (param.type == nodes_1.ParameterType.Attribute) {
                    value += param.name + ' ';
                }
                else if (param.type == nodes_1.ParameterType.Directive) {
                    const directiveSlug = this.makeSlug((_b = (_a = param.directive) === null || _a === void 0 ? void 0 : _a.sourceContent.length) !== null && _b !== void 0 ? _b : 0);
                    this.registerDirectiveParameter(directiveSlug, param);
                    value += directiveSlug + ' ';
                }
                else if (param.type == nodes_1.ParameterType.InlineEcho && param.inlineEcho != null) {
                    const echoSlug = this.makeSlug(param.inlineEcho.content.length);
                    this.registerEchoParameter(echoSlug, param);
                    value += echoSlug + ' ';
                }
                else if (param.type == nodes_1.ParameterType.Comment && param.inlineComment != null) {
                    const commentSlug = this.makeSlug(param.inlineComment.innerContent.length);
                    this.registerCommentParameter(commentSlug, param);
                    value += commentSlug + ' ';
                }
            });
        }
        if (component.isSelfClosing) {
            value += ' />';
        }
        else {
            value += '>';
        }
        return value;
    }
    registerEmbeddedEcho(echo) {
        if (this.parentTransformer != null) {
            return this.parentTransformer.registerEmbeddedEcho(echo);
        }
        const slug = this.makeSlug(echo.sourceContent.length);
        this.embeddedEchos.set(slug, echo);
        return slug;
    }
    prepareEcho(echo) {
        if (echo.isEmbedded()) {
            return this.registerEmbeddedEcho(echo);
        }
        if (echo.fragmentPosition == nodes_1.FragmentPosition.IsDynamicFragmentName) {
            return this.registerDynamicFragmentEcho(echo);
        }
        else if (echo.fragmentPosition == nodes_1.FragmentPosition.InsideFragmentParameter) {
            return this.registerDynamicFragmentEcho(echo);
        }
        else if (echo.fragmentPosition == nodes_1.FragmentPosition.InsideFragment) {
            if (echo.prevNode != null && !(echo.prevNode instanceof nodes_1.LiteralNode)) {
                return this.registerInlineEcho(echo);
            }
            if (echo.nextNode != null) {
                if (echo.nextNode instanceof nodes_1.LiteralNode) {
                    const trailingLiteral = echo.nextNode;
                    if ((trailingLiteral.content.length - trailingLiteral.content.trimLeft().length) > 0) {
                        return this.registerDynamicAttributeFragmentEcho(echo);
                    }
                    else {
                        if (trailingLiteral.content.length == 0) {
                            return this.registerDynamicAttributeFragmentEcho(echo);
                        }
                        else {
                            const firstTrailingChar = trailingLiteral.content[0];
                            if (!stringUtilities_1.StringUtilities.ctypeSpace(firstTrailingChar)) {
                                return this.registerDynamicFragmentEcho(echo);
                            }
                        }
                    }
                }
                else {
                    return this.registerInlineEcho(echo);
                }
            }
            return this.registerDynamicAttributeFragmentEcho(echo);
        }
        return this.registerInlineEcho(echo);
    }
    prepareSwitch(switchNode) {
        if (switchNode.fragmentPosition == nodes_1.FragmentPosition.Unresolved || switchNode.fragmentPosition == nodes_1.FragmentPosition.InsideFragment) {
            const tCases = [];
            let result = '';
            switchNode.cases.forEach((caseNode, index) => {
                var _a, _b;
                const directive = caseNode.head, innerDoc = (_a = caseNode.childDocument) === null || _a === void 0 ? void 0 : _a.document.transform().setParentTransformer(this).toStructure();
                const openSlug = this.makeSlug(directive.sourceContent.length);
                const virtualOpen = this.makeSlug(5);
                const tCase = {
                    case: caseNode,
                    slug: openSlug,
                    doc: innerDoc,
                    virtualOpen: this.selfClosing(virtualOpen),
                    virtualClose: this.close(virtualOpen),
                    pairOpen: this.open(openSlug),
                    pairClose: this.close(openSlug),
                    isFirst: index == 0,
                    isLast: index == switchNode.cases.length - 1,
                    leadingClose: '',
                    leadingOpen: ''
                };
                if (caseNode.leadingDocument != null) {
                    const leadingSlug = this.makeSlug(25);
                    tCase.leadingOpen = this.open(leadingSlug);
                    tCase.leadingClose = this.close(leadingSlug);
                    result += "\n" + caseNode.leadingDocument.document.transform().setParentTransformer(this).toStructure() + "\n";
                }
                result += tCase.pairOpen;
                if (((_b = caseNode.head) === null || _b === void 0 ? void 0 : _b.directiveName) == 'default') {
                    result += tCase.virtualOpen;
                }
                result += innerDoc;
                result += tCase.pairClose;
                tCases.push(tCase);
            });
            const pairOpen = tCases[0].pairOpen, pairClose = tCases[tCases.length - 1].pairClose;
            const virtualSwitchSlug = this.makeSlug(10), virtualSwitchOpen = this.open(virtualSwitchSlug), virtualSwitchClose = this.close(virtualSwitchSlug);
            const tSwitch = {
                switchNode: switchNode,
                pairOpen: pairOpen,
                pairClose: pairClose,
                structures: tCases,
                virtualSwitchClose: virtualSwitchClose,
                virtualSwitchOpen: virtualSwitchOpen
            };
            const virtualStruct = "\n" + virtualSwitchOpen + "\n" + result + "\n" + virtualSwitchClose;
            this.registerSwitchStatement(tSwitch);
            return virtualStruct;
        }
        if (this.dynamicElementSwitch.has(switchNode.nodeContent)) {
            const existingSlug = this.dynamicElementSwitch.get(switchNode.nodeContent);
            return existingSlug + ' ';
        }
        const slug = this.makeSlug(switchNode.nodeContent.length);
        this.registerDynamicElementSwitch(slug, switchNode);
        return slug + ' ';
    }
    registerDynamicElementSwitch(slug, switchNode) {
        if (this.parentTransformer != null) {
            this.dynamicElementSwitch.set(switchNode.nodeContent, slug);
            this.parentTransformer.registerDynamicElementSwitch(slug, switchNode);
        }
        else {
            this.dynamicElementSwitch.set(switchNode.nodeContent, slug);
            this.dynamicElementSwitchNodes.set(slug, switchNode);
        }
    }
    registerDynamicElementCondition(slug, condition) {
        if (this.parentTransformer != null) {
            this.dynamicElementConditions.set(condition.nodeContent, slug);
            this.parentTransformer.registerDynamicElementCondition(slug, condition);
        }
        else {
            this.dynamicElementConditions.set(condition.nodeContent, slug);
            this.dynamicElementConditionNodes.set(slug, condition);
        }
    }
    registerDynamicElementForElse(slug, forElse) {
        if (this.parentTransformer != null) {
            this.dynamicElementForElse.set(forElse.nodeContent, slug);
            this.parentTransformer.registerDynamicElementForElse(slug, forElse);
        }
        else {
            this.dynamicElementForElse.set(forElse.nodeContent, slug);
            this.dynamicElementForElseNodes.set(slug, forElse);
        }
    }
    containsComponents(nodes) {
        for (let i = 0; i < nodes.length; i++) {
            if (nodes[i] instanceof nodes_1.BladeComponentNode) {
                return true;
            }
        }
        return false;
    }
    containsBladeStructures(nodes) {
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (!(node instanceof nodes_1.LiteralNode)) {
                if (node instanceof nodes_1.DirectiveNode && (node.isClosingDirective || node.isClosingDirective || node.name == 'elseif' || node.name == 'else')) {
                    continue;
                }
                return true;
            }
        }
        return false;
    }
    isAllInlineNodes(nodes) {
        let echoCount = 0;
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node instanceof nodes_1.LiteralNode) {
                continue;
            }
            if (node instanceof nodes_1.BladeEchoNode) {
                if (!node.isInlineEcho) {
                    return false;
                }
                echoCount += 1;
            }
            else {
                if (node instanceof nodes_1.DirectiveNode) {
                    if (node.isClosingDirective || node.name == 'elseif' || node.name == 'else') {
                        continue;
                    }
                    return false;
                }
                else {
                    return false;
                }
            }
        }
        if (echoCount == 0) {
            return false;
        }
        return true;
    }
    prepareConditions(condition) {
        var _a, _b, _c, _d, _e, _f;
        if (condition.fragmentPosition == nodes_1.FragmentPosition.Unresolved) {
            if (condition.chain.length == 1 && condition.constructedFrom != null) {
                const construction = condition.constructedFrom.clone();
                construction.childrenDocument = condition.logicBranches[0].childDocument;
                return this.preparePairedDirective(construction);
            }
            const transformedBranches = [];
            let result = '';
            condition.logicBranches.forEach((branch, index) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
                const directive = branch.head, innerDoc = (_a = branch.childDocument) === null || _a === void 0 ? void 0 : _a.document.transform().setParentTransformer(this).toStructure();
                const openSlug = this.makeSlug(directive.sourceContent.length), virtualSlug = this.makeSlug(10);
                const tBranch = {
                    branch: branch,
                    slug: openSlug,
                    doc: innerDoc,
                    pairOpen: this.open(openSlug),
                    pairClose: this.close(openSlug),
                    virtualOpen: this.open(virtualSlug),
                    virtualClose: this.close(virtualSlug),
                    isFirst: index == 0,
                    isLast: index == condition.logicBranches.length - 1,
                    virtualBreakClose: '',
                    virtualBreakOpen: '',
                    isLiteralContent: false,
                };
                if (((_b = branch.head) === null || _b === void 0 ? void 0 : _b.directiveName) == 'else') {
                    result += "\n" + tBranch.pairOpen;
                    const virtualBreakSlug = this.makeSlug(25), containsBladeStructures = this.containsBladeStructures((_c = branch.head.children) !== null && _c !== void 0 ? _c : []);
                    if (attributeRangeRemover_1.isAttributeFormatter) {
                        tBranch.virtualBreakOpen = this.selfClosing(virtualBreakSlug);
                        result += tBranch.virtualBreakOpen + "\n";
                        result += innerDoc;
                        result += "\n" + tBranch.pairClose;
                    }
                    else {
                        if (branch.head.containsChildStructures == false && branch.head.containsAnyFragments == false &&
                            ((((_d = branch.head) === null || _d === void 0 ? void 0 : _d.children.length) <= 2 || ((_e = branch.head) === null || _e === void 0 ? void 0 : _e.children.length) > 4) &&
                                !this.isAllInlineNodes(branch.head.children) &&
                                !containsBladeStructures)) {
                            tBranch.virtualBreakOpen = this.open(virtualBreakSlug);
                            tBranch.virtualBreakClose = this.close(virtualBreakSlug);
                            result += "\n" + tBranch.virtualBreakOpen + "\n";
                            result += innerDoc;
                            result += "\n" + tBranch.virtualBreakClose + "\n" + tBranch.pairClose;
                        }
                        else {
                            tBranch.virtualBreakOpen = this.selfClosing(virtualBreakSlug);
                            result += tBranch.virtualBreakOpen + "\n";
                            result += innerDoc;
                            result += "\n" + tBranch.pairClose;
                        }
                    }
                }
                else {
                    const branchContainsAllInline = this.isAllInlineNodes((_g = (_f = branch.head) === null || _f === void 0 ? void 0 : _f.children) !== null && _g !== void 0 ? _g : []), containsBladeStructures = this.containsBladeStructures((_j = (_h = branch.head) === null || _h === void 0 ? void 0 : _h.children) !== null && _j !== void 0 ? _j : []);
                    if (attributeRangeRemover_1.isAttributeFormatter) {
                        result += "\n" + tBranch.pairOpen;
                        const virtualBreakSlug = this.makeSlug(25);
                        tBranch.virtualBreakOpen = this.selfClosing(virtualBreakSlug);
                        result += tBranch.virtualBreakOpen + "\n";
                        result += innerDoc;
                        result += "\n" + tBranch.pairClose;
                    }
                    else {
                        if (((_k = branch.head) === null || _k === void 0 ? void 0 : _k.containsAnyFragments) == false &&
                            ((_l = branch.head) === null || _l === void 0 ? void 0 : _l.containsChildStructures) == false &&
                            (((_m = branch.head) === null || _m === void 0 ? void 0 : _m.children.length) <= 2 || ((_o = branch.head) === null || _o === void 0 ? void 0 : _o.children.length) > 4) &&
                            !branchContainsAllInline && !containsBladeStructures) {
                            const ifBreakSlug = this.makeSlug(25);
                            tBranch.virtualBreakOpen = this.open(ifBreakSlug);
                            tBranch.virtualBreakClose = this.close(ifBreakSlug);
                            if (((_p = branch.head) === null || _p === void 0 ? void 0 : _p.children.length) <= 2 && branch.head.children[0] instanceof nodes_1.LiteralNode) {
                                result += tBranch.pairOpen;
                                result += "\n" + tBranch.virtualBreakOpen;
                                result += "\n" + tBranch.virtualBreakClose;
                                result += tBranch.pairClose;
                                tBranch.isLiteralContent = true;
                            }
                            else {
                                result += tBranch.pairOpen;
                                result += "\n" + tBranch.virtualBreakOpen;
                                result += innerDoc;
                                result += "\n" + tBranch.virtualBreakClose;
                                result += tBranch.pairClose;
                            }
                        }
                        else {
                            if (branchContainsAllInline) {
                                result += "\n" + tBranch.pairOpen;
                                const virtualBreakSlug = this.makeSlug(25);
                                tBranch.virtualBreakOpen = this.selfClosing(virtualBreakSlug);
                                result += tBranch.virtualBreakOpen + "\n";
                                result += innerDoc;
                                result += "\n" + tBranch.pairClose;
                            }
                            else {
                                result += tBranch.pairOpen;
                                result += "\n";
                                result += innerDoc;
                                result += "\n";
                                result += tBranch.pairClose;
                            }
                        }
                    }
                }
                transformedBranches.push(tBranch);
            });
            const pairOpen = transformedBranches[0].pairOpen, pairClose = transformedBranches[transformedBranches.length - 1].pairClose;
            const tCond = {
                pairOpen: pairOpen,
                pairClose: pairClose,
                structures: transformedBranches,
                condition: condition
            };
            this.registerCondition(tCond);
            return result;
        }
        if (this.dynamicElementConditions.has(condition.nodeContent)) {
            const existingSlug = this.dynamicElementConditions.get(condition.nodeContent);
            return existingSlug + ' ';
        }
        let slug = this.makeSlug(condition.nodeContent.length);
        if (((_a = condition.startPosition) === null || _a === void 0 ? void 0 : _a.line) != ((_b = condition.endPosition) === null || _b === void 0 ? void 0 : _b.line)) {
            slug = this.makeSlug(128);
        }
        this.registerDynamicElementCondition(slug, condition);
        if (condition.fragmentPosition == nodes_1.FragmentPosition.InsideFragmentParameter ||
            condition.fragmentPosition == nodes_1.FragmentPosition.InsideFragment) {
            if (condition.logicBranches.length > 0) {
                // Get the very last item.
                const lastBranch = condition.logicBranches[condition.logicBranches.length - 1];
                if (lastBranch.head != null && lastBranch.head.isClosedBy != null) {
                    // Check for distance between nodes.
                    if (lastBranch.head.isClosedBy.nextNode != null) {
                        const placementDiff = ((_d = (_c = lastBranch.head.isClosedBy.nextNode.startPosition) === null || _c === void 0 ? void 0 : _c.offset) !== null && _d !== void 0 ? _d : 0) - ((_f = (_e = lastBranch.head.isClosedBy.endPosition) === null || _e === void 0 ? void 0 : _e.offset) !== null && _f !== void 0 ? _f : 0);
                        if (lastBranch.head.isClosedBy.nextNode instanceof nodes_1.LiteralNode) {
                            const trailingLiteral = lastBranch.head.isClosedBy.nextNode;
                            if ((trailingLiteral.content.length - trailingLiteral.content.trimLeft().length) > 0) {
                                return slug;
                            }
                            else {
                                if (trailingLiteral.content.length == 0) {
                                    return slug;
                                }
                                else {
                                    const firstTrailingChar = trailingLiteral.content[0];
                                    if (stringUtilities_1.StringUtilities.ctypePunct(firstTrailingChar) || stringUtilities_1.StringUtilities.ctypeSpace(firstTrailingChar)) {
                                        return slug;
                                    }
                                    else {
                                        return slug + ' ';
                                    }
                                }
                            }
                        }
                        else {
                            if (placementDiff > 0) {
                                return slug + ' ';
                            }
                            else {
                                return slug;
                            }
                        }
                    }
                }
            }
            return slug;
        }
        return slug + ' ';
    }
    toStructure() {
        let result = '';
        if (attributeRangeRemover_1.canProcessAttributes && this.parentTransformer == null && Transformer.rootTransformer == null) {
            Transformer.rootTransformer = this;
        }
        if (attributeRangeRemover_1.canProcessAttributes && this.useLaravelPint) {
            if (this.parentTransformer == null) {
                this.pintTransformer = new pintTransformer_1.PintTransformer(this.transformOptions.pintTempDirectory, this.transformOptions.pintCacheDirectory, this.transformOptions.pintCommand, this.transformOptions.pintConfigPath);
                Transformer.sharedPintTransformer = this.pintTransformer;
                this.pintTransformer.setTemplateFilePath(this.filePath);
                // If the shadow document is available we will
                // use that instead. When this happens, it is
                // very likely that the "doc" we have access
                // to has been modified to accomodate things
                // like the formatting of AlpineJS attributes.
                if (this.shadowDoc != null) {
                    this.pintTransformer.format(this.shadowDoc);
                }
                else {
                    this.pintTransformer.format(this.doc);
                }
                this.didPintFail = this.pintTransformer.getDidFail();
            }
        }
        let nodes = this.doc.getRenderNodes();
        nodes.forEach((node) => {
            if (this.isInsideIgnoreFormatter) {
                this.pushLiteralBlock(this.activeLiteralSlug, node);
                if (node instanceof nodes_1.BladeCommentNode) {
                    if (node.innerContent.trim().toLowerCase() == transformIgnore_1.TransformIgnore.FormatIgnoreEnd) {
                        this.isInsideIgnoreFormatter = false;
                        return;
                    }
                }
                return;
            }
            if (node instanceof nodes_1.LiteralNode) {
                result += node.content;
            }
            else if (node instanceof nodes_1.SwitchStatementNode) {
                if (node.cases.length > 0) {
                    result += this.prepareSwitch(node);
                }
                else {
                    result += this.preparePairedDirective(node.constructedFrom);
                }
            }
            else if (node instanceof nodes_1.ConditionNode) {
                result += this.prepareConditions(node);
            }
            else if (node instanceof nodes_1.DirectiveNode) {
                result += this.prepareDirective(node);
            }
            else if (node instanceof nodes_1.BladeEchoNode) {
                result += this.prepareEcho(node);
            }
            else if (node instanceof nodes_1.ForElseNode) {
                result += this.prepareForElse(node);
            }
            else if (node instanceof nodes_1.BladeCommentNode) {
                if (node.innerContent.trim() == transformIgnore_1.TransformIgnore.FormatIgnoreStart) {
                    this.isInsideIgnoreFormatter = true;
                    this.activeLiteralSlug = this.makeSlug(16);
                    this.pushStartLiteralBlock(this.activeLiteralSlug, node);
                    result += this.selfClosing(this.activeLiteralSlug);
                }
                else {
                    result += this.prepareComment(node);
                }
            }
            else if (node instanceof nodes_1.BladeComponentNode) {
                result += this.prepareComponent(node);
            }
            else if (node instanceof nodes_1.InlinePhpNode) {
                result += this.preparePhpBlock(node);
            }
        });
        const structures = this.doc.getParser().getFragmentsContainingStructures();
        if (structures.length > 0) {
            const referenceDocument = bladeDocument_1.BladeDocument.fromText(result);
            structures.forEach((pair) => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                const ref = this.doc.getParser().getText(((_b = (_a = pair.start.endPosition) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0) + 1, (_d = (_c = pair.end.startPosition) === null || _c === void 0 ? void 0 : _c.offset) !== null && _d !== void 0 ? _d : 0), refOpen = referenceDocument.getParser().getFragmentsParser().getEmbeddedFragment(pair.start.embeddedIndex), refClose = referenceDocument.getParser().getFragmentsParser().getClosingFragmentAfter(refOpen), curRef = referenceDocument.getParser().getText(((_f = (_e = refOpen.endPosition) === null || _e === void 0 ? void 0 : _e.offset) !== null && _f !== void 0 ? _f : 0) + 1, (_h = (_g = refClose === null || refClose === void 0 ? void 0 : refClose.startPosition) === null || _g === void 0 ? void 0 : _g.offset) !== null && _h !== void 0 ? _h : 0), refSlug = this.makeSlug(16), isScript = pair.start.name.toLowerCase() == 'script';
                let replaceSlug = refSlug;
                if (isScript) {
                    replaceSlug = '//' + refSlug;
                }
                else {
                    replaceSlug = '/*' + refSlug + '*/';
                }
                result = result.replace(curRef, replaceSlug);
                this.registerEmbeddedDocument(refSlug, ref, isScript);
            });
        }
        return result;
    }
    withOptions(options) {
        this.transformOptions = options;
        this.useLaravelPint = this.transformOptions.useLaravelPint;
        return this;
    }
    transformInlineDirectives(content) {
        let value = content;
        this.inlineDirectiveBlocks.forEach((directive, slug) => {
            const search = this.selfClosing(slug), replace = this.printDirective(directive, this.indentLevel(search));
            value = stringUtilities_1.StringUtilities.safeReplace(value, search, replace);
        });
        return value;
    }
    transformHtmlTagDirectives(content) {
        let value = content;
        this.htmlTagDirectives.forEach((directive, slug) => {
            var _a;
            let formatContent = `${directive.sourceContent}
    ${directive.documentContent}
${(_a = directive.isClosedBy) === null || _a === void 0 ? void 0 : _a.sourceContent}
`;
            if (this.transformOptions.formatJsAttributes && attributeRangeRemover_1.isAttributeFormattingEnabled) {
                (0, attributeRangeRemover_1.setIsFormattingAttributeContent)(true);
                try {
                    (0, attributeRangeRemover_1.disableAttributeProcessing)();
                    if (this.transformOptions.useLaravelPint) {
                        formatContent = (0, utils_1.formatBladeStringWithPint)(formatContent, this.formattingOptions, this.transformOptions).trim();
                    }
                    else {
                        formatContent = (0, utils_1.formatBladeString)(formatContent, this.formattingOptions).trim();
                    }
                }
                catch (err) {
                    (0, attributeRangeRemover_1.enableAttributeProcessing)();
                    (0, attributeRangeRemover_1.setIsFormattingAttributeContent)(false);
                    throw err;
                }
            }
            (0, attributeRangeRemover_1.enableAttributeProcessing)();
            (0, attributeRangeRemover_1.setIsFormattingAttributeContent)(false);
            const indentLevel = indentLevel_1.IndentLevel.relativeIndentLevel(slug, value);
            formatContent = this.adjustAttributeFormattingResults(formatContent);
            formatContent = indentLevel_1.IndentLevel.shiftIndent(formatContent, indentLevel, true, this.transformOptions, false, false);
            value = stringUtilities_1.StringUtilities.safeReplace(value, slug, formatContent);
        });
        return value;
    }
    transformContentDirectives(content) {
        let value = content;
        this.contentDirectives.forEach((directive, slug) => {
            let directiveResult = this.printDirective(directive, 0);
            if (directiveResult.includes("\n")) {
                const relativeIndent = this.indentLevel(slug);
                if (relativeIndent > 0) {
                    directiveResult = indentLevel_1.IndentLevel.shiftIndent(directiveResult, relativeIndent, true, this.transformOptions);
                }
            }
            value = stringUtilities_1.StringUtilities.safeReplace(value, slug, directiveResult);
        });
        return value;
    }
    transformDynamicEcho(content) {
        let value = content;
        this.dynamicEchoBlocks.forEach((echo, slug) => {
            var _a;
            const echoContent = echoPrinter_1.EchoPrinter.printEcho(echo, this.transformOptions, this.phpFormatter, this.indentLevel(slug), (_a = this.pintTransformer) !== null && _a !== void 0 ? _a : Transformer.sharedPintTransformer);
            value = stringUtilities_1.StringUtilities.safeReplaceAllInString(value, slug, echoContent);
        });
        return value;
    }
    transformDynamicDirectives(content) {
        let value = content;
        this.dynamicElementDirectiveNodes.forEach((directive, slug) => {
            const directiveContent = this.printDirective(directive, this.indentLevel(slug));
            value = stringUtilities_1.StringUtilities.safeReplaceAllInString(value, slug, directiveContent);
        });
        return value;
    }
    transformBlockPhp(content, withNewLine) {
        if (this.blockPhpFormatter == null) {
            return content;
        }
        let value = content.trim();
        if (value.startsWith('<?php') == false) {
            value = '<?php ' + value;
        }
        const phpOptions = (0, utils_1.getPhpOptions)();
        value = this.blockPhpFormatter(value, this.transformOptions, {
            ...phpOptions,
            printWidth: (0, printWidthUtils_1.getPrintWidth)(content, phpOptions.printWidth)
        });
        if (withNewLine) {
            value = "\n" + value + "\n";
        }
        if (generalSyntaxReflow_1.GeneralSyntaxReflow.couldReflow(value)) {
            value = generalSyntaxReflow_1.GeneralSyntaxReflow.instance.reflow(value);
        }
        if (syntaxReflow_1.SyntaxReflow.couldReflow(value)) {
            value = syntaxReflow_1.SyntaxReflow.instance.reflow(value);
        }
        return value;
    }
    removeLeadingWhitespace(source, substring) {
        const index = source.indexOf(substring);
        if (index === -1) {
            return source;
        }
        const beforeSubstring = source.slice(0, index);
        const afterSubstring = source.slice(index + substring.length);
        const trimmedBefore = beforeSubstring.replace(/[\s\uFEFF\xA0]+$/g, '');
        return trimmedBefore + substring + afterSubstring;
    }
    findNewLeadingStart(content, substring) {
        const lines = stringUtilities_1.StringUtilities.breakByNewLine(content);
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (line.includes(substring)) {
                return line.length - line.trim().length;
            }
        }
        return -1;
    }
    transformPairedDirectives(content) {
        let value = content;
        this.attachedDirectives.forEach((directive, slug) => {
            var _a, _b;
            value = this.removeLeadingWhitespace(value, slug);
            let attachedDoc = directive.directive.documentContent;
            (0, attributeRangeRemover_1.disableAttributeProcessing)();
            if (this.transformOptions.useLaravelPint) {
                attachedDoc = (0, utils_1.formatBladeStringWithPint)(attachedDoc, this.formattingOptions, this.transformOptions).trim();
            }
            else {
                attachedDoc = (0, utils_1.formatBladeString)(attachedDoc, this.formattingOptions).trim();
            }
            (0, attributeRangeRemover_1.enableAttributeProcessing)();
            const dirResult = this.printDirective(directive.directive, this.indentLevel(slug)).trim(), relIndent = this.findNewLeadingStart(value, slug), tmpDoc = (_b = dirResult + attachedDoc + "\n" + ((_a = directive.directive.isClosedBy) === null || _a === void 0 ? void 0 : _a.sourceContent)) !== null && _b !== void 0 ? _b : '';
            let insertResult = indentLevel_1.IndentLevel.shiftIndent(tmpDoc, relIndent + this.transformOptions.tabSize, true, this.transformOptions, false, true);
            value = stringUtilities_1.StringUtilities.safeReplace(value, slug, insertResult);
        });
        this.pairedDirectives.forEach((directive, slug) => {
            var _a, _b, _c;
            const originalDirective = directive.directive;
            if (directive.virtualElementSlug.length > 0) {
                const open = this.open(directive.virtualElementSlug), close = this.close(directive.virtualElementSlug);
                this.virtualStructureOpens.push(open);
                this.removeLines.push(open);
                this.removeLines.push(close);
            }
            const open = this.open(slug), close = this.close(slug);
            let placeClosingDirective = true;
            if (originalDirective.directiveName.trim().toLowerCase() == 'php') {
                const virtualOpen = this.open(directive.virtualElementSlug), targetIndent = this.indentLevel(virtualOpen), replacePhp = directive.directive.sourceContent;
                let formattedPhp = originalDirective.documentContent;
                if (this.transformOptions.formatDirectivePhpParameters) {
                    if (!this.useLaravelPint) {
                        formattedPhp = indentLevel_1.IndentLevel.shiftIndent(this.transformBlockPhp(originalDirective.innerContent, true), targetIndent, true, this.transformOptions);
                        value = stringUtilities_1.StringUtilities.safeReplace(value, open, replacePhp);
                        value = stringUtilities_1.StringUtilities.safeReplace(value, virtualOpen, formattedPhp);
                    }
                    else {
                        if (this.pintTransformer != null || Transformer.sharedPintTransformer != null) {
                            if (this.pintTransformer != null) {
                                formattedPhp = this.pintTransformer.getDirectivePhpContent(originalDirective).trim();
                            }
                            else if (Transformer.sharedPintTransformer != null) {
                                formattedPhp = Transformer.sharedPintTransformer.getDirectivePhpContent(originalDirective).trim();
                            }
                            const lines = stringUtilities_1.StringUtilities.breakByNewLine(formattedPhp), reflow = [];
                            for (let i = 0; i < lines.length; i++) {
                                if (lines[i].trim().length == 0) {
                                    reflow.push('');
                                    continue;
                                }
                                reflow.push(' '.repeat(targetIndent) + lines[i]);
                            }
                            formattedPhp = reflow.join("\n");
                            value = stringUtilities_1.StringUtilities.safeReplace(value, open, replacePhp + "\n" + formattedPhp);
                            value = stringUtilities_1.StringUtilities.safeReplace(value, virtualOpen, '');
                        }
                        else {
                            value = stringUtilities_1.StringUtilities.safeReplace(value, open, replacePhp);
                            value = stringUtilities_1.StringUtilities.safeReplace(value, virtualOpen, formattedPhp);
                        }
                    }
                }
                else {
                    value = stringUtilities_1.StringUtilities.safeReplace(value, open, replacePhp + "\n" + formattedPhp);
                    value = stringUtilities_1.StringUtilities.safeReplace(value, virtualOpen, '');
                }
            }
            else if (originalDirective.directiveName.trim().toLowerCase() == 'verbatim') {
                if (originalDirective.isClosedBy != null && ((_a = originalDirective.startPosition) === null || _a === void 0 ? void 0 : _a.line) == ((_b = originalDirective.isClosedBy.startPosition) === null || _b === void 0 ? void 0 : _b.line)) {
                    value = stringUtilities_1.StringUtilities.safeReplace(value, open, directive.directive.nodeContent);
                    placeClosingDirective = false;
                }
                else {
                    const replaceVerbatim = directive.directive.sourceContent + "\n" + indentLevel_1.IndentLevel.shiftClean(originalDirective.innerContent, this.transformOptions.tabSize);
                    value = stringUtilities_1.StringUtilities.safeReplace(value, open, replaceVerbatim);
                }
            }
            else {
                value = stringUtilities_1.StringUtilities.safeReplace(value, open, this.printDirective(directive.directive, this.indentLevel(open)));
            }
            if (placeClosingDirective) {
                value = stringUtilities_1.StringUtilities.safeReplace(value, close, (_c = directive.directive.isClosedBy) === null || _c === void 0 ? void 0 : _c.sourceContent);
            }
            else {
                value = stringUtilities_1.StringUtilities.safeReplace(value, close, '');
            }
        });
        this.inlineDirectives.forEach((directive, slug) => {
            value = stringUtilities_1.StringUtilities.safeReplaceAllInString(value, slug, directive.directive.nodeContent);
        });
        return value;
    }
    transformForElseWithNoEmpty(content) {
        let value = content;
        this.forElseNoEmpty.forEach((forElse) => {
            var _a;
            const construction = forElse.forElse.constructedFrom, open = this.open(forElse.truthSlug), close = this.close(forElse.truthSlug), openContent = this.printDirective(construction, this.indentLevel(open)), closeContent = (_a = construction.isClosedBy) === null || _a === void 0 ? void 0 : _a.sourceContent;
            value = stringUtilities_1.StringUtilities.safeReplace(value, open, openContent);
            value = stringUtilities_1.StringUtilities.safeReplace(value, close, closeContent);
        });
        return value;
    }
    transformForElseWithEmpty(content) {
        let value = content;
        this.forElseWithEmpty.forEach((forElse) => {
            var _a, _b;
            const truthOpen = this.open(forElse.truthSlug), construction = forElse.forElse.constructedFrom, constructionContent = this.printDirective(construction, this.indentLevel(truthOpen));
            value = stringUtilities_1.StringUtilities.safeReplace(value, truthOpen, constructionContent);
            value = stringUtilities_1.StringUtilities.safeReplace(value, forElse.pairClose, (_a = construction.isClosedBy) === null || _a === void 0 ? void 0 : _a.sourceContent);
            value = stringUtilities_1.StringUtilities.safeReplace(value, forElse.emptyOpen, (_b = forElse.forElse.elseNode) === null || _b === void 0 ? void 0 : _b.sourceContent);
            this.removeLines.push(forElse.truthClose);
        });
        return value;
    }
    transformInlineEcho(content) {
        let value = content;
        this.inlineEchos.forEach((echo, slug) => {
            var _a;
            const inline = this.selfClosing(slug);
            value = stringUtilities_1.StringUtilities.safeReplace(value, inline, echoPrinter_1.EchoPrinter.printEcho(echo, this.transformOptions, this.phpFormatter, this.indentLevel(slug), (_a = this.pintTransformer) !== null && _a !== void 0 ? _a : Transformer.sharedPintTransformer));
        });
        this.spanEchos.forEach((echo, slug) => {
            var _a;
            value = stringUtilities_1.StringUtilities.safeReplace(value, slug, echoPrinter_1.EchoPrinter.printEcho(echo, this.transformOptions, this.phpFormatter, this.indentLevel(slug), (_a = this.pintTransformer) !== null && _a !== void 0 ? _a : Transformer.sharedPintTransformer));
        });
        return value;
    }
    pushStartLiteralBlock(slug, node) {
        var _a;
        if (this.parentTransformer != null) {
            this.parentTransformer.pushStartLiteralBlock(slug, node);
        }
        else {
            this.ignoredLiteralBlocks.set(slug, []);
            (_a = this.ignoredLiteralBlocks.get(slug)) === null || _a === void 0 ? void 0 : _a.push(node);
        }
    }
    pushLiteralBlock(slug, node) {
        var _a;
        if (this.parentTransformer != null) {
            this.parentTransformer.pushLiteralBlock(slug, node);
        }
        else {
            (_a = this.ignoredLiteralBlocks.get(slug)) === null || _a === void 0 ? void 0 : _a.push(node);
        }
    }
    transformConditions(content) {
        let value = content;
        this.conditions.forEach((condition) => {
            condition.structures.forEach((structure) => {
                const structureDirective = structure.branch.head;
                if (structure.isLiteralContent) {
                    value = stringUtilities_1.StringUtilities.safeReplace(value, structure.virtualBreakOpen, structure.doc.trim());
                }
                if (structure.virtualBreakOpen.length > 0) {
                    this.removeLines.push(structure.virtualBreakOpen);
                }
                if (structure.virtualBreakClose.length > 0) {
                    value = stringUtilities_1.StringUtilities.safeReplace(value, structure.virtualBreakClose, structure.virtualBreakClose + "\n");
                    this.removeLines.push(structure.virtualBreakClose);
                }
                this.virtualStructureOpens.push(structure.virtualOpen);
                this.removeLines.push(structure.virtualOpen);
                this.removeLines.push(structure.virtualClose);
                if (!structure.isLast) {
                    this.removeLines.push(structure.pairClose);
                    value = stringUtilities_1.StringUtilities.safeReplace(value, structure.pairOpen, this.printDirective(structureDirective, this.indentLevel(structure.pairOpen)));
                }
                else {
                    value = stringUtilities_1.StringUtilities.safeReplace(value, structure.pairOpen, this.printDirective(structureDirective, this.indentLevel(structure.pairOpen)));
                    const closeDirective = structureDirective.isClosedBy;
                    value = stringUtilities_1.StringUtilities.safeReplace(value, structure.pairClose, this.printDirective(closeDirective, this.indentLevel(structure.pairClose)));
                }
            });
        });
        return value;
    }
    transformSwitchStatements(content) {
        let value = content;
        this.switchStatements.forEach((switchStatement) => {
            const open = switchStatement.switchNode.constructedFrom;
            value = stringUtilities_1.StringUtilities.safeReplace(value, switchStatement.virtualSwitchOpen, this.printDirective(open, this.indentLevel(switchStatement.virtualSwitchOpen)));
            const closeDirective = open.isClosedBy;
            value = stringUtilities_1.StringUtilities.safeReplace(value, switchStatement.virtualSwitchClose, closeDirective.sourceContent);
            switchStatement.structures.forEach((structure) => {
                const structureDirective = structure.case.head;
                this.removeLines.push(structure.virtualClose);
                this.removeLines.push(structure.virtualOpen);
                if (!structure.isLast) {
                    if (structure.isFirst) {
                        this.removeLines.push(structure.pairClose);
                        value = stringUtilities_1.StringUtilities.safeReplace(value, structure.pairOpen, this.printDirective(structureDirective, this.indentLevel(structure.pairOpen)));
                    }
                    else {
                        this.removeLines.push(structure.pairClose);
                        value = stringUtilities_1.StringUtilities.safeReplace(value, structure.pairOpen, this.printDirective(structureDirective, this.indentLevel(structure.pairOpen)));
                    }
                }
                else {
                    value = stringUtilities_1.StringUtilities.safeReplace(value, structure.pairOpen, this.printDirective(structureDirective, this.indentLevel(structure.pairOpen)));
                    this.removeLines.push(structure.pairClose);
                }
            });
        });
        return value;
    }
    transformProps(content) {
        let value = content;
        this.propDirectives.forEach((directive, slug) => {
            const close = this.close(slug), open = this.open(slug);
            this.removeLines.push(close);
            let content = directive.sourceContent;
            try {
                if (this.transformOptions.formatDirectivePhpParameters) {
                    if (!this.useLaravelPint) {
                        if (this.phpFormatter != null && directive.hasValidPhp()) {
                            let params = directive.getPhpContent().trim();
                            if (params.startsWith('(') && params.endsWith(')')) {
                                params = params.substring(1);
                                params = params.substring(0, params.length - 1);
                            }
                            let tResult = this.phpFormatter('<?php ' + params, this.transformOptions, null);
                            const arrayParser = new simpleArrayParser_1.SimpleArrayParser(), array = arrayParser.parse(stringUtilities_1.StringUtilities.safeReplaceAllInString(tResult, "\n", ' ')), targetIndent = this.indentLevel(open);
                            if (arrayParser.getIsAssoc()) {
                                content = '@props' + ' '.repeat(this.transformOptions.spacesAfterDirective) + '(' + tResult + ')';
                            }
                            else {
                                if (array != null) {
                                    tResult = arrayPrinter_1.ArrayPrinter.print(array, this.transformOptions.tabSize, 1);
                                    if (targetIndent > 0) {
                                        tResult = stringUtilities_1.StringUtilities.removeEmptyNewLines(indentLevel_1.IndentLevel.shiftIndent(tResult, targetIndent, true, this.transformOptions));
                                    }
                                    content = '@props' + ' '.repeat(this.transformOptions.spacesAfterDirective) + '(' + tResult + ')';
                                }
                            }
                        }
                    }
                    else {
                        content = this.printDirective(directive, this.indentLevel(open));
                    }
                }
            }
            catch (err) {
                content = directive.sourceContent;
            }
            value = stringUtilities_1.StringUtilities.safeReplace(value, open, content);
        });
        return value;
    }
    transformBreaks(content) {
        let value = content;
        this.breakDirectives.forEach((directive, slug) => {
            const close = this.close(slug), open = this.open(slug);
            this.removeLines.push(close);
            value = stringUtilities_1.StringUtilities.safeReplace(value, open, directive.sourceContent);
        });
        return value;
    }
    transformComments(content) {
        let value = content;
        this.inlineComments.forEach((comment, slug) => {
            const open = this.selfClosing(slug);
            value = stringUtilities_1.StringUtilities.safeReplace(value, open, commentPrinter_1.CommentPrinter.printComment(comment, this.transformOptions.tabSize, 0));
        });
        this.htmlTagComments.forEach((comment, slug) => {
            value = stringUtilities_1.StringUtilities.safeReplace(value, slug, commentPrinter_1.CommentPrinter.printComment(comment, this.transformOptions.tabSize, 0));
        });
        return value;
    }
    indentLevel(value) {
        for (let i = 0; i < this.structureLines.length; i++) {
            const thisLine = this.structureLines[i];
            if (thisLine.includes(value)) {
                const trimmed = thisLine.trimLeft();
                return thisLine.length - trimmed.length;
            }
        }
        return 0;
    }
    transformVirtualComments(content) {
        let value = content;
        this.blockComments.forEach((structure) => {
            const comment = structure.node;
            value = stringUtilities_1.StringUtilities.safeReplace(value, structure.pairOpen, commentPrinter_1.CommentPrinter.printComment(comment, this.transformOptions.tabSize, this.indentLevel(structure.pairOpen)));
            this.removeLines.push(structure.pairClose);
            this.removeLines.push(structure.virtualElement);
        });
        return value;
    }
    adjustAttributeFormattingResults(content) {
        const lines = stringUtilities_1.StringUtilities.breakByNewLine(content), newLines = [];
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (line.trimRight().endsWith(':') && i + 1 < lines.length - 1) {
                newLines.push(line.trimRight() + ' ' + lines[i + 1].trimLeft());
                i += 1;
                continue;
            }
            else {
                newLines.push(line);
            }
        }
        return newLines.join("\n");
    }
    transformDynamicElementForElse(content) {
        let value = content;
        this.dynamicElementForElseNodes.forEach((forElse, slug) => {
            value = stringUtilities_1.StringUtilities.safeReplaceAllInString(value, slug, forElse.nodeContent);
        });
        return value;
    }
    removeTrailingWhitespaceAfterSubstring(source, substring) {
        const lines = stringUtilities_1.StringUtilities.breakByNewLine(source), newLines = [];
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (line.trimRight().endsWith(substring)) {
                newLines.push(line.trimRight());
            }
            else {
                newLines.push(line);
            }
        }
        return newLines.join("\n");
    }
    transformDynamicElementConditions(content) {
        let value = content;
        this.dynamicElementConditionNodes.forEach((condition, slug) => {
            var _a, _b;
            if (((_a = condition.startPosition) === null || _a === void 0 ? void 0 : _a.line) != ((_b = condition.endPosition) === null || _b === void 0 ? void 0 : _b.line)) {
                let formatContent = condition.nodeContent;
                if (this.transformOptions.formatJsAttributes && attributeRangeRemover_1.isAttributeFormattingEnabled) {
                    (0, attributeRangeRemover_1.disableAttributeProcessing)();
                    (0, attributeRangeRemover_1.setIsFormattingAttributeContent)(true);
                    try {
                        if (this.transformOptions.useLaravelPint) {
                            formatContent = (0, utils_1.formatBladeStringWithPint)(formatContent, this.formattingOptions, this.transformOptions).trim();
                        }
                        else {
                            formatContent = (0, utils_1.formatBladeString)(formatContent, this.formattingOptions).trim();
                        }
                    }
                    catch (err) {
                        (0, attributeRangeRemover_1.enableAttributeProcessing)();
                        (0, attributeRangeRemover_1.setIsFormattingAttributeContent)(false);
                        throw err;
                    }
                    (0, attributeRangeRemover_1.enableAttributeProcessing)();
                    (0, attributeRangeRemover_1.setIsFormattingAttributeContent)(false);
                }
                const indentLevel = indentLevel_1.IndentLevel.relativeIndentLevel(slug, value);
                formatContent = this.adjustAttributeFormattingResults(formatContent);
                formatContent = indentLevel_1.IndentLevel.shiftIndent(formatContent, indentLevel, true, this.transformOptions, false, false);
                value = stringUtilities_1.StringUtilities.safeReplaceAllInString(value, slug, formatContent);
            }
            else {
                value = this.removeTrailingWhitespaceAfterSubstring(value, slug);
                value = stringUtilities_1.StringUtilities.safeReplaceAllInString(value, slug, condition.nodeContent);
            }
        });
        return value;
    }
    transformDynamicElementSwitch(content) {
        let value = content;
        this.dynamicElementSwitchNodes.forEach((switchNode, slug) => {
            value = stringUtilities_1.StringUtilities.safeReplaceAllInString(value, slug, switchNode.nodeContent);
        });
        return value;
    }
    transformDirectiveParameters(content) {
        let value = content;
        this.directiveParameters.forEach((param, slug) => {
            const paramDirective = param.directive;
            value = stringUtilities_1.StringUtilities.safeReplace(value, slug, this.printDirective(paramDirective, this.indentLevel(slug)));
        });
        return value;
    }
    transformExpressionParameters(content) {
        let value = content;
        this.expressionParameters.forEach((param, slug) => {
            let content = param.content;
            if (this.transformOptions.useLaravelPint && (this.pintTransformer != null || Transformer.sharedPintTransformer != null)) {
                if (this.pintTransformer != null) {
                    content = this.pintTransformer.getComponentParameterContent(param);
                }
                else if (Transformer.sharedPintTransformer != null) {
                    content = Transformer.sharedPintTransformer.getComponentParameterContent(param);
                }
            }
            if (content.includes("\n")) {
                const relativeIndent = this.indentLevel(slug);
                content = indentLevel_1.IndentLevel.shiftIndent(content, relativeIndent + this.transformOptions.tabSize, true, this.transformOptions, false, true);
            }
            value = stringUtilities_1.StringUtilities.safeReplace(value, slug, content);
        });
        return value;
    }
    transformEchoParameters(content) {
        let value = content;
        this.commentParameters.forEach((param, slug) => {
            if (param.inlineComment != null) {
                value = stringUtilities_1.StringUtilities.safeReplace(value, slug, commentPrinter_1.CommentPrinter.printComment(param.inlineComment, this.transformOptions.tabSize, 0));
            }
            else {
                value = stringUtilities_1.StringUtilities.safeReplace(value, slug, '');
            }
        });
        this.echoParameters.forEach((param, slug) => {
            var _a;
            if (param.inlineEcho != null) {
                const checkContent = param.inlineEcho.content.trim();
                // Handle case of comments (this shouldn't happen anymore, but will leave it for now.)
                if (checkContent.startsWith('{{--') && checkContent.endsWith('--}}')) {
                    let commentContent = checkContent.substring(2, checkContent.length - 2);
                    value = stringUtilities_1.StringUtilities.safeReplace(value, slug, '{{' + commentContent.trim() + '}}');
                    return;
                }
                else if (checkContent.startsWith('{--') && checkContent.endsWith('--}')) {
                    let commentContent = checkContent.substring(3, checkContent.length - 3);
                    value = stringUtilities_1.StringUtilities.safeReplace(value, slug, '{{-- ' + commentContent.trim() + ' --}}');
                    return;
                }
                else if (checkContent.startsWith('--') && checkContent.endsWith('--')) {
                    let commentContent = checkContent.substring(2, checkContent.length - 2);
                    value = stringUtilities_1.StringUtilities.safeReplace(value, slug, '{{-- ' + commentContent.trim() + ' --}}');
                    return;
                }
                value = stringUtilities_1.StringUtilities.safeReplace(value, slug, echoPrinter_1.EchoPrinter.printEcho(param.inlineEcho, this.transformOptions, this.phpFormatter, 0, (_a = this.pintTransformer) !== null && _a !== void 0 ? _a : Transformer.sharedPintTransformer));
            }
            else {
                value = stringUtilities_1.StringUtilities.safeReplace(value, slug, '');
            }
        });
        return value;
    }
    transformEmbeddedEcho(content) {
        let value = content;
        this.embeddedEchos.forEach((echo, slug) => {
            var _a;
            let indentLevel = this.indentLevel(slug);
            if (indentLevel == 0) {
                indentLevel = this.transformOptions.tabSize;
            }
            value = stringUtilities_1.StringUtilities.safeReplace(value, slug, echoPrinter_1.EchoPrinter.printEcho(echo, this.transformOptions, this.phpFormatter, indentLevel, (_a = this.pintTransformer) !== null && _a !== void 0 ? _a : Transformer.sharedPintTransformer));
        });
        this.dynamicAttributeEchoBlocks.forEach((echo, slug) => {
            var _a;
            let indentLevel = this.indentLevel(slug), targetReplace = `${slug}="${slug}"`;
            if (indentLevel == 0) {
                indentLevel = this.transformOptions.tabSize;
            }
            value = stringUtilities_1.StringUtilities.safeReplace(value, targetReplace, echoPrinter_1.EchoPrinter.printEcho(echo, this.transformOptions, this.phpFormatter, indentLevel, (_a = this.pintTransformer) !== null && _a !== void 0 ? _a : Transformer.sharedPintTransformer));
        });
        return value;
    }
    transformEmbeddedDirectives(content) {
        let value = content;
        this.embeddedDirectives.forEach((directive, slug) => {
            let targetIndent = this.indentLevel(slug);
            if (targetIndent == 0 && directive.sourceContent.includes("\n")) {
                targetIndent = indentLevel_1.IndentLevel.relativeIndentLevel(slug, value) + (2 * this.transformOptions.tabSize);
            }
            value = stringUtilities_1.StringUtilities.safeReplace(value, slug, this.printDirective(directive, targetIndent));
        });
        return value;
    }
    transformExtractedDocuments(content) {
        let value = content;
        this.extractedEmbeddedDocuments.forEach((document, slug) => {
            let target = '', indent = 0;
            if (document.isScript) {
                target = '//' + slug;
            }
            else {
                target = '/*' + slug + '*/';
            }
            indent = this.indentLevel(target);
            if (indent == this.transformOptions.tabSize) {
                indent = 0;
            }
            if (value.includes(target)) {
                value = stringUtilities_1.StringUtilities.safeReplace(value, target, indentLevel_1.IndentLevel.indentRelative(document.content, indent, this.transformOptions.tabSize));
            }
        });
        return value;
    }
    removeVirtualStructures(content) {
        let value = content;
        this.removeLines.forEach((line) => {
            value = stringUtilities_1.StringUtilities.safeReplace(value, line, '');
        });
        return value;
    }
    shouldCleanAfter(line) {
        for (let i = 0; i < this.removeLines.length; i++) {
            if (line.startsWith(this.removeLines[i])) {
                return true;
            }
        }
        return false;
    }
    shouldCleanLine(line) {
        for (let i = 0; i < this.forceCleanLines.length; i++) {
            if (line.startsWith(this.forceCleanLines[i])) {
                return true;
            }
        }
        return false;
    }
    cleanVirtualStructures(content) {
        const newLines = [], contentLines = stringUtilities_1.StringUtilities.breakByNewLine(content);
        let removeNewLines = false;
        for (let i = 0; i < contentLines.length; i++) {
            const checkLine = contentLines[i].trim();
            if (removeNewLines) {
                if (checkLine.length == 0) {
                    continue;
                }
                else {
                    removeNewLines = false;
                }
            }
            else {
                removeNewLines = this.shouldCleanAfter(checkLine);
            }
            if (this.shouldCleanLine(checkLine)) {
                for (let j = newLines.length - 1; j > 0; j--) {
                    const tLine = newLines[j];
                    if (tLine.trim().length == 0) {
                        newLines.pop();
                    }
                    else {
                        break;
                    }
                }
            }
            if (this.removeLines.includes(checkLine)) {
                continue;
            }
            else {
                let newLine = contentLines[i];
                this.removeLines.forEach((line) => {
                    if (newLine.includes(line)) {
                        newLine = stringUtilities_1.StringUtilities.safeReplace(newLine, line, '');
                    }
                });
                newLines.push(newLine);
            }
        }
        return newLines.join("\n");
    }
    reflowSlugs(content) {
        let result = content;
        const rLines = stringUtilities_1.StringUtilities.breakByNewLine(result);
        const newLines = [];
        for (let i = 0; i < rLines.length; i++) {
            const rLine = rLines[i].trimRight();
            let added = false;
            for (let j = 0; j < this.slugs.length; j++) {
                const slug = this.slugs[j];
                if (rLine.endsWith('<' + slug) && i + 1 < rLines.length) {
                    const nLine = rLines[i + 1];
                    if (nLine.trimLeft().startsWith('/>')) {
                        const breakOn = nLine.indexOf('/>');
                        const nLineAfter = nLine.substring(breakOn + 2);
                        newLines.push(rLine.trimRight() + ' />');
                        const reflowCount = rLine.indexOf('<' + slug);
                        newLines.push(' '.repeat(reflowCount) + nLineAfter.trimLeft());
                        i += 1;
                        added = true;
                        break;
                    }
                }
            }
            if (!added) {
                newLines.push(rLine);
            }
        }
        result = newLines.join("\n");
        this.slugs.forEach((slug) => {
            const open = this.open(slug), close = this.close(slug), selfClose = this.selfClosing(slug), openRegex = '/<' + slug + '(.*?)>/gms', closeRegex = '/</' + slug + '(.*?)>/gms', selfCloseRegex = '/<' + slug + '(.*?)/>/gms';
            result = result.replace(openRegex, open);
            result = result.replace(closeRegex, close);
            result = result.replace(selfCloseRegex, selfClose);
        });
        return result;
    }
    transformRemovedAttibutes(content) {
        let result = content;
        this.removedAttributes.forEach((attribute, slug) => {
            const attributeResult = (0, bladeJavaScriptFormatter_1.formatExtractedScript)(attribute, this.transformOptions, slug, result, this, this.doc);
            result = stringUtilities_1.StringUtilities.safeReplace(result, '"' + slug + '"', attributeResult);
        });
        return result;
    }
    fromStructure(content) {
        if (this.didPintFail) {
            if (this.shadowDoc != null) {
                return this.shadowDoc.getContent();
            }
            return this.doc.getContent();
        }
        const reflowedContent = this.reflowSlugs(content);
        this.structureLines = stringUtilities_1.StringUtilities.breakByNewLine(reflowedContent);
        // Dynamic blocks might be hiding some attributes. We need to restore
        // those first before transforming the removed attributes safely.
        let results = this.transformDynamicElementConditions(reflowedContent);
        results = this.transformDynamicEcho(results);
        results = this.transformDynamicElementForElse(results);
        results = this.transformDynamicElementSwitch(results);
        results = this.transformDynamicDirectives(results);
        results = this.transformHtmlTagDirectives(results);
        results = this.transformRemovedAttibutes(results);
        if (this.parentTransformer == null && voidHtmlTagsManager_1.VoidHtmlTagsManager.voidTagMapping.size > 0) {
            voidHtmlTagsManager_1.VoidHtmlTagsManager.voidTagMapping.forEach((htmlTag, slug) => {
                results = stringUtilities_1.StringUtilities.safeReplaceAllInString(results, slug, htmlTag);
            });
        }
        return this.transformStructures(results);
    }
    containsRemovedAttributes(content) {
        if (this.removedAttributes.size == 0) {
            return false;
        }
        const attributeRegions = Array.from(this.removedAttributes.keys());
        for (let i = 0; i < attributeRegions.length; i++) {
            const region = attributeRegions[i];
            if (content.includes(region)) {
                return true;
            }
        }
        return false;
    }
    transformStructures(content) {
        let results = content;
        results = this.transformInlineDirectives(results);
        results = this.transformContentDirectives(results);
        results = this.transformDynamicEcho(results);
        results = this.transformPairedDirectives(results);
        results = this.transformForElseWithEmpty(results);
        results = this.transformForElseWithNoEmpty(results);
        results = this.transformDynamicElementForElse(results);
        results = this.transformInlineEcho(results);
        results = this.transformConditions(results);
        results = this.transformDynamicElementConditions(results);
        results = this.transformSwitchStatements(results);
        results = this.transformDynamicElementSwitch(results);
        results = this.transformBreaks(results);
        results = this.transformProps(results);
        results = this.transformComments(results);
        results = this.transformVirtualComments(results);
        results = this.transformDirectiveParameters(results);
        results = this.transformExpressionParameters(results);
        results = this.transformEchoParameters(results);
        results = this.transformDynamicDirectives(results);
        results = this.cleanVirtualStructures(results);
        results = this.removeVirtualStructures(results);
        results = this.transformEmbeddedEcho(results);
        results = this.transformEmbeddedDirectives(results);
        results = this.transformExtractedDocuments(results);
        results = this.transformPhpBlock(results);
        results = this.transformComponentSlots(results);
        if (this.ignoredLiteralBlocks.size > 0) {
            this.ignoredLiteralBlocks.forEach((nodes, slug) => {
                const replace = this.selfClosing(slug);
                results = stringUtilities_1.StringUtilities.safeReplace(results, replace, this.dumpPreservedNodes(nodes));
            });
            if (this.removedAttributes.size > 0) {
                this.removedAttributes.forEach((attribute, slug) => {
                    const contentToInsert = attribute.content.substring(1, attribute.content.length - 1);
                    results = stringUtilities_1.StringUtilities.safeReplace(results, slug, contentToInsert);
                });
            }
        }
        if (this.parentTransformer === null && attributeRangeRemover_1.canProcessAttributes) {
            Transformer.sharedPintTransformer = null;
            Transformer.rootTransformer = null;
            Transformer.inlineComments = [];
        }
        return results;
    }
    dumpPreservedNodes(nodes) {
        let stringResults = '';
        nodes.forEach((node) => {
            if (node instanceof nodes_1.LiteralNode) {
                stringResults += node.content;
            }
            else if (node instanceof nodes_1.SwitchStatementNode) {
                stringResults += node.nodeContent;
            }
            else if (node instanceof nodes_1.ConditionNode) {
                stringResults += node.nodeContent;
            }
            else if (node instanceof nodes_1.DirectiveNode) {
                stringResults += node.sourceContent;
            }
            else if (node instanceof nodes_1.BladeEchoNode) {
                stringResults += node.sourceContent;
            }
            else if (node instanceof nodes_1.ForElseNode) {
                stringResults += node.nodeContent;
            }
            else if (node instanceof nodes_1.BladeCommentNode) {
                stringResults += node.sourceContent;
            }
            else if (node instanceof nodes_1.BladeComponentNode) {
                stringResults += node.sourceContent;
            }
            else if (node instanceof nodes_1.InlinePhpNode) {
                stringResults += node.sourceContent;
            }
        });
        return stringResults;
    }
}
exports.Transformer = Transformer;
Transformer.sharedPintTransformer = null;
Transformer.rootTransformer = null;
Transformer.inlineComments = [];
//# sourceMappingURL=transformer.js.map