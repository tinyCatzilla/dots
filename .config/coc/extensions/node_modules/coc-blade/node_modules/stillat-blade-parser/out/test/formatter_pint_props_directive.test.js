"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("../formatting/prettier/utils");
suite('Pint Transformer: Props Directive', () => {
    test('pint: it can format props on many lines', () => {
        assert_1.default.strictEqual((0, utils_1.formatBladeStringWithPint)(`<x-icon


            :class="Arr::toCssClasses(['...'])" 
            
            
            
            
            />

@props(

       [          
         'icon'

                   ]
       
       
       )

<div>
<x-icon                      @class([$icon, "pe-2"] )
                                   />
           {{ $slot +   !$something}}



           
       </div>`).trim(), `<x-icon :class="Arr::toCssClasses(['...'])" />

@props([
    'icon',

])

<div>
    <x-icon @class([$icon, 'pe-2']) />
    {{ $slot + ! $something }}
</div>`);
    });
    test('pint: it formats document with props', () => {
        assert_1.default.strictEqual((0, utils_1.formatBladeStringWithPint)(`<x-icon


            :class="Arr::toCssClasses(['...'])" 
            
            
            
            
            />
            
            @props(
            
            [           'icon'
            
            
            
                   ]
            
            
            )
            
            <div>
            <x-icon                      @class([$icon, 'pe-2'] )
                                   />
            {{ $slot }}
            
            
            
            
            </div>`).trim(), `<x-icon :class="Arr::toCssClasses(['...'])" />

@props(['icon',

])

<div>
    <x-icon @class([$icon, 'pe-2']) />
    {{ $slot }}
</div>`);
    });
    test('pint: it leaves associative arrays alone', () => {
        const template = `@props([
    'foo' => true,
            'bar'       => false,
                         'bar2'                   => false,
])`;
        const out = `@props([
    'foo' => true,
    'bar' => false,
    'bar2' => false,
])
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeStringWithPint)(template), out);
    });
    test('pint: it can wrap prop lists', () => {
        const template = `@props([
    'heading','footer',
])`;
        const out = `@props([
    'heading', 'footer',
])
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeStringWithPint)(template), out);
    });
    test('pint: it detects associative arrays', () => {
        const template = `@props([
    "foo" => [],
])`;
        const out = `@props([
    'foo' => [],
])
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeStringWithPint)(template), out);
    });
    test('pint: it detects assoc arrays 2', () => {
        const template = `@props([
    'foo' => [],
    'foobarbaz' => false,
])`;
        const out = `@props([
    'foo' => [],
    'foobarbaz' => false,
])
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeStringWithPint)(template), out);
    });
    test('pint: it does not force align mixed arrays', () => {
        const input = `@props([
    'foobarbaz' => true,
    'bar',
    'baz' => true,
])`;
        const out = `@props([
    'foobarbaz' => true,
    'bar',
    'baz' => true,
])
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeStringWithPint)(input), out);
        assert_1.default.strictEqual((0, utils_1.formatBladeStringWithPint)(out), out);
    });
    test('pint: it doesnt wrap empty arrays', () => {
        const input = `@props([
            'actions' => [],
            'url',
        ])`;
        const out = `@props([
    'actions' => [],
    'url',
])
`;
        assert_1.default.strictEqual((0, utils_1.formatBladeStringWithPint)(input), out);
        assert_1.default.strictEqual((0, utils_1.formatBladeStringWithPint)(out), out);
    });
});
//# sourceMappingURL=formatter_pint_props_directive.test.js.map