"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DirectivePrinter = void 0;
const utils_1 = require("../../formatting/prettier/utils");
const syntaxReflow_1 = require("../../formatting/syntaxReflow");
const simpleArrayParser_1 = require("../../parser/simpleArrayParser");
const stringUtilities_1 = require("../../utilities/stringUtilities");
const arrayPrinter_1 = require("./arrayPrinter");
const indentLevel_1 = require("./indentLevel");
const printWidthUtils_1 = require("./printWidthUtils");
const generalSyntaxReflow_1 = require("../../formatting/generalSyntaxReflow");
class DirectivePrinter {
    static getReasonableDirectivePhpOptions(directive, phpOptions) {
        // We will override the traillingCommaPHP setting within condition-like
        // directives; if we don't we end up with rather ugly @if(...) blocks
        // all over the place. However, we can't override this on all of
        // the directives, otherwise directives like @class look weird.
        if (DirectivePrinter.defaultControlDirectiveNames.includes(directive.name)) {
            return {
                ...phpOptions,
                trailingCommaPHP: false
            };
        }
        return phpOptions;
    }
    static printDirective(directive, options, phpFormatter, jsonFormatter, indentLevel, pintTransformer) {
        var _a, _b, _c, _d;
        let directiveName = directive.directiveName.trim(), result = '@' + directiveName;
        if (directive.hasDirectiveParameters) {
            let paramContent = directive.directiveParameters;
            if (!directive.hasJsonParameters) {
                if (options.formatDirectivePhpParameters && phpFormatter != null && directive.hasValidPhp()) {
                    if (pintTransformer != null) {
                        let spacesToUse = options.spacesAfterDirective;
                        if (DirectivePrinter.defaultControlDirectiveNames.includes(directiveName)) {
                            spacesToUse = options.spacesAfterControlDirective;
                        }
                        const prefix = '@' + directiveName + ' '.repeat(spacesToUse);
                        let tResult = pintTransformer.getDirectiveContent(directive);
                        tResult = indentLevel_1.IndentLevel.shiftIndent(tResult, indentLevel, true, options);
                        if (DirectivePrinter.defaultControlDirectiveNames.includes(directiveName) && tResult.includes("\n")) {
                            const nLines = stringUtilities_1.StringUtilities.breakByNewLine(tResult), reflowed = [];
                            for (let i = 0; i < nLines.length; i++) {
                                const line = nLines[i];
                                if (i == 0) {
                                    reflowed.push(line);
                                    continue;
                                }
                                reflowed.push(' '.repeat(prefix.length + 1) + line);
                            }
                            tResult = reflowed.join("\n");
                        }
                        return prefix + tResult;
                    }
                    let params = directive.getPhpContent().trim();
                    if (params.startsWith('(') && params.endsWith(')')) {
                        params = params.substring(1);
                        params = params.substring(0, params.length - 1);
                    }
                    let tResult = params, removeLines = false;
                    const phpOptions = (0, utils_1.getPhpOptions)();
                    if (params.startsWith('[') && params.endsWith(']') && ((_a = directive.startPosition) === null || _a === void 0 ? void 0 : _a.line) != ((_b = directive.endPosition) === null || _b === void 0 ? void 0 : _b.line)) {
                        let phpInput = '<?php ' + params;
                        const lineWrapWorkaround = (0, printWidthUtils_1.preparePrettierWorkaround)(phpInput);
                        if (lineWrapWorkaround.addedHack) {
                            phpInput = lineWrapWorkaround.content;
                        }
                        tResult = phpFormatter(phpInput, options, DirectivePrinter.getReasonableDirectivePhpOptions(directive, {
                            ...phpOptions,
                            printWidth: (0, printWidthUtils_1.getPrintWidth)(params, phpOptions.printWidth)
                        }));
                        if (lineWrapWorkaround.addedHack) {
                            tResult = (0, printWidthUtils_1.undoPrettierWorkaround)(tResult);
                        }
                        const arrayParser = new simpleArrayParser_1.SimpleArrayParser(), array = arrayParser.parse(stringUtilities_1.StringUtilities.replaceAllInString(tResult, "\n", ' ')), targetIndent = 0;
                        if (arrayParser.getIsAssoc() || tResult.includes('match') || tResult.includes('=>' || tResult.includes('&&'))) {
                            if (tResult.includes("\n") && !removeLines) {
                                tResult = indentLevel_1.IndentLevel.shiftIndent(tResult, indentLevel, true, options);
                            }
                            if (generalSyntaxReflow_1.GeneralSyntaxReflow.couldReflow(tResult)) {
                                tResult = generalSyntaxReflow_1.GeneralSyntaxReflow.instance.reflow(tResult);
                            }
                            if (syntaxReflow_1.SyntaxReflow.couldReflow(tResult)) {
                                tResult = syntaxReflow_1.SyntaxReflow.instance.reflow(tResult);
                            }
                            tResult = '@' + directiveName + ' '.repeat(options.spacesAfterDirective) + '(' + tResult + ')';
                        }
                        else {
                            if (array != null) {
                                tResult = arrayPrinter_1.ArrayPrinter.print(array, options.tabSize, 1);
                                if (targetIndent > 0) {
                                    tResult = stringUtilities_1.StringUtilities.removeEmptyNewLines(indentLevel_1.IndentLevel.shiftIndent(tResult, targetIndent, true, options));
                                }
                                if (tResult.includes("\n") && !removeLines) {
                                    tResult = indentLevel_1.IndentLevel.shiftIndent(tResult, indentLevel, true, options);
                                }
                                tResult = '@' + directiveName + ' '.repeat(options.spacesAfterDirective) + '(' + tResult + ')';
                            }
                        }
                        return tResult;
                    }
                    else {
                        try {
                            let formatOptions = (0, utils_1.getPhpOptions)();
                            if (((_c = directive.startPosition) === null || _c === void 0 ? void 0 : _c.line) == ((_d = directive.endPosition) === null || _d === void 0 ? void 0 : _d.line)) {
                                formatOptions = {
                                    ...(0, utils_1.getPhpOptions)(),
                                    printWidth: Infinity
                                };
                                removeLines = true;
                            }
                            tResult = phpFormatter('<?php ' + params, options, DirectivePrinter.getReasonableDirectivePhpOptions(directive, formatOptions));
                        }
                        catch (err) {
                            // Prevent PHP errors from crashing formatter.
                        }
                    }
                    if (directive.directiveName.toLowerCase() == 'forelse') {
                        tResult = tResult.substring(9);
                        tResult = tResult.substring(0, tResult.length - 14);
                    }
                    if (generalSyntaxReflow_1.GeneralSyntaxReflow.couldReflow(tResult)) {
                        tResult = generalSyntaxReflow_1.GeneralSyntaxReflow.instance.reflow(tResult);
                    }
                    if (syntaxReflow_1.SyntaxReflow.couldReflow(tResult)) {
                        tResult = syntaxReflow_1.SyntaxReflow.instance.reflow(tResult);
                    }
                    if (tResult.includes("\n") && !removeLines) {
                        paramContent = '(' + indentLevel_1.IndentLevel.shiftIndent(tResult, indentLevel, true, options) + ')';
                    }
                    else {
                        if (removeLines) {
                            tResult = removeContentLines(tResult);
                        }
                        paramContent = '(' + tResult + ')';
                    }
                }
            }
            else {
                if (options.formatDirectiveJsonParameters && jsonFormatter && directive.hasValidJson()) {
                    let params = directive.getPhpContent().trim();
                    if (params.startsWith('(') && params.endsWith(')')) {
                        params = params.substring(1);
                        params = params.substring(0, params.length - 1);
                    }
                    let tResult = jsonFormatter(params);
                    if (tResult.includes("\n")) {
                        tResult = indentLevel_1.IndentLevel.shiftIndent(tResult, indentLevel, true, options);
                    }
                    paramContent = '(' + tResult + ')';
                }
            }
            let spacesToUse = options.spacesAfterDirective;
            if (DirectivePrinter.defaultControlDirectiveNames.includes(directiveName)) {
                spacesToUse = options.spacesAfterControlDirective;
            }
            result += ' '.repeat(spacesToUse) + paramContent;
        }
        return result;
    }
}
exports.DirectivePrinter = DirectivePrinter;
DirectivePrinter.defaultControlDirectiveNames = [
    'if', 'elseif', 'unless', 'while', 'for', 'foreach', 'forelse'
];
function removeContentLines(content) {
    let newContent = '';
    const lines = stringUtilities_1.StringUtilities.breakByNewLine(content);
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        newContent += line.trim();
    }
    return newContent;
}
//# sourceMappingURL=directivePrinter.js.map