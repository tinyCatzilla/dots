"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhpStructuresAnalyzer = void 0;
const php_parser_1 = require("php-parser");
const genericLanguageStructures_1 = require("./genericLanguageStructures");
/**
 * This class helps find structures within PHP code
 * that should be ignored by class emulation. For
 * example, we cannot safely transform method
 * or function arguments as prettier will
 * remove whitespace from the classlist.
 *
 * i.e., implode(', ') becomes implode(',')
 */
class PhpStructuresAnalyzer {
    constructor() {
        this.structures = [];
        this.hasStructuresWithUnknownLocations = false;
        this.excludedStructures = [];
        this.allowedMethods = [];
        this.phpAssignToGeneric = new Map([
            ['=', genericLanguageStructures_1.GenericLanguageStructures.Assignment],
            ['+=', genericLanguageStructures_1.GenericLanguageStructures.AdditionAssignment],
            ['-=', genericLanguageStructures_1.GenericLanguageStructures.SubtractionAssignment],
            ['*=', genericLanguageStructures_1.GenericLanguageStructures.MultiplicationAssignment],
            ['/=', genericLanguageStructures_1.GenericLanguageStructures.DivisionAssignment],
            ['%=', genericLanguageStructures_1.GenericLanguageStructures.ModulusAssignment],
            ['.=', genericLanguageStructures_1.GenericLanguageStructures.ConcatenationAssignment],
            ['%=', genericLanguageStructures_1.GenericLanguageStructures.BitwiseAndAssignment],
            ['|=', genericLanguageStructures_1.GenericLanguageStructures.BitwiseOrAssignment],
            ['^=', genericLanguageStructures_1.GenericLanguageStructures.BitwiseXorAssignment],
            ['<<=', genericLanguageStructures_1.GenericLanguageStructures.LeftShiftAssignment],
            ['>>=', genericLanguageStructures_1.GenericLanguageStructures.RightShiftAssignment],
        ]);
        this.phpOperatorsToGeneric = new Map([
            ['.', genericLanguageStructures_1.GenericLanguageStructures.Concat],
            ['+', genericLanguageStructures_1.GenericLanguageStructures.Addition],
            ['-', genericLanguageStructures_1.GenericLanguageStructures.Substraction],
            ['*', genericLanguageStructures_1.GenericLanguageStructures.Multiplication],
            ['/', genericLanguageStructures_1.GenericLanguageStructures.Division],
            ['%', genericLanguageStructures_1.GenericLanguageStructures.Modulus],
            ['**', genericLanguageStructures_1.GenericLanguageStructures.Exponentiation],
            ['>', genericLanguageStructures_1.GenericLanguageStructures.GreaterThan],
            ['&', genericLanguageStructures_1.GenericLanguageStructures.BitwiseAnd],
            ['|', genericLanguageStructures_1.GenericLanguageStructures.BitwiseOr],
            ['^', genericLanguageStructures_1.GenericLanguageStructures.BitwiseXor],
            ['<<', genericLanguageStructures_1.GenericLanguageStructures.LeftShift],
            ['>>', genericLanguageStructures_1.GenericLanguageStructures.RightShift],
            ['==', genericLanguageStructures_1.GenericLanguageStructures.Equality],
            ['===', genericLanguageStructures_1.GenericLanguageStructures.Identity],
            ['<', genericLanguageStructures_1.GenericLanguageStructures.LessThan],
            ['<>', genericLanguageStructures_1.GenericLanguageStructures.Inequality],
            ['!=', genericLanguageStructures_1.GenericLanguageStructures.Inequality],
            ['!==', genericLanguageStructures_1.GenericLanguageStructures.NotIdentity],
            ['>=', genericLanguageStructures_1.GenericLanguageStructures.GreaterThanEqual],
            ['<=', genericLanguageStructures_1.GenericLanguageStructures.LessThanEqual],
            ['&&', genericLanguageStructures_1.GenericLanguageStructures.CompAnd],
            ['and', genericLanguageStructures_1.GenericLanguageStructures.CompAnd],
            ['||', genericLanguageStructures_1.GenericLanguageStructures.CompOr],
            ['or', genericLanguageStructures_1.GenericLanguageStructures.CompOr],
            ['xor', genericLanguageStructures_1.GenericLanguageStructures.Xor],
        ]);
        this.parser = new php_parser_1.Engine({
            parser: {
                extractDoc: true,
            },
            ast: {
                withPositions: true,
                withSource: true,
            },
        });
    }
    hasUnknownLocations() {
        return this.hasStructuresWithUnknownLocations;
    }
    getStructureLocations(code, locationOffset) {
        const ast = this.parser.parseCode(code, 'code.php');
        this.findStructureLocations(ast, locationOffset);
    }
    setExcludedStructures(structures) {
        this.excludedStructures = structures;
    }
    setAllowedMethods(methods) {
        this.allowedMethods = methods;
    }
    getStructures() {
        return this.structures;
    }
    findStructureLocations(ast, locationOffset) {
        const ranges = [], excludedStructures = this.excludedStructures, phpOps = this.phpOperatorsToGeneric, phpAssigns = this.phpAssignToGeneric, allowedMethodNames = this.allowedMethods;
        let foundUnknownLocations = false;
        function traverse(node) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
            if (node.kind === 'if') {
                const ifStatement = node;
                if (ifStatement.test.loc == null) {
                    foundUnknownLocations = true;
                }
                if (excludedStructures.includes(genericLanguageStructures_1.GenericLanguageStructures.IfStatement)) {
                    ranges.push({
                        label: genericLanguageStructures_1.GenericLanguageStructures.IfStatement,
                        start: ((_b = (_a = ifStatement.test.loc) === null || _a === void 0 ? void 0 : _a.start.offset) !== null && _b !== void 0 ? _b : -1) - locationOffset,
                        end: ((_d = (_c = ifStatement.test.loc) === null || _c === void 0 ? void 0 : _c.end.offset) !== null && _d !== void 0 ? _d : -1) - locationOffset
                    });
                }
            }
            else if (node.kind == 'retif') {
                const retIf = node;
                if (retIf.test.loc == null) {
                    foundUnknownLocations = true;
                }
                if (excludedStructures.includes(genericLanguageStructures_1.GenericLanguageStructures.TernaryStatement)) {
                    ranges.push({
                        label: genericLanguageStructures_1.GenericLanguageStructures.TernaryStatement,
                        start: ((_f = (_e = retIf.test.loc) === null || _e === void 0 ? void 0 : _e.start.offset) !== null && _f !== void 0 ? _f : -1) - locationOffset,
                        end: ((_h = (_g = retIf.test.loc) === null || _g === void 0 ? void 0 : _g.end.offset) !== null && _h !== void 0 ? _h : -1) - locationOffset + 2
                    });
                }
            }
            else if (node.kind == 'assign') {
                const assignStatement = node;
                let addRange = true;
                if (assignStatement.left.loc == null || assignStatement.right.loc == null) {
                    foundUnknownLocations = true;
                }
                let assignType = assignStatement.operator;
                if (phpAssigns.has(assignType)) {
                    assignType = phpAssigns.get(assignType);
                }
                else {
                    assignType = genericLanguageStructures_1.GenericLanguageStructures.Assignment;
                }
                if (!excludedStructures.includes(assignType)) {
                    addRange = false;
                }
                if (addRange) {
                    ranges.push({
                        label: assignType,
                        start: ((_k = (_j = assignStatement.left.loc) === null || _j === void 0 ? void 0 : _j.start.offset) !== null && _k !== void 0 ? _k : -1) - locationOffset,
                        end: ((_m = (_l = assignStatement.right.loc) === null || _l === void 0 ? void 0 : _l.end.offset) !== null && _m !== void 0 ? _m : -1) - locationOffset
                    });
                }
            }
            else if (node.kind == 'bin') {
                const binStatement = node;
                let addRange = true;
                if (binStatement.left.loc == null || binStatement.right.loc == null) {
                    foundUnknownLocations = true;
                }
                let binType = binStatement.kind.toLowerCase();
                if (phpOps.has(binType)) {
                    binType = phpOps.get(binType);
                }
                else {
                    binType = genericLanguageStructures_1.GenericLanguageStructures.BinCompare;
                }
                if (!excludedStructures.includes(binType)) {
                    addRange = false;
                }
                if (addRange) {
                    ranges.push({
                        label: binType,
                        start: ((_p = (_o = binStatement.left.loc) === null || _o === void 0 ? void 0 : _o.start.offset) !== null && _p !== void 0 ? _p : -1) - locationOffset,
                        end: ((_r = (_q = binStatement.right.loc) === null || _q === void 0 ? void 0 : _q.end.offset) !== null && _r !== void 0 ? _r : -1) - locationOffset
                    });
                }
            }
            else if (node.kind == 'call') {
                const callStatement = node;
                let addRange = true;
                if (callStatement.what.kind == 'propertylookup') {
                    const lookup = callStatement.what;
                    if (lookup.offset.kind == 'identifier') {
                        const identifier = lookup.offset;
                        if (allowedMethodNames.includes(identifier.name)) {
                            addRange = false;
                        }
                    }
                }
                if (!excludedStructures.includes(genericLanguageStructures_1.GenericLanguageStructures.CallStatement)) {
                    addRange = false;
                }
                if (addRange) {
                    if (callStatement.loc == null) {
                        foundUnknownLocations = true;
                    }
                    ranges.push({
                        label: genericLanguageStructures_1.GenericLanguageStructures.CallStatement,
                        start: ((_t = (_s = callStatement.loc) === null || _s === void 0 ? void 0 : _s.start.offset) !== null && _t !== void 0 ? _t : -1) - locationOffset,
                        end: ((_v = (_u = callStatement.loc) === null || _u === void 0 ? void 0 : _u.end.offset) !== null && _v !== void 0 ? _v : -1) - locationOffset
                    });
                }
            }
            for (const key in node) {
                if (node.hasOwnProperty(key) && typeof node[key] === 'object' && node[key]) {
                    traverse(node[key]);
                }
            }
        }
        traverse(ast);
        this.hasStructuresWithUnknownLocations = foundUnknownLocations;
        this.structures = ranges;
    }
}
exports.PhpStructuresAnalyzer = PhpStructuresAnalyzer;
function isObject(variable) {
    return typeof variable === 'object' && variable !== null;
}
//# sourceMappingURL=phpStructuresAnalyzer.js.map