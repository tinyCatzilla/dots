"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentParser = void 0;
const stringRemover_1 = require("./stringRemover");
const conditionalRewriteAnalyzer_1 = require("../analyzers/conditionalRewriteAnalyzer");
const directivePairAnalyzer_1 = require("../analyzers/directivePairAnalyzer");
const directiveStack_1 = require("../analyzers/directiveStack");
const fragmentPositionAnalyzer_1 = require("../analyzers/fragmentPositionAnalyzer");
const inlineEchoAnalyzer_1 = require("../analyzers/inlineEchoAnalyzer");
const inlinePhpAnalyzer_1 = require("../analyzers/inlinePhpAnalyzer");
const pairManager_1 = require("../analyzers/pairManager");
const bladeDocument_1 = require("../document/bladeDocument");
const wordScanner_1 = require("../document/scanners/wordScanner");
const bladeError_1 = require("../errors/bladeError");
const bladeErrorCodes_1 = require("../errors/bladeErrorCodes");
const helpers_1 = require("../nodes/helpers");
const nodes_1 = require("../nodes/nodes");
const position_1 = require("../nodes/position");
const stringUtilities_1 = require("../utilities/stringUtilities");
const bladeKeywords_1 = require("./bladeKeywords");
const componentParser_1 = require("./componentParser");
const fragmentsParser_1 = require("./fragmentsParser");
const parserOptions_1 = require("./parserOptions");
const isStartOfString_1 = require("./scanners/isStartOfString");
const nextNonWhitespace_1 = require("./scanners/nextNonWhitespace");
const scanToEndOfLogicGroup_1 = require("./scanners/scanToEndOfLogicGroup");
const skipToEndOfLine_1 = require("./scanners/skipToEndOfLine");
const skipToEndOfMultilineComment_1 = require("./scanners/skipToEndOfMultilineComment");
const skipToEndOfString_1 = require("./scanners/skipToEndOfString");
const fragmentTransformer_1 = require("../document/fragmentTransformer");
class DocumentParser {
    constructor() {
        this.nodes = [];
        this.renderNodes = [];
        this.chars = [];
        this.currentIndex = 0;
        this.currentContent = [];
        this.cur = null;
        this.next = null;
        this.prev = null;
        this.charLen = 0;
        this.inputLen = 0;
        this.maxLine = 1;
        this.chunkSize = 5;
        this.currentChunkOffset = 0;
        this.parsingOffset = 0;
        this.isVerbatim = false;
        this.isPhpNode = false;
        this.bladeStartIndex = [];
        this.bladeStartPositionIndex = new Map();
        this.lastBladeEndIndex = -1;
        this.lastNode = null;
        this.documentOffsets = new Map();
        this.lineIndex = new Map();
        this.lastDocumentOffsetKey = null;
        this.content = '';
        this.originalContent = '';
        this.seedOffset = 0;
        this.seedStartLine = 1;
        this.shiftLine = 0;
        this.isParsingComponent = false;
        this.shouldIgnoreStructures = false;
        this.pushedErrors = new Map();
        this.errors = [];
        this.structureErrors = [];
        this.doesHaveUnclosedIfStructures = false;
        this.doesHaveUnclosedSwitchStructures = false;
        this.doesHaveUnclosedComments = false;
        this.doesHaveUnclosedRegions = false;
        this.phpValidator = null;
        this.didRecoveryLogic = false;
        this.parseFragments = true;
        this.hasPairedStructures = false;
        this.hasComponents = false;
        this.hasPhpContent = false;
        this.unclosedRegionErrors = [
            bladeErrorCodes_1.BladeErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT,
            bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_PHP_DIRECTIVE,
            bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_PHP_CLOSING_DIRECTIVE,
            bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_VERBATIM,
            bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_VERBATIM_CLOSING_DIRECTIVE,
            bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_FOR_DIRECTIVE,
            bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_FOR_CLOSING_DIRECTIVE,
            bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_FOR_ELSE_DIRECTIVE,
            bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_FOR_ELSE_CLOSING_DIRECTIVE
        ];
        this.componentParser = new componentParser_1.ComponentParser(this);
        this.fragmentsParser = new fragmentsParser_1.FragmentsParser();
        this.fragmentsAnalyzer = new fragmentPositionAnalyzer_1.FragmentPositionAnalyzer(this, this.fragmentsParser);
        this.parserOptions = (0, parserOptions_1.getParserOptions)();
    }
    advance(count) {
        for (let i = 0; i < count; i++) {
            this.currentIndex++;
            this.checkCurrentOffsets();
        }
    }
    encounteredFailure() {
        this.didRecoveryLogic = true;
    }
    withPhpValidator(validator) {
        this.phpValidator = validator;
        return this;
    }
    getPhpValidator() {
        return this.phpValidator;
    }
    withParserOptions(options) {
        this.parserOptions = options;
        return this;
    }
    getParserOptions() {
        return this.parserOptions;
    }
    hasUnclosedIfStructures() {
        return this.doesHaveUnclosedIfStructures;
    }
    hasUnclosedSwitchStructures() {
        return this.doesHaveUnclosedSwitchStructures;
    }
    hasUnclosedComments() {
        return this.doesHaveUnclosedComments;
    }
    hasUnclosedRegions() {
        return this.doesHaveUnclosedRegions;
    }
    hasUnclosedStructures() {
        return this.doesHaveUnclosedComments || this.doesHaveUnclosedIfStructures || this.doesHaveUnclosedSwitchStructures || this.doesHaveUnclosedRegions;
    }
    getErrors() {
        return this.errors;
    }
    getStructureErrors() {
        return this.structureErrors;
    }
    updateIndex(index) {
        this.currentIndex = index;
    }
    inputLength() {
        return this.inputLen;
    }
    incrementIndex() {
        this.currentIndex += 1;
    }
    getCurrentIndex() {
        return this.currentIndex;
    }
    getCurrent() {
        return this.cur;
    }
    getNext() {
        return this.next;
    }
    getPrev() {
        return this.prev;
    }
    getChar(index) {
        return this.chars[index];
    }
    pushChar(value) {
        this.currentContent.push(value);
    }
    getSeedOffset() {
        return this.seedOffset;
    }
    getContentSubstring(from, length) {
        return this.content.substr(from, length);
    }
    resetIntermediateState() {
        this.chars = [];
        this.charLen = 0;
        this.currentIndex = 0;
        this.currentContent = [];
        this.cur = null;
        this.next = null;
        this.prev = null;
    }
    setSeedPosition(position) {
        if (position == null) {
            this.shiftLine = 0;
        }
        else {
            this.shiftLine = position.line;
        }
        return this;
    }
    resetState() {
        this.nodes = [];
        this.renderNodes = [];
        this.charLen = 0;
        this.bladeStartIndex = [];
        this.lastBladeEndIndex = -1;
    }
    getHasPhpContent() {
        return this.hasPhpContent;
    }
    getDidRecovery() {
        return this.didRecoveryLogic;
    }
    isStartingPhp() {
        if (this.cur == DocumentParser.Punctuation_LessThan && this.next == DocumentParser.Punctuation_QuestionMark) {
            const fetch = this.fetchAt(this.currentChunkOffset, 5).toLowerCase();
            return fetch == '<?php';
        }
        return false;
    }
    isStartingShorthandPhp() {
        if (this.cur == DocumentParser.Punctuation_LessThan && this.next == DocumentParser.Punctuation_QuestionMark) {
            const fetch = this.fetchAt(this.currentChunkOffset, 3).toLowerCase();
            return fetch == '<?=';
        }
        return false;
    }
    isStartingDirective() {
        if (this.next != null) {
            if (!stringUtilities_1.StringUtilities.ctypeAlpha(this.next)) {
                return false;
            }
        }
        if (this.cur == DocumentParser.AtChar && this.next != null && this.prev != DocumentParser.AtChar) {
            return true;
        }
        return false;
    }
    isClosingComponent() {
        if (this.cur == DocumentParser.Punctuation_GreaterThan && (this.prev != DocumentParser.Punctuation_Minus && this.prev != DocumentParser.Punctuation_Equals)) {
            return true;
        }
        return false;
    }
    isStartingClosingComponentTag() {
        if (this.cur == DocumentParser.Punctuation_LessThan &&
            this.next == DocumentParser.Punctuation_ForwardSlash
            && this.peekRelative(2) == 'x' && (this.peekRelative(3) == DocumentParser.Punctuation_Minus || this.peekRelative(3) == DocumentParser.Punctuation_Colon)) {
            return true;
        }
        return false;
    }
    isStartingOpeningComponentTag() {
        if (this.cur == DocumentParser.Punctuation_LessThan && this.next == 'x' && (this.peekRelative(2) == DocumentParser.Punctuation_Minus || this.peekRelative(2) == DocumentParser.Punctuation_Colon)) {
            return true;
        }
        return false;
    }
    isStartingEscapedEcho() {
        if ((this.prev == null || (this.prev != null && this.prev != DocumentParser.AtChar)) && this.next == DocumentParser.Punctuation_Exclamation) {
            if (this.cur == DocumentParser.LeftBrace && this.peek(2) == DocumentParser.Punctuation_Exclamation) {
                return true;
            }
        }
        return false;
    }
    isStartingBladeNodeStructure() {
        if ((this.prev == null || (this.prev != null && this.prev != DocumentParser.AtChar)) && this.next == DocumentParser.LeftBrace) {
            if (this.cur == DocumentParser.LeftBrace && this.next == DocumentParser.LeftBrace) {
                return true;
            }
        }
        return false;
    }
    hasEncounteredAnotherStructure() {
        if (this.shouldIgnoreStructures) {
            return false;
        }
        if (this.isStartingOpeningComponentTag()) {
            return true;
        }
        if (this.isParsingComponent) {
            return false;
        }
        if (this.isStartingClosingComponentTag() ||
            this.isStartingDirective() ||
            this.isStartingEscapedEcho() ||
            this.isStartingBladeNodeStructure()) {
            return true;
        }
        return false;
    }
    endsWithTld(s) {
        const regex = /\.[a-z]{2,63}$/i;
        return regex.test(s);
    }
    processInputText(input) {
        var _a;
        this.originalContent = input;
        this.content = stringUtilities_1.StringUtilities.normalizeLineEndings(input);
        this.inputLen = this.content.length;
        const documentNewLines = [...this.content.matchAll(/(\n)/gm)];
        const newLineCountLen = documentNewLines.length;
        let currentLine = this.seedStartLine, lastOffset = null, lastStartIndex = 0, lastEndIndex = 0;
        for (let i = 0; i < newLineCountLen; i++) {
            const thisNewLine = documentNewLines[i], thisIndex = (_a = thisNewLine.index) !== null && _a !== void 0 ? _a : 0;
            let indexChar = thisIndex;
            if (lastOffset != null) {
                indexChar = thisIndex - lastOffset;
            }
            else {
                indexChar = indexChar + 1;
            }
            this.documentOffsets.set(thisIndex, {
                char: indexChar,
                line: currentLine
            });
            let thisStartIndex = 0, thisEndIndex = 0;
            if (i == 0) {
                thisEndIndex = indexChar - 1;
                thisStartIndex = 0;
            }
            else {
                thisStartIndex = lastEndIndex + 1;
                thisEndIndex = thisIndex;
            }
            this.lineIndex.set(currentLine, {
                char: indexChar,
                line: currentLine,
                startIndex: thisStartIndex,
                endIndex: thisEndIndex
            });
            this.lastDocumentOffsetKey = thisIndex;
            this.maxLine = currentLine;
            currentLine += 1;
            lastOffset = thisIndex;
            lastEndIndex = thisEndIndex;
            lastStartIndex = thisStartIndex;
        }
        this.maxLine += 1;
        const bladeStartCandidates = [...this.content.matchAll(/({{|<\?php|<\?=|@?{!!|@|<x-|<\/x-|<x:|<\/x:)/gm)];
        let lastBladeOffset = 0, lastWasEscaped = false, lastWasEscapedDirective = false, lastMatch, lastAbandonedFromEmail = false;
        bladeStartCandidates.forEach((bladeRegion) => {
            var _a, _b, _c, _d, _e, _f;
            if (lastWasEscapedDirective) {
                if (lastMatch != null) {
                    const diff = ((_a = bladeRegion.index) !== null && _a !== void 0 ? _a : 0) - ((_b = lastMatch.index) !== null && _b !== void 0 ? _b : 0);
                    if (diff > 1) {
                        lastWasEscaped = false;
                        lastWasEscapedDirective = false;
                        lastBladeOffset = (_c = bladeRegion.index) !== null && _c !== void 0 ? _c : 0;
                    }
                }
            }
            else {
                if (lastAbandonedFromEmail && bladeRegion.index) {
                    lastBladeOffset = (_d = bladeRegion.index) !== null && _d !== void 0 ? _d : 0;
                    lastAbandonedFromEmail = false;
                }
            }
            const matchText = bladeRegion[0], seekIndex = this.content.indexOf(matchText, lastBladeOffset), seekText = this.content.substr(seekIndex, 10);
            if (seekText.startsWith('@@') || seekText.startsWith('@{{')) {
                lastBladeOffset = this.content.indexOf(matchText, lastBladeOffset); // + 2;
                lastWasEscaped = true;
                if (seekText.startsWith('@@')) {
                    lastWasEscapedDirective = true;
                }
                else {
                    lastWasEscapedDirective = false;
                }
                lastMatch = bladeRegion;
                return;
            }
            const offset = this.content.indexOf(matchText, lastBladeOffset);
            if (lastWasEscaped) {
                if (lastMatch != null) {
                    const diff = ((_e = bladeRegion.index) !== null && _e !== void 0 ? _e : 0) - ((_f = lastMatch.index) !== null && _f !== void 0 ? _f : 0);
                    if (diff <= 1) {
                        lastBladeOffset = offset;
                        lastMatch = bladeRegion;
                        return;
                    }
                    else {
                        lastWasEscaped = false;
                    }
                }
                if (lastBladeOffset == offset || (offset - lastBladeOffset) <= 1) {
                    lastBladeOffset = offset;
                    lastMatch = bladeRegion;
                    return;
                }
                else {
                    lastWasEscaped = false;
                }
            }
            let prefetchLength = 3, shouldCheckForIgnoredDirectives = false, exclusiveDirectivesSupplied = false;
            const lowerIgnoreDirectives = [], lowerExclusiveDirectives = [];
            if (this.parserOptions.ignoreDirectives.length > 0) {
                this.parserOptions.ignoreDirectives.forEach((directive) => {
                    lowerIgnoreDirectives.push(directive.toLowerCase());
                    if (directive.length > prefetchLength) {
                        prefetchLength = directive.length;
                    }
                });
                prefetchLength += 5;
                shouldCheckForIgnoredDirectives = true;
            }
            if (this.parserOptions.directives.length > 0) {
                prefetchLength = 3;
                this.parserOptions.directives.forEach((directive) => {
                    lowerExclusiveDirectives.push(directive.toLowerCase());
                    if (directive.length > prefetchLength) {
                        prefetchLength = directive.length;
                    }
                });
                prefetchLength += 5;
                shouldCheckForIgnoredDirectives = false;
                exclusiveDirectivesSupplied = true;
            }
            const preFetch = this.fetchAt(offset, prefetchLength);
            if (preFetch.includes('.')) {
                let preFetchCheck = preFetch;
                if (preFetch.includes("\n")) {
                    preFetchCheck = stringUtilities_1.StringUtilities.breakByNewLine(preFetchCheck)[0];
                }
                const rmResults = stringRemover_1.StringRemover.fromText(preFetchCheck);
                if (rmResults.includes('.') && this.endsWithTld(rmResults)) {
                    lastMatch = bladeRegion;
                    lastAbandonedFromEmail = true;
                    return;
                }
            }
            if (preFetch.startsWith('@{') == false) {
                const firstChar = preFetch.substring(0, 1), secondChar = preFetch.substring(1, 2);
                if (firstChar == '@' && stringUtilities_1.StringUtilities.ctypeAlpha(secondChar)) {
                    if (exclusiveDirectivesSupplied) {
                        const checkPrefetch = this.breakPreFetch(preFetch).toLowerCase();
                        if (lowerExclusiveDirectives.includes(checkPrefetch)) {
                            this.bladeStartIndex.push(offset);
                        }
                    }
                    else {
                        if (shouldCheckForIgnoredDirectives) {
                            const checkPrefetch = this.breakPreFetch(preFetch).toLowerCase();
                            if (!lowerIgnoreDirectives.includes(checkPrefetch)) {
                                this.bladeStartIndex.push(offset);
                            }
                        }
                        else {
                            this.bladeStartIndex.push(offset);
                        }
                    }
                }
                else if (firstChar != '@') {
                    this.bladeStartIndex.push(offset);
                }
            }
            this.bladeStartPositionIndex.set(offset, 1);
            lastBladeOffset = offset + 2;
            lastWasEscaped = false;
            lastMatch = bladeRegion;
        });
        this.fragmentsParser
            .setDocumentOffsets(this.documentOffsets, this.lastDocumentOffsetKey);
        return true;
    }
    breakPreFetch(value) {
        const wsParts = stringUtilities_1.StringUtilities.replaceAllInString(stringUtilities_1.StringUtilities.normalizeLineEndings(value), "\n", ' ').split(' '), parenParts = wsParts[0].split('(');
        let candidate = parenParts[0].trim();
        if (candidate.startsWith('@')) {
            candidate = candidate.substring(1);
        }
        return candidate.toLowerCase();
    }
    fetchAt(start, length) {
        return this.content.substr(start, length);
    }
    shouldSkipForward() {
        if (this.lastNode == null) {
            return true;
        }
        if (this.lastNode instanceof nodes_1.DirectiveNode) {
            if (this.lastNode.directiveName == bladeKeywords_1.BladeKeywords.Verbatim || this.lastNode.directiveName == bladeKeywords_1.BladeKeywords.Php) {
                return false;
            }
        }
        return true;
    }
    setParseFragments(parseFragments) {
        this.parseFragments = parseFragments;
    }
    pushError(error) {
        const errorHash = error.hash();
        if (!this.pushedErrors.has(errorHash)) {
            if (error.errorCode == bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_CONDITION) {
                this.doesHaveUnclosedIfStructures = true;
                this.structureErrors.push(error);
            }
            else if (error.errorCode == bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_SWITCH) {
                this.doesHaveUnclosedSwitchStructures = true;
                this.structureErrors.push(error);
            }
            else if (error.errorCode == bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_COMMENT) {
                this.doesHaveUnclosedComments = true;
                this.structureErrors.push(error);
            }
            else if (this.unclosedRegionErrors.includes(error.errorCode)) {
                this.doesHaveUnclosedRegions = true;
                this.structureErrors.push(error);
            }
            this.pushedErrors.set(errorHash, error);
            this.errors.push(error);
        }
    }
    getContent() {
        return this.content;
    }
    getOriginalContent() {
        return this.originalContent;
    }
    getFragments() {
        return this.fragmentsParser.getFragments();
    }
    getFragmentsParser() {
        return this.fragmentsParser;
    }
    getFragmentsContainingStructures() {
        return this.fragmentsParser.getFragmentsContainingStructures();
    }
    charLeftAt(position) {
        if (position == null) {
            return null;
        }
        if (position.char <= 1) {
            return null;
        }
        return this.charAt(this.positionFromCursor(position.line, position.char - 1));
    }
    charLeftAtCursor(line, char) {
        return this.charLeftAt(this.positionFromCursor(line, char));
    }
    charRightAt(position) {
        if (position == null) {
            return null;
        }
        return this.charAt(this.positionFromCursor(position.line, position.char + 1));
    }
    charRightAtCursor(line, char) {
        return this.charRightAt(this.positionFromCursor(line, char));
    }
    punctuationLeftAt(position, tabSize = 4) {
        if (position == null) {
            return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
            return null;
        }
        return wordScanner_1.WordScanner.findLeftNeighboringNextPunctuation(position.char, lineText, tabSize);
    }
    punctuationLeftAtCursor(line, char, tabSize = 4) {
        return this.punctuationLeftAt(this.positionFromCursor(line, char), tabSize);
    }
    punctuationRightAt(position, tabSize = 4) {
        if (position == null) {
            return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
            return null;
        }
        return wordScanner_1.WordScanner.findRightBeighboringNextPunctuation(position.char, lineText, tabSize);
    }
    punctuationRightAtCursor(line, char, tabSize = 4) {
        return this.punctuationRightAt(this.positionFromCursor(line, char), tabSize);
    }
    wordRightAt(position, tabSize = 4) {
        if (position == null) {
            return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
            return null;
        }
        const rightWordChar = wordScanner_1.WordScanner.findRightNeighboringNextAlphaNumeric(position.char, lineText, tabSize);
        if (rightWordChar == null) {
            return null;
        }
        return wordScanner_1.WordScanner.scanWordAt(rightWordChar, lineText, tabSize);
    }
    wordRightAtCursor(line, char, tabSize = 4) {
        return this.wordRightAt(this.positionFromCursor(line, char), tabSize);
    }
    wordLeftAt(position, tabSize = 4) {
        if (position == null) {
            return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
            return null;
        }
        const leftWordChar = wordScanner_1.WordScanner.findLeftNeighboringNextAlphaNumeric(position.char, lineText, tabSize);
        if (leftWordChar == null) {
            return null;
        }
        return wordScanner_1.WordScanner.scanWordAt(leftWordChar, lineText, tabSize);
    }
    wordLeftAtCursor(line, char, tabSize = 4) {
        return this.wordLeftAt(this.positionFromCursor(line, char), tabSize);
    }
    wordAt(position, tabSize = 4) {
        if (position == null) {
            return null;
        }
        const lineText = this.getLineText(position.line);
        if (lineText == null) {
            return null;
        }
        return wordScanner_1.WordScanner.scanWordAt(position.char, lineText, tabSize);
    }
    getLineText(lineNumber) {
        const index = this.getLineIndex(lineNumber);
        if (index != null) {
            return stringUtilities_1.StringUtilities.trimRight(this.getContent().substring(index.start, index.end + 1));
        }
        return null;
    }
    wordAtCursor(line, char, tabSize = 4) {
        return this.wordAt(this.positionFromCursor(line, char), tabSize);
    }
    charAt(position) {
        if (position == null) {
            return null;
        }
        return this.content.substr(position.offset, 1);
    }
    getLinesAround(line) {
        var _a;
        const lines = new Map();
        let startLine = line - 3, endLine = line + 3;
        if (startLine < 1) {
            startLine = 1;
        }
        if (endLine > this.maxLine) {
            endLine = this.maxLine;
        }
        for (let i = startLine; i <= endLine; i++) {
            lines.set(i, (_a = this.getLineText(i)) !== null && _a !== void 0 ? _a : '');
        }
        return lines;
    }
    charAtCursor(line, char) {
        return this.charAt(this.positionFromCursor(line, char));
    }
    getLineIndex(line) {
        if (line == this.maxLine) {
            const lastIndex = this.lineIndex.get(line - 1);
            if (lastIndex != null) {
                const startIndex = lastIndex.endIndex + 1, endIndex = this.inputLen - 1;
                return {
                    end: endIndex,
                    start: startIndex
                };
            }
            return null;
        }
        const indexEntry = this.lineIndex.get(line);
        if (indexEntry != null) {
            return {
                start: indexEntry.startIndex,
                end: indexEntry.endIndex
            };
        }
        return null;
    }
    getHasPairedStructures() {
        return this.hasPairedStructures;
    }
    getHasComponents() {
        return this.hasComponents;
    }
    positionFromCursor(line, char) {
        if (line == this.maxLine) {
            const lastIndex = this.lineIndex.get(line - 1);
            if (lastIndex != null) {
                const startIndex = lastIndex.endIndex + 1, thisOffset = startIndex + (char - 1);
                const position = new position_1.Position();
                position.offset = thisOffset;
                position.line = line;
                position.char = char;
                position.index = thisOffset;
                return position;
            }
            return null;
        }
        const indexEntry = this.lineIndex.get(line);
        if (indexEntry != null) {
            const position = new position_1.Position();
            position.offset = indexEntry.startIndex + (char - 1);
            position.line = indexEntry.line;
            position.char = char;
            position.index = indexEntry.startIndex + (char - 1);
            return position;
        }
        return null;
    }
    parse(text) {
        pairManager_1.PairManager.customIfs.clear();
        this.parserOptions.customIfs.forEach((customIf) => {
            pairManager_1.PairManager.customIfs.set(customIf, 1);
        });
        if (!this.processInputText(text)) {
            return [];
        }
        const indexCount = this.bladeStartIndex.length, lastIndex = indexCount - 1;
        if (indexCount == 0 && !this.isVerbatim) {
            const fullDocumentLiteral = new nodes_1.LiteralNode();
            fullDocumentLiteral.withParser(this);
            fullDocumentLiteral.content = this.prepareLiteralContent(this.content);
            fullDocumentLiteral.startPosition = this.positionFromOffset(0, 0);
            fullDocumentLiteral.endPosition = this.positionFromOffset(this.inputLen - 1, this.inputLen - 1);
            this.nodes.push(fullDocumentLiteral);
        }
        else {
            for (let i = 0; i < indexCount; i += 1) {
                let offset = this.bladeStartIndex[i];
                this.seedOffset = offset;
                if (i == 0 && offset > 0 && !this.isVerbatim) {
                    const node = new nodes_1.LiteralNode();
                    node.withParser(this);
                    node.content = this.prepareLiteralContent(this.content.substr(0, offset));
                    if (node.content.length > 0) {
                        node.startPosition = this.positionFromOffset(0, 0);
                        node.endPosition = this.positionFromOffset(offset, offset - 1);
                        this.nodes.push(node);
                    }
                }
                if (offset < this.lastBladeEndIndex) {
                    continue;
                }
                this.currentChunkOffset = offset;
                this.parsingOffset = offset;
                this.resetIntermediateState();
                this.parseIntermediateText(offset);
                if (this.isVerbatim) {
                    let found = false;
                    for (let j = i + 1; j < this.bladeStartIndex.length; j++) {
                        const checkIndex = this.bladeStartIndex[j], thisChunk = this.fetchAt(checkIndex, 12);
                        if (thisChunk == '@endverbatim') {
                            i = j - 1;
                            this.isVerbatim = false;
                            found = true;
                            break;
                        }
                    }
                    if (found) {
                        continue;
                    }
                }
                if (this.isPhpNode) {
                    let found = false;
                    for (let j = i + 1; j < this.bladeStartIndex.length; j++) {
                        const checkIndex = this.bladeStartIndex[j], thisChunk = this.fetchAt(checkIndex, 7);
                        if (thisChunk == '@endphp') {
                            i = j - 1;
                            this.isPhpNode = false;
                            found = true;
                            break;
                        }
                    }
                    if (found) {
                        continue;
                    }
                }
                if (this.lastNode instanceof nodes_1.BladeCommentNode || this.lastNode instanceof nodes_1.InlinePhpNode) {
                    let seekLiteralIndex = -1;
                    for (let j = i; j < this.bladeStartIndex.length; j++) {
                        const checkIndex = this.bladeStartIndex[j];
                        if (checkIndex > this.lastBladeEndIndex) {
                            seekLiteralIndex = checkIndex;
                            break;
                        }
                    }
                    if (seekLiteralIndex != -1) {
                        let literalOffset = 1;
                        if (this.lastNode instanceof nodes_1.InlinePhpNode) {
                            literalOffset = 0;
                        }
                        const literalStart = this.lastBladeEndIndex + literalOffset, literalContent = this.content.substr(this.lastBladeEndIndex + literalOffset, seekLiteralIndex - this.lastBladeEndIndex - literalOffset), literalEnd = seekLiteralIndex - 1;
                        const literalNode = new nodes_1.LiteralNode();
                        literalNode.withParser(this);
                        literalNode.startPosition = this.positionFromOffset(literalStart, literalStart);
                        literalNode.endPosition = this.positionFromOffset(literalEnd, literalEnd);
                        literalNode.content = literalContent;
                        this.nodes.push(literalNode);
                        this.lastNode = literalNode;
                        this.lastBladeEndIndex = literalEnd;
                        continue;
                    }
                }
                if (this.lastNode instanceof nodes_1.BladeComponentNode) {
                    offset -= 2;
                }
                let shouldProduceLiteralNode = false;
                if (!this.bladeStartPositionIndex.has(this.currentChunkOffset)) {
                    shouldProduceLiteralNode = true;
                }
                else if (this.lastBladeEndIndex < this.currentChunkOffset) {
                    shouldProduceLiteralNode = true;
                }
                if (shouldProduceLiteralNode) {
                    if (i + 1 < indexCount) {
                        let nextBladeStart = this.bladeStartIndex[i + 1];
                        let literalNodeOffset = 1;
                        if (this.lastNode instanceof nodes_1.InlinePhpNode) {
                            literalNodeOffset = 0;
                        }
                        const literalStartIndex = this.lastBladeEndIndex + literalNodeOffset;
                        if (nextBladeStart < literalStartIndex) {
                            if (this.lastBladeEndIndex > nextBladeStart) {
                                if (i + 2 < indexCount) {
                                    nextBladeStart = this.bladeStartIndex[i + 2];
                                }
                            }
                            else {
                                continue;
                            }
                        }
                        if (this.shouldSkipForward()) {
                            for (let j = i; j < this.bladeStartIndex.length; j++) {
                                const checkIndex = this.bladeStartIndex[j];
                                if (checkIndex > this.lastBladeEndIndex) {
                                    nextBladeStart = checkIndex;
                                    break;
                                }
                            }
                        }
                        if (i + 1 == lastIndex && (nextBladeStart <= this.lastBladeEndIndex)) {
                            if (this.isVerbatim) {
                                break;
                            }
                            // In this scenario, we will create the last trailing literal node and break.
                            const thisOffset = this.currentChunkOffset, nodeContent = this.content.substr(literalStartIndex);
                            const literalNode = new nodes_1.LiteralNode();
                            literalNode.withParser(this);
                            literalNode.content = this.prepareLiteralContent(nodeContent);
                            if (literalNode.content.length > 0) {
                                literalNode.startPosition = this.positionFromOffset(thisOffset, thisOffset);
                                literalNode.endPosition = this.positionFromOffset(nextBladeStart, nextBladeStart - 1);
                                this.nodes.push(literalNode);
                            }
                            break;
                        }
                        else {
                            const literalLength = nextBladeStart - this.lastBladeEndIndex - 1;
                            if (literalLength < 0 && this.lastNode instanceof nodes_1.BladeComponentNode) {
                                let allInsideComponent = true;
                                for (let j = i; j < this.bladeStartIndex.length; j++) {
                                    const checkIndex = this.bladeStartIndex[j];
                                    if (checkIndex > this.lastBladeEndIndex) {
                                        nextBladeStart = checkIndex;
                                        allInsideComponent = false;
                                        break;
                                    }
                                }
                                if (allInsideComponent) {
                                    const literalStart = this.currentIndex + offset;
                                    if (literalStart < this.inputLen && !this.isVerbatim) {
                                        const literalNode = new nodes_1.LiteralNode();
                                        literalNode.withParser(this);
                                        literalNode.content = this.prepareLiteralContent(this.content.substr(literalStart));
                                        if (literalNode.content.length > 0) {
                                            literalNode.startPosition = this.positionFromOffset(literalStart, literalStart);
                                            literalNode.endPosition = this.positionFromOffset(this.inputLen - 1, this.inputLen - 1);
                                            this.nodes.push(literalNode);
                                        }
                                        break;
                                    }
                                }
                            }
                            if (literalLength == 0 || this.isVerbatim) {
                                continue;
                            }
                            const nodeContent = this.content.substr(literalStartIndex, literalLength);
                            const literalNode = new nodes_1.LiteralNode();
                            literalNode.withParser(this);
                            literalNode.content = this.prepareLiteralContent(nodeContent);
                            if (literalNode.content.length > 0) {
                                literalNode.startPosition = this.positionFromOffset(literalStartIndex, literalStartIndex);
                                literalNode.endPosition = this.positionFromOffset(nextBladeStart, nextBladeStart - 1);
                                this.nodes.push(literalNode);
                            }
                        }
                        continue;
                    }
                    if (i !== lastIndex && this.lastNode != null && this.lastNode.endPosition != null) {
                        const startCandidate = this.positionFromOffset(offset, offset);
                        // Skip processing potentital nodes that are inside the last node.
                        if (startCandidate.isBefore(this.lastNode.endPosition)) {
                            if (i + 1 < indexCount) {
                                const nextBladeStart = this.bladeStartIndex[i + 1];
                                if (nextBladeStart < this.lastNode.endPosition.offset) {
                                    continue;
                                }
                            }
                            else {
                                if (i + 1 != lastIndex) {
                                    continue;
                                }
                            }
                        }
                    }
                    if (i == lastIndex) {
                        const literalStart = this.currentIndex + offset;
                        if (literalStart < this.inputLen && !this.isVerbatim) {
                            const literalNode = new nodes_1.LiteralNode();
                            literalNode.withParser(this);
                            literalNode.content = this.prepareLiteralContent(this.content.substr(literalStart));
                            if (literalNode.content.length > 0) {
                                literalNode.startPosition = this.positionFromOffset(literalStart, literalStart);
                                literalNode.endPosition = this.positionFromOffset(this.inputLen - 1, this.inputLen - 1);
                                this.nodes.push(literalNode);
                            }
                            break;
                        }
                    }
                }
            }
        }
        // Index the nodes.
        let curIndex = 0;
        this.nodes.forEach((node) => {
            node.index = curIndex;
            curIndex += 1;
        });
        let lastNode = null;
        for (let i = 0; i < this.nodes.length; i++) {
            const thisNode = this.nodes[i];
            let nextNode = null;
            if (i + 1 < this.nodes.length) {
                nextNode = this.nodes[i + 1];
            }
            thisNode.prevNode = lastNode;
            thisNode.nextNode = nextNode;
            lastNode = thisNode;
        }
        // Ask the PairManager to analyze the document to help build up the possible pairs.
        pairManager_1.PairManager.determineCandidates(this.nodes);
        this.nodes = conditionalRewriteAnalyzer_1.ConditionalRewriteAnalyzer.rewrite(this.nodes);
        const pairAnalyzer = new directivePairAnalyzer_1.DirectivePairAnalyzer();
        this.renderNodes = pairAnalyzer.associate(this.nodes, this);
        this.hasPairedStructures = pairAnalyzer.getPairsCreated() > 0;
        inlineEchoAnalyzer_1.InlineEchoAnalyzer.analyze(this.nodes);
        inlinePhpAnalyzer_1.InlinePhpAnalyzer.analyze(this.nodes);
        this.nodes.forEach((node) => {
            if (node instanceof nodes_1.DirectiveNode) {
                const directive = node, lowerName = directive.directiveName.toLowerCase();
                if (directive.isClosedBy != null) {
                    const directiveChildren = directive.getImmediateChildren();
                    for (let i = 0; i < directiveChildren.length; i++) {
                        const child = directiveChildren[i];
                        if (child instanceof nodes_1.DirectiveNode && child != directive.isClosedBy && child.isClosedBy != null) {
                            directive.containsChildStructures = true;
                            break;
                        }
                        else if (child instanceof nodes_1.ConditionNode || child instanceof nodes_1.SwitchStatementNode || child instanceof nodes_1.ForElseNode) {
                            directive.containsChildStructures = true;
                            break;
                        }
                    }
                }
                if ((lowerName == 'switch' && directive.isClosedBy == null) ||
                    (lowerName == 'endswitch' && directive.isOpenedBy == null)) {
                    directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_PARSE_UNCLOSED_SWITCH, directive, 'Unclosed switch control structure', bladeError_1.ErrrorLevel.Error));
                }
                else if (lowerName == 'php') {
                    if (directive.hasDirectiveParameters == false && directive.isClosedBy == null) {
                        directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_PHP_DIRECTIVE, directive, 'Unclosed @php directive', bladeError_1.ErrrorLevel.Error));
                    }
                }
                else if (lowerName == 'endphp' && directive.isOpenedBy == null) {
                    directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_PHP_CLOSING_DIRECTIVE, directive, 'Unpaired @endphp directive', bladeError_1.ErrrorLevel.Error));
                }
                else if (lowerName == 'verbatim' && directive.isClosedBy == null) {
                    directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_VERBATIM, directive, 'Unclosed @verbatim directive', bladeError_1.ErrrorLevel.Error));
                }
                else if (lowerName == 'endverbatim' && directive.isOpenedBy == null) {
                    directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_VERBATIM_CLOSING_DIRECTIVE, directive, 'Unpaired @endverbatim directive', bladeError_1.ErrrorLevel.Error));
                }
                else if (lowerName == 'for' && directive.isClosedBy == null) {
                    directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_FOR_DIRECTIVE, directive, 'Unclosed @for directive', bladeError_1.ErrrorLevel.Error));
                }
                else if (lowerName == 'for' && directive.isClosingDirective == true && directive.isOpenedBy == null) {
                    directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_FOR_CLOSING_DIRECTIVE, directive, 'Unpaired @endfor directive', bladeError_1.ErrrorLevel.Error));
                }
                else if (lowerName == 'forelse') {
                    if (directive.isClosedBy == null) {
                        directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_FOR_ELSE_DIRECTIVE, directive, 'Unclosed @forelse directive', bladeError_1.ErrrorLevel.Error));
                    }
                    const emptyChild = directive.findFirstDirectChildDirectiveOfType('empty');
                    if (emptyChild == null) {
                        directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_FOR_ELSE_MISSING_EMPTY_DIRECTIVE, directive, '@forelse missing @empty directive', bladeError_1.ErrrorLevel.Warning));
                    }
                }
                else if (lowerName == 'endforelse' && directive.isOpenedBy == null) {
                    directive.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNPAIRED_FOR_ELSE_CLOSING_DIRECTIVE, directive, 'Unpaired @endforelse directive', bladeError_1.ErrrorLevel.Error));
                }
            }
        });
        this.createChildDocuments(this.renderNodes);
        if (this.parseFragments && this.content.length > 0) {
            this.fragmentsParser
                .setIndexRanges(this.getNodeIndexRanges())
                .parse(fragmentTransformer_1.FragmentsTransformer.transform(this.nodes, this.content));
        }
        this.fragmentsAnalyzer.analyze();
        this.renderNodes.forEach((node) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            if (node instanceof nodes_1.ConditionNode) {
                node.fragment = (_b = (_a = node.constructedFrom) === null || _a === void 0 ? void 0 : _a.fragment) !== null && _b !== void 0 ? _b : null;
                node.fragmentPosition = (_d = (_c = node.constructedFrom) === null || _c === void 0 ? void 0 : _c.fragmentPosition) !== null && _d !== void 0 ? _d : nodes_1.FragmentPosition.Unresolved;
            }
            else if (node instanceof nodes_1.ForElseNode) {
                node.fragment = (_f = (_e = node.constructedFrom) === null || _e === void 0 ? void 0 : _e.fragment) !== null && _f !== void 0 ? _f : null;
                node.fragmentPosition = (_h = (_g = node.constructedFrom) === null || _g === void 0 ? void 0 : _g.fragmentPosition) !== null && _h !== void 0 ? _h : nodes_1.FragmentPosition.Unresolved;
            }
            else if (node instanceof nodes_1.SwitchStatementNode) {
                node.fragment = (_k = (_j = node.constructedFrom) === null || _j === void 0 ? void 0 : _j.fragment) !== null && _k !== void 0 ? _k : null;
                node.fragmentPosition = (_m = (_l = node.constructedFrom) === null || _l === void 0 ? void 0 : _l.fragmentPosition) !== null && _m !== void 0 ? _m : nodes_1.FragmentPosition.Unresolved;
            }
        });
        directiveStack_1.DirectiveStack.setChildTypeCounts(this.nodes);
        return this.renderNodes;
    }
    getNodeIndexRanges() {
        const indexRanges = [];
        this.nodes.forEach((node) => {
            var _a, _b, _c, _d;
            if ((node instanceof nodes_1.LiteralNode) == false) {
                indexRanges.push({
                    start: (_b = (_a = node.startPosition) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : 0,
                    end: (_d = (_c = node.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0
                });
            }
        });
        return indexRanges;
    }
    createChildDocuments(renderNodes) {
        renderNodes.forEach((node) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (node instanceof nodes_1.DirectiveNode && node.isClosedBy != null) {
                const isClosedBy = node.isClosedBy, docStart = ((_b = (_a = node.startPosition) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : 0) - 1, docLength = ((_d = (_c = isClosedBy.endPosition) === null || _c === void 0 ? void 0 : _c.index) !== null && _d !== void 0 ? _d : 0) - docStart;
                node.nodeContent = this.content.substr(docStart, docLength);
                const startOffset = ((_f = (_e = node.endPosition) === null || _e === void 0 ? void 0 : _e.index) !== null && _f !== void 0 ? _f : 0), length = (((_h = (_g = isClosedBy.startPosition) === null || _g === void 0 ? void 0 : _g.index) !== null && _h !== void 0 ? _h : 0) - 1) - startOffset, childText = this.content.substr(startOffset, length);
                node.childrenDocument = bladeDocument_1.BladeDocument.childFromText(childText, this, (0, helpers_1.getStartPosition)(node.getChildren()));
            }
        });
    }
    checkCurrentOffsets() {
        if (this.currentIndex > this.chars.length) {
            this.cur = null;
            this.prev = null;
            this.next = null;
            return;
        }
        // Fake the chunking behavior.
        const curChunk = Math.ceil(this.currentIndex / 5);
        if (curChunk > 0) {
            this.currentChunkOffset = this.parsingOffset + (this.chunkSize * curChunk);
        }
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (this.currentIndex > 0) {
            this.prev = this.chars[this.currentIndex - 1];
        }
        if ((this.currentIndex + 1) < this.inputLen) {
            if (this.currentIndex + 1 < this.chars.length) {
                this.next = this.chars[this.currentIndex + 1];
            }
        }
    }
    parseIntermediateText(offset) {
        this.currentContent = [];
        this.chars = this.content.substring(offset).split('');
        this.charLen = this.chars.length;
        let parsedNode = false;
        for (this.currentIndex = 0; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (this.isStartingShorthandPhp()) {
                this.scanToEndOfPhp(this.currentIndex, true);
                this.currentIndex += 2;
                this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
                this.currentContent = [];
                break;
            }
            if (this.isStartingPhp()) {
                this.scanToEndOfPhp(this.currentIndex);
                this.currentIndex += 2;
                this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
                this.currentContent = [];
                break;
            }
            if (this.isStartingDirective()) {
                this.currentIndex += 1;
                this.scanToEndOfDirective();
                this.currentContent = [];
                this.currentIndex += 1;
                parsedNode = true;
                break;
            }
            if (this.isStartingClosingComponentTag()) {
                const componentTagStartedOn = this.currentIndex;
                this.currentIndex += 4;
                this.currentContent = [];
                this.checkCurrentOffsets();
                this.isParsingComponent = true;
                this.scanToEndOfComponentTag(componentTagStartedOn, true);
                this.isParsingComponent = false;
                this.currentIndex += 3;
                this.currentContent = [];
                parsedNode = true;
                break;
            }
            if (this.isStartingOpeningComponentTag()) {
                const componentTagStartedOn = this.currentIndex;
                this.currentIndex += 3;
                this.currentContent = [];
                this.checkCurrentOffsets();
                this.isParsingComponent = true;
                this.scanToEndOfComponentTag(componentTagStartedOn, false);
                this.isParsingComponent = false;
                this.currentContent = [];
                this.currentIndex += 3;
                parsedNode = true;
                break;
            }
            if (this.isStartingEscapedEcho()) {
                const escapedEchoStartedOn = this.currentIndex;
                this.currentIndex += 3;
                this.currentContent = [];
                this.checkCurrentOffsets();
                this.scanToEndOfEscapedEcho(escapedEchoStartedOn);
                this.currentContent = [];
                this.currentIndex += 3;
                parsedNode = true;
                break;
            }
            if (this.isStartingBladeNodeStructure()) {
                const peekOne = this.peek(2), peekTwo = this.peek(3);
                // Check for comments.
                if (peekOne == DocumentParser.Punctuation_Minus && peekTwo == DocumentParser.Punctuation_Minus) {
                    const commentStartedOn = this.currentIndex;
                    this.currentIndex += 4;
                    this.currentContent = [];
                    this.checkCurrentOffsets();
                    this.scanToEndOfComment(commentStartedOn);
                    this.currentContent = [];
                    this.currentIndex += 4;
                    parsedNode = true;
                    break;
                }
                else {
                    if (peekOne == DocumentParser.LeftBrace) {
                        const echoStartedOn = this.currentIndex;
                        this.currentIndex += 3;
                        this.scanToEndOfBladeEntitiesEcho(echoStartedOn + 1);
                        this.currentContent = [];
                        this.currentIndex += 3;
                        parsedNode = true;
                        break;
                    }
                    else {
                        const echoStartedOn = this.currentIndex;
                        this.currentIndex += 2;
                        this.scanToEndOfBladeEcho(echoStartedOn + 1);
                        this.currentContent = [];
                        this.currentIndex += 2;
                        parsedNode = true;
                        break;
                    }
                }
            }
        }
        return parsedNode;
    }
    peek(count) {
        return this.chars[count];
    }
    peekRelative(count) {
        return this.peek(this.currentIndex + count);
    }
    scanToEndOfPhp(startedOn, isShorthand = false) {
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
                (0, skipToEndOfString_1.skipToEndOfString)(this);
            }
            if (this.cur == DocumentParser.Punctuation_ForwardSlash && this.next == DocumentParser.Punctuation_ForwardSlash) {
                this.shouldIgnoreStructures = true;
                (0, skipToEndOfLine_1.skipToEndOfLine)(this, true);
                this.shouldIgnoreStructures = false;
                continue;
            }
            if (this.cur == DocumentParser.Punctuation_ForwardSlash && this.next == DocumentParser.Punctuation_Asterisk) {
                this.shouldIgnoreStructures = true;
                (0, skipToEndOfMultilineComment_1.skipToEndOfMultilineComment)(this, true);
                this.shouldIgnoreStructures = false;
                continue;
            }
            if ((this.cur == DocumentParser.Punctuation_QuestionMark && this.next == DocumentParser.Punctuation_GreaterThan) || this.next == null) {
                let inlinePhp = new nodes_1.InlinePhpNode();
                this.hasPhpContent = true;
                if (isShorthand) {
                    inlinePhp = new nodes_1.ShorthandInlinePhpNode();
                }
                inlinePhp.withParser(this);
                inlinePhp.startPosition = this.positionFromOffset(startedOn + this.seedOffset, startedOn + this.seedOffset);
                inlinePhp.endPosition = this.positionFromOffset(this.currentIndex + 1 + this.seedOffset, this.currentIndex + 1 + this.seedOffset);
                const startOffset = inlinePhp.startPosition.index, length = (inlinePhp.endPosition.index - inlinePhp.startPosition.index) + 1;
                inlinePhp.sourceContent = this.content.substr(startOffset, length);
                this.nodes.push(inlinePhp);
                this.lastNode = inlinePhp;
                break;
            }
        }
    }
    scanToEndOfComponentTag(startedOn, isClosing) {
        let hasObservedNewLine = false, hasObservedSpace = false, newlineRecoveryIndex = -1, spaceRecoveryIndex = -1, createErrorNode = false;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (this.cur == DocumentParser.NewLine && !hasObservedNewLine) {
                hasObservedNewLine = true;
                newlineRecoveryIndex = this.currentIndex;
            }
            if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) && !hasObservedSpace) {
                hasObservedSpace = true;
                spaceRecoveryIndex = this.currentIndex;
            }
            if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
                this.shouldIgnoreStructures = true;
                (0, skipToEndOfString_1.skipToEndOfString)(this);
                this.shouldIgnoreStructures = false;
                continue;
            }
            const isClosingComponent = this.isClosingComponent();
            if (this.hasEncounteredAnotherStructure() || (this.next == null && !isClosingComponent)) {
                createErrorNode = true;
                if (newlineRecoveryIndex != -1) {
                    this.currentIndex = newlineRecoveryIndex - 2;
                    this.currentContent = this.currentContent.slice(0, newlineRecoveryIndex - 2);
                    this.didRecoveryLogic = true;
                }
                else if (spaceRecoveryIndex != -1) {
                    this.currentIndex = spaceRecoveryIndex - 2;
                    this.currentContent = this.currentContent.slice(0, spaceRecoveryIndex - 2);
                    this.didRecoveryLogic = true;
                }
            }
            if (isClosingComponent || createErrorNode) {
                const tagComponent = new nodes_1.BladeComponentNode();
                this.hasComponents = true;
                tagComponent.withParser(this);
                tagComponent.startPosition = this.positionFromOffset(startedOn + this.seedOffset, startedOn + this.seedOffset);
                tagComponent.endPosition = this.positionFromOffset(this.currentIndex + this.seedOffset, this.currentIndex + this.seedOffset);
                const startOffset = tagComponent.startPosition.index, length = (tagComponent.endPosition.index - tagComponent.startPosition.index) + 1, endOffset = startOffset + length;
                tagComponent.sourceContent = this.content.substr(startOffset, length);
                tagComponent.isClosingTag = isClosing;
                tagComponent.isSelfClosing = this.prev == DocumentParser.Punctuation_ForwardSlash;
                tagComponent.offset = {
                    start: startOffset,
                    end: endOffset,
                    length: length
                };
                let shiftRight = 3;
                if (tagComponent.isSelfClosing) {
                    shiftRight += 1;
                }
                tagComponent.innerContent = this.content.substr(tagComponent.startPosition.index + 3, (tagComponent.endPosition.index - tagComponent.startPosition.index) - shiftRight);
                if (createErrorNode) {
                    tagComponent.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT, tagComponent, 'Unexpected end of input while parsing component tag', bladeError_1.ErrrorLevel.Error));
                }
                this.componentParser.parse(tagComponent);
                this.currentContent = [];
                this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
                this.lastNode = tagComponent;
                this.nodes.push(tagComponent);
                break;
            }
        }
    }
    scanToEndOfEscapedEcho(startedOn) {
        let hasObservedNewLine = false, hasObservedSpace = false, newlineRecoveryIndex = -1, spaceRecoveryIndex = -1, createErrorNode = false;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (this.cur == DocumentParser.NewLine && !hasObservedNewLine) {
                hasObservedNewLine = true;
                newlineRecoveryIndex = this.currentIndex;
            }
            if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) && !hasObservedSpace) {
                hasObservedSpace = true;
                spaceRecoveryIndex = this.currentIndex;
            }
            if (this.hasEncounteredAnotherStructure() || this.next == null) {
                createErrorNode = true;
                if (newlineRecoveryIndex != -1) {
                    this.currentIndex = newlineRecoveryIndex - 2;
                    this.currentContent = this.currentContent.slice(0, newlineRecoveryIndex - 2);
                    this.didRecoveryLogic = true;
                }
                else if (spaceRecoveryIndex != -1) {
                    this.currentIndex = spaceRecoveryIndex - 2;
                    this.currentContent = this.currentContent.slice(0, spaceRecoveryIndex - 2);
                    this.didRecoveryLogic = true;
                }
            }
            // Check for !!}
            if ((this.cur == DocumentParser.Punctuation_Exclamation && this.next == DocumentParser.Punctuation_Exclamation && this.peekRelative(2) == DocumentParser.RightBrace) || createErrorNode) {
                const echoEnd = this.currentIndex + 2;
                const echoNode = new nodes_1.BladeEscapedEchoNode();
                echoNode.startPosition = this.positionFromOffset(startedOn + this.seedOffset, startedOn + this.seedOffset);
                echoNode.endPosition = this.positionFromOffset(echoEnd + this.seedOffset, echoEnd + this.seedOffset);
                echoNode.withParser(this);
                const startOffset = echoNode.startPosition.index, length = (echoNode.endPosition.index - echoNode.startPosition.index) + 1, endOffset = startOffset + length;
                echoNode.sourceContent = this.content.substr(startOffset, length);
                echoNode.offset = {
                    start: startOffset,
                    end: endOffset,
                    length: length
                };
                if (createErrorNode) {
                    echoNode.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT, echoNode, 'Unexpected end of input while parsing echo', bladeError_1.ErrrorLevel.Error));
                }
                echoNode.content = this.currentContent.join('');
                this.currentContent = [];
                this.lastBladeEndIndex = this.currentIndex + 2 + this.seedOffset;
                this.lastNode = echoNode;
                this.nodes.push(echoNode);
                break;
            }
            if (this.cur == null) {
                break;
            }
            this.currentContent.push(this.cur);
        }
    }
    scanToEndOfComment(startedOn) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        let hasObservedNewLine = false, hasObservedSpace = false, newlineRecoveryIndex = -1, spaceRecoveryIndex = -1, createErrorNode = false;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (this.cur == DocumentParser.NewLine && !hasObservedNewLine) {
                hasObservedNewLine = true;
                newlineRecoveryIndex = this.currentIndex;
            }
            if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) && !hasObservedSpace) {
                hasObservedSpace = true;
                spaceRecoveryIndex = this.currentIndex;
            }
            if (this.next == null) {
                createErrorNode = true;
                if (newlineRecoveryIndex != -1) {
                    this.currentIndex = newlineRecoveryIndex - 2;
                    this.currentContent = this.currentContent.slice(0, newlineRecoveryIndex - 2);
                    this.didRecoveryLogic = true;
                }
                else if (spaceRecoveryIndex != -1) {
                    this.currentIndex = spaceRecoveryIndex - 2;
                    this.currentContent = this.currentContent.slice(0, spaceRecoveryIndex - 2);
                    this.didRecoveryLogic = true;
                }
            }
            if ((this.cur == DocumentParser.Punctuation_Minus && this.next == DocumentParser.Punctuation_Minus) || this.next == null) {
                const peekOne = this.peekRelative(2), peekTwo = this.peekRelative(3);
                if ((peekOne == DocumentParser.RightBrace && peekTwo == DocumentParser.RightBrace) || this.next == null) {
                    const commentEnd = this.currentIndex + 3;
                    const comment = new nodes_1.BladeCommentNode();
                    comment.startPosition = this.positionFromOffset(startedOn + this.seedOffset, startedOn + this.seedOffset);
                    comment.endPosition = this.positionFromOffset(commentEnd + this.seedOffset, commentEnd + this.seedOffset);
                    comment.innerContentPosition = {
                        start: this.positionFromOffset(startedOn + 4 + this.seedOffset, startedOn + 4 + this.seedOffset),
                        end: this.positionFromOffset(commentEnd - 4 + this.seedOffset, commentEnd - 4 + this.seedOffset)
                    };
                    comment.withParser(this);
                    const startOffset = comment.startPosition.index, length = (comment.endPosition.index - comment.startPosition.index) + 1, endOffset = startOffset + length;
                    comment.sourceContent = this.content.substr(startOffset, length);
                    comment.offset = {
                        start: startOffset,
                        end: endOffset,
                        length: length
                    };
                    if (createErrorNode) {
                        comment.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNCLOSED_COMMENT, comment, 'Unexpected end of input while parsing comment', bladeError_1.ErrrorLevel.Error));
                    }
                    comment.innerContent = this.content.substr(((_c = (_b = (_a = comment.innerContentPosition) === null || _a === void 0 ? void 0 : _a.start) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : 0), (((_f = (_e = (_d = comment.innerContentPosition) === null || _d === void 0 ? void 0 : _d.end) === null || _e === void 0 ? void 0 : _e.index) !== null && _f !== void 0 ? _f : 0) - ((_j = (_h = (_g = comment.innerContentPosition) === null || _g === void 0 ? void 0 : _g.start) === null || _h === void 0 ? void 0 : _h.index) !== null && _j !== void 0 ? _j : 0)) + 1);
                    this.currentContent = [];
                    this.lastBladeEndIndex = this.currentIndex + 3 + this.seedOffset;
                    this.lastNode = comment;
                    this.nodes.push(comment);
                    break;
                }
                else {
                    if (this.cur != null) {
                        this.currentContent.push(this.cur);
                    }
                    continue;
                }
            }
            if (this.cur == null) {
                break;
            }
            this.currentContent.push(this.cur);
        }
    }
    scanToEndOfBladeEntitiesEcho(startedOn) {
        let hasObservedNewLine = false, hasObservedSpace = false, newlineRecoveryIndex = -1, spaceRecoveryIndex = -1, createErrorNode = false;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (this.cur == DocumentParser.NewLine && !hasObservedNewLine) {
                hasObservedNewLine = true;
                newlineRecoveryIndex = this.currentIndex;
            }
            if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) && !hasObservedSpace) {
                hasObservedSpace = true;
                spaceRecoveryIndex = this.currentIndex;
            }
            if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
                const stringStart = this.cur;
                this.shouldIgnoreStructures = true;
                const results = (0, skipToEndOfString_1.skipToEndOfStringTraced)(this);
                this.shouldIgnoreStructures = false;
                this.currentIndex = results.endedOn;
                this.currentContent.push(stringStart);
                this.currentContent = this.currentContent.concat(results.value.split(''));
                this.currentContent.push(stringStart);
                this.currentIndex = results.endedOn;
                continue;
            }
            if (this.hasEncounteredAnotherStructure() || this.next == null) {
                createErrorNode = true;
                if (newlineRecoveryIndex != -1) {
                    this.currentIndex = newlineRecoveryIndex - 2;
                    this.currentContent = this.currentContent.slice(0, newlineRecoveryIndex - 2);
                    this.didRecoveryLogic = true;
                }
                else if (spaceRecoveryIndex != -1) {
                    this.currentIndex = spaceRecoveryIndex - 2;
                    this.currentContent = this.currentContent.slice(0, spaceRecoveryIndex - 2);
                    this.didRecoveryLogic = true;
                }
            }
            if ((this.cur == DocumentParser.RightBrace && this.next == DocumentParser.RightBrace && this.peekRelative(2) == DocumentParser.RightBrace) || createErrorNode) {
                const echoEnd = this.currentIndex + 1;
                const echoNode = new nodes_1.BladeEntitiesEchoNode();
                echoNode.startPosition = this.positionFromOffset(startedOn + this.seedOffset, startedOn + this.seedOffset);
                echoNode.endPosition = this.positionFromOffset(echoEnd + this.seedOffset, echoEnd + this.seedOffset);
                echoNode.withParser(this);
                const startOffset = echoNode.startPosition.index - 1, length = (echoNode.endPosition.index - echoNode.startPosition.index) + 3, endOffset = startOffset + length;
                echoNode.sourceContent = this.content.substr(startOffset, length);
                echoNode.offset = {
                    start: startOffset,
                    end: endOffset,
                    length: length
                };
                if (createErrorNode) {
                    echoNode.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT, echoNode, 'Unexpected end of input while parsing echo', bladeError_1.ErrrorLevel.Error));
                }
                echoNode.content = this.currentContent.join('');
                this.currentContent = [];
                this.lastBladeEndIndex = this.currentIndex + 2 + this.seedOffset;
                this.lastNode = echoNode;
                this.nodes.push(echoNode);
                break;
            }
            if (this.cur == null) {
                break;
            }
            this.currentContent.push(this.cur);
        }
    }
    scanToEndOfBladeEcho(startedOn) {
        let hasObservedNewLine = false, hasObservedSpace = false, newlineRecoveryIndex = -1, spaceRecoveryIndex = -1, createErrorNode = false;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (this.cur == DocumentParser.NewLine && !hasObservedNewLine) {
                hasObservedNewLine = true;
                newlineRecoveryIndex = this.currentIndex;
            }
            if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur) && !hasObservedSpace) {
                hasObservedSpace = true;
                spaceRecoveryIndex = this.currentIndex;
            }
            if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
                const stringStart = this.cur;
                this.shouldIgnoreStructures = true;
                const results = (0, skipToEndOfString_1.skipToEndOfStringTraced)(this);
                this.shouldIgnoreStructures = false;
                this.currentIndex = results.endedOn;
                this.currentContent.push(stringStart);
                this.currentContent = this.currentContent.concat(results.value.split(''));
                this.currentContent.push(stringStart);
                this.currentIndex = results.endedOn;
                continue;
            }
            if (this.hasEncounteredAnotherStructure() || this.next == null) {
                createErrorNode = true;
                if (newlineRecoveryIndex != -1) {
                    this.currentIndex = newlineRecoveryIndex - 2;
                    this.currentContent = this.currentContent.slice(0, newlineRecoveryIndex - 2);
                    this.didRecoveryLogic = true;
                }
                else if (spaceRecoveryIndex != -1) {
                    this.currentIndex = spaceRecoveryIndex - 2;
                    this.currentContent = this.currentContent.slice(0, spaceRecoveryIndex - 2);
                    this.didRecoveryLogic = true;
                }
            }
            if ((this.cur == DocumentParser.RightBrace && this.next == DocumentParser.RightBrace) || createErrorNode) {
                const echoEnd = this.currentIndex + 1;
                const echoNode = new nodes_1.BladeEchoNode();
                echoNode.startPosition = this.positionFromOffset(startedOn + this.seedOffset, startedOn + this.seedOffset);
                echoNode.endPosition = this.positionFromOffset(echoEnd + this.seedOffset, echoEnd + this.seedOffset);
                echoNode.withParser(this);
                const startOffset = echoNode.startPosition.index - 1, length = (echoNode.endPosition.index - echoNode.startPosition.index) + 2, endOffset = startOffset + length;
                echoNode.sourceContent = this.content.substr(startOffset, length);
                echoNode.offset = {
                    start: startOffset,
                    end: endOffset,
                    length: length
                };
                if (createErrorNode) {
                    echoNode.pushError(bladeError_1.BladeError.makeSyntaxError(bladeErrorCodes_1.BladeErrorCodes.TYPE_UNEXPECTED_END_OF_INPUT, echoNode, 'Unexpected end of input while parsing echo', bladeError_1.ErrrorLevel.Error));
                }
                echoNode.content = this.currentContent.join('');
                this.currentContent = [];
                this.lastBladeEndIndex = this.currentIndex + 1 + this.seedOffset;
                this.lastNode = echoNode;
                this.nodes.push(echoNode);
                break;
            }
            if (this.cur == null) {
                break;
            }
            this.currentContent.push(this.cur);
        }
    }
    makeDirective(name, nameStartsOn, nameEndsOn) {
        const directive = new nodes_1.DirectiveNode();
        directive.withParser(this);
        if (name == bladeKeywords_1.BladeKeywords.Verbatim) {
            this.isVerbatim = true;
        }
        else if (name == bladeKeywords_1.BladeKeywords.Php) {
            this.isPhpNode = true;
        }
        else if (name == bladeKeywords_1.BladeKeywords.EndVerbatim || name == bladeKeywords_1.BladeKeywords.EndPhp) {
            const lastNode = this.nodes[this.nodes.length - 1];
            if (lastNode instanceof nodes_1.LiteralNode) {
                const literal = this.nodes.pop();
                if (this.nodes[this.nodes.length - 1] instanceof nodes_1.DirectiveNode) {
                    const openNode = this.nodes[this.nodes.length - 1];
                    if (openNode.directiveName == bladeKeywords_1.BladeKeywords.Verbatim || openNode.directiveName == bladeKeywords_1.BladeKeywords.Php) {
                        openNode.innerContent = literal.content;
                    }
                }
            }
        }
        directive.directiveName = name.trim();
        directive.name = name.trim();
        const lowerName = directive.name.toLowerCase();
        if (lowerName == 'endcan' || lowerName == 'endcannot' || lowerName == 'endauth' || lowerName == 'endguest' || lowerName == 'endenv' || lowerName == 'endproduction') {
            directive.name = 'if';
            directive.isClosingDirective = true;
        }
        else if (name.startsWith('end')) {
            directive.name = name.substring(3);
        }
        else if (name.startsWith('else') && name != 'elseif' && name != 'else') {
            directive.name = 'elseif';
        }
        const nameStartPosition = this.positionFromOffset(this.seedOffset + nameStartsOn, this.seedOffset + nameStartsOn), nameEndPosition = this.positionFromOffset(this.seedOffset + nameEndsOn, this.seedOffset + nameEndsOn);
        directive.startPosition = nameStartPosition;
        directive.endPosition = nameEndPosition;
        directive.namePosition = {
            start: nameStartPosition,
            end: nameEndPosition
        };
        directive.hasDirectiveParameters = false;
        if (directive.startPosition != null && directive.endPosition != null) {
            const startOffset = directive.startPosition.index - 1, length = (directive.endPosition.index - directive.startPosition.index) + 1, endOffset = startOffset + length;
            directive.sourceContent = this.content.substr(startOffset, length);
            directive.offset = {
                start: startOffset,
                end: endOffset,
                length: length
            };
        }
        return directive;
    }
    makeDirectiveWithParameters(name, nameStartsOn, nameEndsOn, params) {
        var _a, _b;
        const directive = this.makeDirective(name.trim(), nameStartsOn, nameEndsOn);
        if (this.isPhpNode && name == bladeKeywords_1.BladeKeywords.Php) {
            this.isPhpNode = false;
        }
        directive.hasDirectiveParameters = true;
        directive.directiveParameters = params.content;
        // Check to see if the directive probably contains JSON params.
        let checkParams = params.content.trim();
        if (checkParams.startsWith('(') && checkParams.endsWith(')')) {
            checkParams = checkParams.substring(1);
            checkParams = checkParams.substring(0, checkParams.length - 1);
            checkParams = checkParams.trim();
            directive.hasJsonParameters = checkParams.startsWith('{') && checkParams.endsWith('}');
        }
        const directiveParamtersStartPosition = this.positionFromOffset(params.start, params.start), directiveParametersEndPosition = this.positionFromOffset(params.end, params.end);
        directive.startPosition = (_b = (_a = directive.namePosition) === null || _a === void 0 ? void 0 : _a.start) !== null && _b !== void 0 ? _b : null;
        directive.endPosition = directiveParametersEndPosition;
        directive.directiveParametersPosition = {
            start: directiveParamtersStartPosition,
            end: directiveParametersEndPosition
        };
        if (directive.startPosition != null && directive.endPosition != null) {
            const startOffset = directive.startPosition.index - 1, length = (directive.endPosition.index - directive.startPosition.index) + 1, endOffset = startOffset + length;
            directive.sourceContent = this.content.substr(startOffset, length);
            directive.offset = {
                start: startOffset,
                end: endOffset,
                length: length
            };
        }
        return directive;
    }
    scanToEndOfDirective() {
        const directiveNameStartsOn = this.currentIndex;
        let directiveName = '', directiveNameEndsOn = 0;
        for (this.currentIndex; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (this.cur == DocumentParser.Punctuation_ForwardSlash && this.next == DocumentParser.Punctuation_Asterisk) {
                this.shouldIgnoreStructures = true;
                (0, skipToEndOfMultilineComment_1.skipToEndOfMultilineComment)(this, true);
                this.shouldIgnoreStructures = false;
                continue;
            }
            if (this.cur == DocumentParser.Punctuation_ForwardSlash && this.next == DocumentParser.Punctuation_ForwardSlash) {
                this.shouldIgnoreStructures = true;
                (0, skipToEndOfLine_1.skipToEndOfLine)(this, true);
                this.shouldIgnoreStructures = false;
                continue;
            }
            if (this.cur == DocumentParser.NewLine) {
                directiveNameEndsOn = this.currentIndex;
                directiveName = this.currentContent.join('');
                this.currentContent = [];
                const directive = this.makeDirective(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn);
                this.lastNode = directive;
                this.nodes.push(directive);
                this.lastBladeEndIndex = this.currentIndex + this.seedOffset - 1;
                break;
            }
            else if (this.next == null) {
                this.currentContent.push(this.cur);
                directiveNameEndsOn = this.currentIndex + 1;
                directiveName = this.currentContent.join('');
                this.currentContent = [];
                const directive = this.makeDirective(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn);
                this.lastNode = directive;
                this.nodes.push(directive);
                this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
                break;
            }
            const nextNonWs = (0, nextNonWhitespace_1.nextNonWhitespace)(this);
            if (this.cur != DocumentParser.LeftParen && nextNonWs.didFind && stringUtilities_1.StringUtilities.ctypePunct(nextNonWs.char)) {
                if (nextNonWs.char != DocumentParser.LeftParen && nextNonWs.char != DocumentParser.Punctuation_Minus && nextNonWs.char != '.') {
                    let endOffset = 0, brokeOnWhiteSpace = false;
                    if (!stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
                        this.currentContent.push(this.cur);
                    }
                    else {
                        endOffset = 1;
                        brokeOnWhiteSpace = true;
                    }
                    directiveNameEndsOn = this.currentIndex + 1;
                    directiveName = this.currentContent.join('');
                    this.currentContent = [];
                    const directive = this.makeDirective(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn - endOffset);
                    this.lastNode = directive;
                    this.nodes.push(directive);
                    this.lastBladeEndIndex = this.currentIndex + this.seedOffset - endOffset;
                    if (brokeOnWhiteSpace) {
                        this.currentIndex -= 1;
                    }
                    break;
                }
            }
            if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
                const nextNonWs = (0, nextNonWhitespace_1.nextNonWhitespace)(this);
                if (nextNonWs.didFind && nextNonWs.char == DocumentParser.LeftParen) {
                    directiveNameEndsOn = this.currentIndex - 1;
                    directiveName = this.currentContent.join('');
                    this.currentContent = [];
                    this.currentIndex = nextNonWs.index;
                    this.checkCurrentOffsets();
                    const logicGroupResults = (0, scanToEndOfLogicGroup_1.scanToEndOfLogicGroup)(this);
                    let directive;
                    if (logicGroupResults.foundEnd) {
                        directive = this.makeDirectiveWithParameters(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn, logicGroupResults);
                    }
                    else {
                        directive = this.makeDirective(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn);
                        this.didRecoveryLogic = true;
                    }
                    this.lastNode = directive;
                    this.nodes.push(directive);
                    this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
                    break;
                }
                else {
                    directiveNameEndsOn = this.currentIndex;
                    directiveName = this.currentContent.join('');
                    this.currentContent = [];
                    const directive = this.makeDirective(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn);
                    this.lastNode = directive;
                    this.nodes.push(directive);
                    this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
                    break;
                }
            }
            else if (this.cur == DocumentParser.LeftParen) {
                directiveNameEndsOn = this.currentIndex - 1;
                directiveName = this.currentContent.join('');
                this.currentContent = [];
                const logicGroupResults = (0, scanToEndOfLogicGroup_1.scanToEndOfLogicGroup)(this);
                let directive;
                if (logicGroupResults.foundEnd) {
                    directive = this.makeDirectiveWithParameters(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn, logicGroupResults);
                }
                else {
                    directive = this.makeDirective(directiveName.trim(), directiveNameStartsOn, directiveNameEndsOn + 1);
                }
                this.lastNode = directive;
                this.nodes.push(directive);
                this.lastBladeEndIndex = this.currentIndex + this.seedOffset;
                break;
            }
            if (this.cur == null) {
                break;
            }
            this.currentContent.push(this.cur);
        }
    }
    getText(start, end) {
        return this.content.substr(start, (end - start));
    }
    getNodeText(nodes) {
        let text = '';
        nodes.forEach((node) => {
            var _a, _b, _c, _d, _e;
            if (node instanceof nodes_1.LiteralNode) {
                text += node.content;
            }
            else {
                if (node instanceof nodes_1.ForElseNode) {
                    text += node.nodeContent;
                }
                else if (node instanceof nodes_1.SwitchStatementNode) {
                    text += node.nodeContent;
                }
                else if (node instanceof nodes_1.ConditionNode) {
                    text += node.nodeContent;
                }
                else if (node instanceof nodes_1.DirectiveNode) {
                    if ((node.name == 'php' || node.name == 'verbatim') && node.isClosedBy != null) {
                        if (node.documentContent.trim().length == 0) {
                            const content = (_a = node.getParser()) === null || _a === void 0 ? void 0 : _a.getText(((_c = (_b = node.endPosition) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : 0), ((_e = (_d = node.isClosedBy.startPosition) === null || _d === void 0 ? void 0 : _d.index) !== null && _e !== void 0 ? _e : 0) - 1);
                            text += node.sourceContent;
                            text += content;
                        }
                    }
                    else {
                        text += node.sourceContent;
                    }
                }
                else {
                    text += node.sourceContent;
                }
            }
        });
        return text;
    }
    getNodes() {
        return this.nodes;
    }
    getNodesBetween(start, end) {
        const returnNodes = [];
        this.nodes.forEach((node) => {
            var _a, _b, _c, _d;
            if (((_b = (_a = node.startPosition) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0) > start.offset && ((_d = (_c = node.endPosition) === null || _c === void 0 ? void 0 : _c.offset) !== null && _d !== void 0 ? _d : 0) < end.offset) {
                returnNodes.push(node);
            }
        });
        return returnNodes;
    }
    getRenderNodes() {
        return this.renderNodes;
    }
    prepareLiteralContent(content) {
        return content;
    }
    positionFromOffset(offset, index, isRelativeOffset = false) {
        let lineToUse = 0, charToUse = 0;
        if (!this.documentOffsets.has(offset)) {
            if (this.documentOffsets.size == 0) {
                lineToUse = 1;
                charToUse = offset + 1;
            }
            else {
                let nearestOffset = null, nearestOffsetIndex = null, lastOffset = null, lastOffsetIndex = null;
                for (const documentOffset of this.documentOffsets.keys()) {
                    if (documentOffset >= offset) {
                        if (lastOffsetIndex != null && offset > lastOffsetIndex) {
                            nearestOffset = lastOffset;
                            nearestOffsetIndex = lastOffsetIndex;
                        }
                        else {
                            nearestOffset = this.documentOffsets.get(documentOffset);
                            nearestOffsetIndex = documentOffset;
                        }
                        break;
                    }
                    lastOffset = this.documentOffsets.get(documentOffset);
                    lastOffsetIndex = documentOffset;
                }
                if (nearestOffset == null) {
                    nearestOffset = lastOffset;
                    nearestOffsetIndex = lastOffsetIndex;
                }
                if (nearestOffset != null) {
                    if (isRelativeOffset) {
                        const tChar = offset - (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0);
                        charToUse = tChar;
                        lineToUse = nearestOffset.line;
                        if (offset <= (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0)) {
                            lineToUse = nearestOffset.line;
                            charToUse = offset + 1;
                        }
                        else {
                            lineToUse = nearestOffset.line + 1;
                        }
                    }
                    else {
                        const tChar = offset - (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0);
                        charToUse = tChar;
                        lineToUse = nearestOffset.line;
                        if (offset <= (nearestOffsetIndex !== null && nearestOffsetIndex !== void 0 ? nearestOffsetIndex : 0)) {
                            lineToUse = nearestOffset.line;
                            charToUse = offset + 1;
                        }
                        else {
                            lineToUse = nearestOffset.line + 1;
                        }
                    }
                }
                else {
                    if (this.lastDocumentOffsetKey != null) {
                        const lastOffset = this.documentOffsets.get(this.lastDocumentOffsetKey);
                        lineToUse = lastOffset.line + 1;
                        charToUse = offset + this.lastDocumentOffsetKey;
                    }
                }
            }
        }
        else {
            const offsetDetails = this.documentOffsets.get(offset);
            lineToUse = offsetDetails.line;
            charToUse = offsetDetails.char;
        }
        const position = new position_1.Position();
        position.index = index;
        position.offset = offset;
        position.line = lineToUse + this.shiftLine;
        position.char = charToUse;
        return position;
    }
}
exports.DocumentParser = DocumentParser;
DocumentParser.K_CHAR = 'char';
DocumentParser.K_LINE = 'line';
DocumentParser.NewLine = "\n";
DocumentParser.AtChar = '@';
DocumentParser.Punctuation_Colon = ':';
DocumentParser.Punctuation_QuestionMark = '?';
DocumentParser.LeftParen = '(';
DocumentParser.RightParen = ')';
DocumentParser.LeftBrace = '{';
DocumentParser.RightBrace = '}';
DocumentParser.String_Terminator_DoubleQuote = '"';
DocumentParser.String_Terminator_SingleQuote = "'";
DocumentParser.Punctuation_LessThan = '<';
DocumentParser.Punctuation_GreaterThan = '>';
DocumentParser.Punctuation_Equals = '=';
DocumentParser.Punctuation_Exclamation = '!';
DocumentParser.LeftBracket = '[';
DocumentParser.RightBracket = ']';
DocumentParser.Punctuation_Comma = ',';
DocumentParser.Punctuation_Minus = '-';
DocumentParser.Punctuation_Asterisk = '*';
DocumentParser.Punctuation_ForwardSlash = '/';
DocumentParser.Punctuation_Underscore = '_';
DocumentParser.String_EscapeCharacter = '\\';
//# sourceMappingURL=documentParser.js.map