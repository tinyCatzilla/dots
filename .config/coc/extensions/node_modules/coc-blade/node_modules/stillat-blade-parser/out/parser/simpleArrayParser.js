"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleArrayParser = void 0;
const nodes_1 = require("../nodes/nodes");
const stringUtilities_1 = require("../utilities/stringUtilities");
const documentParser_1 = require("./documentParser");
const isStartOfString_1 = require("./scanners/isStartOfString");
const skipToEndOfString_1 = require("./scanners/skipToEndOfString");
class SimpleArrayParser {
    constructor() {
        this.content = '';
        this.chars = [];
        this.inputLen = 0;
        this.prev = null;
        this.cur = null;
        this.next = null;
        this.currentIndex = 0;
        this.currentContent = [];
        this.tokens = [];
        this.createdArrays = [];
        this.keyValueTokens = 0;
        this.elements = 0;
    }
    advance(count) {
        for (let i = 0; i < count; i++) {
            this.currentIndex++;
            this.checkCurrentOffsets();
        }
    }
    encounteredFailure() {
        return;
    }
    updateIndex(index) {
        this.currentIndex = index;
    }
    inputLength() {
        return this.inputLen;
    }
    getCurrentIndex() {
        return this.currentIndex;
    }
    incrementIndex() {
        this.currentIndex += 1;
    }
    getCurrent() {
        return this.cur;
    }
    getNext() {
        return this.next;
    }
    getPrev() {
        return this.prev;
    }
    checkCurrentOffsets() {
        this.cur = this.chars[this.currentIndex];
        this.prev = null;
        this.next = null;
        if (this.currentIndex > 0) {
            this.prev = this.chars[this.currentIndex - 1];
        }
        if ((this.currentIndex + 1) < this.inputLen) {
            this.next = this.chars[this.currentIndex + 1];
        }
    }
    pushChar(value) {
        this.currentContent.push(value);
    }
    getChar(index) {
        return this.chars[index];
    }
    getSeedOffset() {
        return 0;
    }
    getContentSubstring(from, length) {
        return this.content.substr(from, length);
    }
    getNumberOfElements() {
        return this.elements;
    }
    getNumberOfKeyValuePairs() {
        return this.keyValueTokens;
    }
    getIsAssoc() {
        return this.elements == this.keyValueTokens;
    }
    checkCurrentContent() {
        if (this.currentContent.length > 0) {
            const value = this.currentContent.join(''), valueNode = new nodes_1.AbstractNode();
            if (value.trim().length == 0) {
                this.currentContent = [];
                return;
            }
            valueNode.sourceContent = value;
            this.tokens.push(valueNode);
            this.currentContent = [];
        }
    }
    parse(text) {
        this.content = stringUtilities_1.StringUtilities.normalizeLineEndings(text);
        this.chars = this.content.split('');
        this.inputLen = this.chars.length;
        // Break the input string into tokens to help build on the final array nodes.
        for (this.currentIndex = 0; this.currentIndex < this.inputLen; this.currentIndex += 1) {
            this.checkCurrentOffsets();
            if (stringUtilities_1.StringUtilities.ctypeSpace(this.cur)) {
                continue;
            }
            if ((0, isStartOfString_1.isStartOfString)(this.cur)) {
                const terminator = this.cur, results = (0, skipToEndOfString_1.skipToEndOfStringTraced)(this);
                this.pushChar(terminator);
                this.currentContent = this.currentContent.concat(results.value.split(''));
                this.pushChar(terminator);
                this.currentIndex = results.endedOn;
                continue;
            }
            if (this.cur == documentParser_1.DocumentParser.LeftBracket) {
                this.checkCurrentContent();
                this.tokens.push(new nodes_1.ArrayStartNode());
                continue;
            }
            else if (this.cur == documentParser_1.DocumentParser.RightBracket) {
                this.checkCurrentContent();
                this.tokens.push(new nodes_1.ArrayEndNode());
            }
            else if (this.cur == documentParser_1.DocumentParser.Punctuation_Comma) {
                this.checkCurrentContent();
                this.tokens.push(new nodes_1.ArrayElementSeparatorNode());
                this.currentContent = [];
            }
            else if (this.cur == documentParser_1.DocumentParser.Punctuation_Equals && this.next == documentParser_1.DocumentParser.Punctuation_GreaterThan) {
                this.checkCurrentContent();
                this.currentIndex += 1;
                this.tokens.push(new nodes_1.ArrayKeyValueNode());
                continue;
            }
            else {
                this.currentContent.push(this.cur);
            }
        }
        const array = this.parseArrays(this.tokens);
        this.fillArrayDetails();
        array === null || array === void 0 ? void 0 : array.elements.filter(function (el) {
            if (el.value instanceof nodes_1.ArrayElementSeparatorNode) {
                return false;
            }
            return true;
        }).forEach((el) => {
            this.elements += 1;
            if (el.key != null && el.value != null) {
                this.keyValueTokens += 1;
            }
        });
        return array;
    }
    fillArrayDetails() {
        this.createdArrays.forEach((array) => {
            array.elements.forEach((element, index) => {
                if (element.key != null) {
                    array.containsKeys = true;
                    if (element.key.sourceContent.length > array.maxKeyLength) {
                        array.maxKeyLength = element.key.sourceContent.length;
                    }
                }
                element.isLast = index == array.elements.length - 1;
            });
        });
    }
    parseArrays(tokens) {
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            if (token instanceof nodes_1.ArrayStartNode) {
                const arrayNodes = this.findEndOfArray(tokens.slice(i));
                i += arrayNodes.length;
                arrayNodes.shift();
                arrayNodes.pop();
                return this.createArray(arrayNodes, true);
            }
        }
        return null;
    }
    createArray(tokens, isRoot) {
        const returnArray = new nodes_1.ArrayNode();
        this.createdArrays.push(returnArray);
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            let nextToken = null;
            if (i + 1 < tokens.length) {
                nextToken = tokens[i + 1];
            }
            if (nextToken instanceof nodes_1.ArrayElementSeparatorNode || nextToken == null) {
                const element = new nodes_1.ArrayElementNode();
                element.value = token;
                returnArray.elements.push(element);
                i += 1;
                continue;
            }
            else if (nextToken instanceof nodes_1.ArrayKeyValueNode) {
                const valueNode = tokens[i + 2];
                if (valueNode instanceof nodes_1.ArrayStartNode == false) {
                    const element = new nodes_1.ArrayElementNode();
                    element.key = token;
                    element.value = valueNode;
                    returnArray.elements.push(element);
                    i += 3;
                    continue;
                }
                else {
                    const arrayNodes = this.findEndOfArray(tokens.slice(i + 2)), element = new nodes_1.ArrayElementNode();
                    i += arrayNodes.length + 1;
                    arrayNodes.shift();
                    arrayNodes.pop();
                    element.key = token;
                    element.value = this.createArray(arrayNodes, false);
                    returnArray.elements.push(element);
                    continue;
                }
            }
            else if (token instanceof nodes_1.ArrayStartNode) {
                const arrayNodes = this.findEndOfArray(tokens.slice(i)), element = new nodes_1.ArrayElementNode();
                i += arrayNodes.length;
                arrayNodes.shift();
                arrayNodes.pop();
                element.value = this.createArray(arrayNodes, false);
                continue;
            }
        }
        return returnArray;
    }
    findEndOfArray(tokens) {
        const arrayTokens = [];
        let stackCount = 0;
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            arrayTokens.push(token);
            if (token instanceof nodes_1.ArrayStartNode) {
                stackCount += 1;
                continue;
            }
            else if (token instanceof nodes_1.ArrayEndNode) {
                stackCount -= 1;
                if (stackCount <= 0) {
                    break;
                }
                continue;
            }
        }
        return arrayTokens;
    }
}
exports.SimpleArrayParser = SimpleArrayParser;
//# sourceMappingURL=simpleArrayParser.js.map