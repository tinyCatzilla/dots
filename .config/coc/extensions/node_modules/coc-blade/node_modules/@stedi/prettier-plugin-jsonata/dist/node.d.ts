import { JsonataASTNode, ObjectUnaryNode, ArrayUnaryNode, StringNode, NullNode, NumberNode, LiteralNode, FunctionNode, PartialFunctionNode, SortNode, NegationUnaryNode, NameNode, LambdaNode, ParentNode, FilterNode, VariableNode, ConditionNode, BinaryNode, BindNode, ValueNode, OperatorNode, PathNode, BlockNode, ApplyNode, WildcardNode, UnaryNode, DescendantNode, RegexNode } from "./types";
/**
 * Checks whether the node represents AST that evaluates to an object.
 * For example, `{"foo": "bar"}` expression would evaluate to AST that fulfills checks within this function.
 *
 * The `isObjectUnaryNode` only checks the underlying structure, and the number of properties or types of values is of no concern for this function.
 */
export declare const isObjectUnaryNode: (node: JsonataASTNode) => node is ObjectUnaryNode;
export declare const isOperatorNode: (node: JsonataASTNode) => node is OperatorNode;
/**
 * Checks whether the node represents and AST that evaluates an array.
 * For example, `[{property: "value"}, {property: "otherValue"}]`, `[1, true, "string"]`, and `[]` expressions would evaluate to AST that fulfills checks within this function.
 */
export declare const isArrayUnaryNode: (node: JsonataASTNode) => node is ArrayUnaryNode;
export declare const isValueNode: (node: JsonataASTNode) => node is ValueNode;
export declare const isStringNode: (node: JsonataASTNode) => node is StringNode;
export declare const isNullNode: (node: JsonataASTNode) => node is NullNode;
export declare const isNumberNode: (node: JsonataASTNode) => node is NumberNode;
/**
 * Checks whether the node represents an AST that evaluates to a primitive node.
 * For example, the `true`, `"hello"` or `1` would all evaluate to AST that fullfil checks within this function.
 */
export declare const isPrimitiveNode: (node: JsonataASTNode) => node is LiteralNode;
/**
 * Checks whether the node represents an AST that evaluates to a JSONata function.
 * For example, the `$length("hi")` would evaluate to AST that fullfil checks within this function.
 */
export declare const isFunctionNode: (node: JsonataASTNode) => node is FunctionNode;
/**
 * Checks whether the node represents an AST that evaluates to a partially applied function.
 * For example, the `$substring(?, 0, 5)` would evaluate to AST that fullfil checks within this function.
 *
 * Please note, that the partial function has to be declared within a block.
 * More info here: https://docs.jsonata.org/programming#partial-function-application
 */
export declare const isPartialFunctionNode: (node: JsonataASTNode) => node is PartialFunctionNode;
/**
 * Checks whether the node represents an AST that evaluates to a `^` symbol in the context of path operators.
 * For example, given the `Product^(Price)` expression, the `^` symbol would evaluate to AST that fullfil checks within this function.
 *
 * More info here: https://docs.jsonata.org/path-operators#---order-by
 */
export declare const isSortNode: (node: JsonataASTNode) => node is SortNode;
export declare const isNegationNode: (node: JsonataASTNode) => node is NegationUnaryNode;
/**
 * Checks whether the node represents an AST that evaluates to a key in key:value structure.
 * For example, given the `{foo: "bar"}` expression, the `foo:` would evaluate to AST that fullfil checks within this function.
 */
export declare const isNameNode: (node: JsonataASTNode) => node is NameNode;
/**
 * Checks whether the node represents an AST that evaluates to a antonymous function declaration.
 * For example, the `function($a, $b){$a + $b}` expression would evaluate to AST that fullfil checks within this function.
 */
export declare const isLambdaNode: (node: JsonataASTNode) => node is LambdaNode;
/**
 * Checks whether the node represents an AST that evaluates to a "%" symbol in the context of path operations.
 * For example, given the `MyParent.{'OrderID': %.OrderId}` expression, the `%` would evaluate to AST that fullfil checks within this function.
 */
export declare const isParentNode: (node: JsonataASTNode) => node is ParentNode;
/**
 * Checks whether the node represents an AST that evaluates to a filter expression predicate.
 * For example, given the `Phone[type='mobile']` expression, the `type='mobile'` would evaluate to AST that fullfil checks within this function.
 *
 * More info here: https://docs.jsonata.org/path-operators#---order-by
 */
export declare const isFilterNode: (node: JsonataASTNode) => node is FilterNode;
/**
 * Checks whether the node represents an AST that evaluates to a variable.
 * For example, given the `$foo := "bar"` expression, the `$foo` would evaluate to AST that fullfil checks within this function.
 */
export declare const isVariableNode: (node: JsonataASTNode) => node is VariableNode;
/**
 * Checks whether the node represents an AST that evaluates to a JSONata condition.
 * For example, the `property = 3 ? "three": "not three"` would evaluate to AST that fullfil checks within this function.
 */
export declare const isConditionNode: (node: JsonataASTNode) => node is ConditionNode;
/**
 * Checks whether the node represents an AST that evaluates to a JSONata `&` expression.
 * For example, the `"foo" & "bar"` would evaluate to AST that fullfil checks within this function.
 */
export declare const isBinaryNode: (node: JsonataASTNode) => node is BinaryNode;
/**
 * Checks whether the node represents an AST that evaluates to JSONata property assignment expression.
 * For example, the `$myVar := "value"` would evaluate to AST that fullfil checks within this function.
 */
export declare const isBindNode: (node: JsonataASTNode) => node is BindNode;
export declare const isPathNode: (node: JsonataASTNode) => node is PathNode;
export declare const isBlockNode: (node: JsonataASTNode) => node is BlockNode;
/**
 * Checks whether the node represents an AST that evaluates to a `~>` symbol in the context of function chaining.
 * For example, given the `"foo" ~> $uppercase ~> $trim` expression, the `~>` symbol would evaluate to AST that fullfil checks within this function.
 *
 * More info here: https://docs.jsonata.org/other-operators#-chain
 */
export declare const isApplyNode: (node: JsonataASTNode) => node is ApplyNode;
export declare const isUnaryNode: (node: JsonataASTNode) => node is UnaryNode;
export declare const isWildcardNode: (node: JsonataASTNode) => node is WildcardNode;
export declare const isDescendantNode: (node: JsonataASTNode) => node is DescendantNode;
export declare const isRegexNode: (node: JsonataASTNode) => node is RegexNode;
