"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegexNode = exports.isDescendantNode = exports.isWildcardNode = exports.isUnaryNode = exports.isApplyNode = exports.isBlockNode = exports.isPathNode = exports.isBindNode = exports.isBinaryNode = exports.isConditionNode = exports.isVariableNode = exports.isFilterNode = exports.isParentNode = exports.isLambdaNode = exports.isNameNode = exports.isNegationNode = exports.isSortNode = exports.isPartialFunctionNode = exports.isFunctionNode = exports.isPrimitiveNode = exports.isNumberNode = exports.isNullNode = exports.isStringNode = exports.isValueNode = exports.isArrayUnaryNode = exports.isOperatorNode = exports.isObjectUnaryNode = void 0;
/**
 * Checks whether the node represents AST that evaluates to an object.
 * For example, `{"foo": "bar"}` expression would evaluate to AST that fulfills checks within this function.
 *
 * The `isObjectUnaryNode` only checks the underlying structure, and the number of properties or types of values is of no concern for this function.
 */
const isObjectUnaryNode = (node) => {
    if (node.type !== "unary") {
        return false;
    }
    if (node.value !== "{") {
        return false;
    }
    if (!Array.isArray(node.lhs)) {
        return false;
    }
    if (node.lhs.some((tuple) => !Array.isArray(tuple))) {
        return false;
    }
    return true;
};
exports.isObjectUnaryNode = isObjectUnaryNode;
const isOperatorNode = (node) => {
    if (node.type !== "operator") {
        return false;
    }
    return node.value === "?";
};
exports.isOperatorNode = isOperatorNode;
/**
 * Checks whether the node represents and AST that evaluates an array.
 * For example, `[{property: "value"}, {property: "otherValue"}]`, `[1, true, "string"]`, and `[]` expressions would evaluate to AST that fulfills checks within this function.
 */
const isArrayUnaryNode = (node) => {
    if (node.type !== "unary") {
        return false;
    }
    if (node.value !== "[") {
        return false;
    }
    return true;
};
exports.isArrayUnaryNode = isArrayUnaryNode;
const isValueNode = (node) => {
    if (node.type !== "value") {
        return false;
    }
    const allowedValues = [true, false, null];
    return allowedValues.includes(node.value);
};
exports.isValueNode = isValueNode;
const isStringNode = (node) => {
    return node.type === "string";
};
exports.isStringNode = isStringNode;
const isNullNode = (node) => {
    return node.value == null && node.type === "value";
};
exports.isNullNode = isNullNode;
const isNumberNode = (node) => {
    return node.type === "number";
};
exports.isNumberNode = isNumberNode;
/**
 * Checks whether the node represents an AST that evaluates to a primitive node.
 * For example, the `true`, `"hello"` or `1` would all evaluate to AST that fullfil checks within this function.
 */
const isPrimitiveNode = (node) => {
    return ["string", "number", "value"].includes(node.type);
};
exports.isPrimitiveNode = isPrimitiveNode;
/**
 * Checks whether the node represents an AST that evaluates to a JSONata function.
 * For example, the `$length("hi")` would evaluate to AST that fullfil checks within this function.
 */
const isFunctionNode = (node) => {
    if (node.type !== "function") {
        return false;
    }
    if (node.value !== "(") {
        return false;
    }
    return true;
};
exports.isFunctionNode = isFunctionNode;
/**
 * Checks whether the node represents an AST that evaluates to a partially applied function.
 * For example, the `$substring(?, 0, 5)` would evaluate to AST that fullfil checks within this function.
 *
 * Please note, that the partial function has to be declared within a block.
 * More info here: https://docs.jsonata.org/programming#partial-function-application
 */
const isPartialFunctionNode = (node) => {
    if (node.type !== "partial") {
        return false;
    }
    if (node.value !== "(") {
        return false;
    }
    return true;
};
exports.isPartialFunctionNode = isPartialFunctionNode;
/**
 * Checks whether the node represents an AST that evaluates to a `^` symbol in the context of path operators.
 * For example, given the `Product^(Price)` expression, the `^` symbol would evaluate to AST that fullfil checks within this function.
 *
 * More info here: https://docs.jsonata.org/path-operators#---order-by
 */
const isSortNode = (node) => {
    return node.type === "sort";
};
exports.isSortNode = isSortNode;
const isNegationNode = (node) => {
    if (node.type !== "unary") {
        return false;
    }
    if (node.value !== "-") {
        return false;
    }
    return true;
};
exports.isNegationNode = isNegationNode;
/**
 * Checks whether the node represents an AST that evaluates to a key in key:value structure.
 * For example, given the `{foo: "bar"}` expression, the `foo:` would evaluate to AST that fullfil checks within this function.
 */
const isNameNode = (node) => {
    return node.type === "name";
};
exports.isNameNode = isNameNode;
/**
 * Checks whether the node represents an AST that evaluates to a antonymous function declaration.
 * For example, the `function($a, $b){$a + $b}` expression would evaluate to AST that fullfil checks within this function.
 */
const isLambdaNode = (node) => {
    return node.type === "lambda";
};
exports.isLambdaNode = isLambdaNode;
/**
 * Checks whether the node represents an AST that evaluates to a "%" symbol in the context of path operations.
 * For example, given the `MyParent.{'OrderID': %.OrderId}` expression, the `%` would evaluate to AST that fullfil checks within this function.
 */
const isParentNode = (node) => {
    return node.type === "parent";
};
exports.isParentNode = isParentNode;
/**
 * Checks whether the node represents an AST that evaluates to a filter expression predicate.
 * For example, given the `Phone[type='mobile']` expression, the `type='mobile'` would evaluate to AST that fullfil checks within this function.
 *
 * More info here: https://docs.jsonata.org/path-operators#---order-by
 */
const isFilterNode = (node) => {
    return node.type === "filter";
};
exports.isFilterNode = isFilterNode;
/**
 * Checks whether the node represents an AST that evaluates to a variable.
 * For example, given the `$foo := "bar"` expression, the `$foo` would evaluate to AST that fullfil checks within this function.
 */
const isVariableNode = (node) => {
    return node.type === "variable";
};
exports.isVariableNode = isVariableNode;
/**
 * Checks whether the node represents an AST that evaluates to a JSONata condition.
 * For example, the `property = 3 ? "three": "not three"` would evaluate to AST that fullfil checks within this function.
 */
const isConditionNode = (node) => {
    return node.type === "condition";
};
exports.isConditionNode = isConditionNode;
/**
 * Checks whether the node represents an AST that evaluates to a JSONata `&` expression.
 * For example, the `"foo" & "bar"` would evaluate to AST that fullfil checks within this function.
 */
const isBinaryNode = (node) => {
    return node.type === "binary";
};
exports.isBinaryNode = isBinaryNode;
/**
 * Checks whether the node represents an AST that evaluates to JSONata property assignment expression.
 * For example, the `$myVar := "value"` would evaluate to AST that fullfil checks within this function.
 */
const isBindNode = (node) => {
    return node.type === "bind";
};
exports.isBindNode = isBindNode;
const isPathNode = (node) => {
    if (node.type !== "path") {
        return false;
    }
    return Array.isArray(node.steps);
};
exports.isPathNode = isPathNode;
const isBlockNode = (node) => {
    if (node.type !== "block") {
        return false;
    }
    return Array.isArray(node.expressions);
};
exports.isBlockNode = isBlockNode;
/**
 * Checks whether the node represents an AST that evaluates to a `~>` symbol in the context of function chaining.
 * For example, given the `"foo" ~> $uppercase ~> $trim` expression, the `~>` symbol would evaluate to AST that fullfil checks within this function.
 *
 * More info here: https://docs.jsonata.org/other-operators#-chain
 */
const isApplyNode = (node) => {
    if (node.type !== "apply") {
        return false;
    }
    if (node.value !== "~>") {
        return false;
    }
    return true;
};
exports.isApplyNode = isApplyNode;
const isUnaryNode = (node) => {
    if (node.type !== "unary") {
        return false;
    }
    const allowedValues = ["{", "[", "-"];
    return allowedValues.includes(node.value);
};
exports.isUnaryNode = isUnaryNode;
const isWildcardNode = (node) => {
    if (node.type !== "wildcard") {
        return false;
    }
    const allowedValues = ["*", "**"];
    return allowedValues.includes(node.value);
};
exports.isWildcardNode = isWildcardNode;
const isDescendantNode = (node) => {
    if (node.type !== "descendant") {
        return false;
    }
    return typeof node.value === "string";
};
exports.isDescendantNode = isDescendantNode;
const isRegexNode = (node) => {
    if (node.type !== "regex") {
        return false;
    }
    return true;
};
exports.isRegexNode = isRegexNode;
