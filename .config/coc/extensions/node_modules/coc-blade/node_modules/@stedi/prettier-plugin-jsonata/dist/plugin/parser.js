"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.locEnd = exports.locStart = exports.parse = void 0;
const jsonata_1 = __importDefault(require("jsonata"));
const parse = (expression) => {
    try {
        const jsonataComments = [];
        const commentMatches = expression.matchAll(/\/\*((\*(?!\/)|[^*])*)\*\//g);
        for (const commentMatch of commentMatches) {
            const matchedCommentPosition = commentMatch.index;
            if (matchedCommentPosition === undefined)
                continue;
            const matchedCommentBody = commentMatch[1];
            if (!matchedCommentBody)
                continue;
            jsonataComments.push({ position: matchedCommentPosition, value: matchedCommentBody.trim() });
        }
        const ast = (0, jsonata_1.default)(expression).ast();
        return Object.assign(Object.assign({}, ast), { jsonataComments });
    }
    catch (e) {
        const error = e;
        const debugInfoKeys = ["code", "position", "token"];
        const debugInfoParts = debugInfoKeys
            .filter((key) => error[key] !== undefined)
            .map((key) => `${key}: ${error[key]}`);
        const errorMessage = [error.message, ...debugInfoParts].join(", ");
        throw new Error(errorMessage);
    }
};
exports.parse = parse;
const locStart = (node) => node.position;
exports.locStart = locStart;
// JSONata AST is not storing info about the end position of a statement represented by a given node,
// therefore we can't populate the `locEnd` callback correctly.
const locEnd = () => 0;
exports.locEnd = locEnd;
